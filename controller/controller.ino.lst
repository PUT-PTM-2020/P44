
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311/controller.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	0c 94 0d 04 	jmp	0x81a	; 0x81a <__ctors_end>
../../../../crt1/gcrt1.S:63
       4:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:64
       8:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:65
       c:	0c 94 7c 0f 	jmp	0x1ef8	; 0x1ef8 <__vector_3>
../../../../crt1/gcrt1.S:66
      10:	0c 94 57 0f 	jmp	0x1eae	; 0x1eae <__vector_4>
../../../../crt1/gcrt1.S:67
      14:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:68
      18:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:69
      1c:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:70
      20:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:71
      24:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:72
      28:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:73
      2c:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:74
      30:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:75
      34:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:76
      38:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:77
      3c:	0c 94 01 0f 	jmp	0x1e02	; 0x1e02 <__vector_15>
../../../../crt1/gcrt1.S:78
      40:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:79
      44:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:80
      48:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:81
      4c:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:82
      50:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:83
      54:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:84
      58:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:85
      5c:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:86
      60:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__vector_24>
../../../../crt1/gcrt1.S:87
      64:	0c 94 44 10 	jmp	0x2088	; 0x2088 <__vector_25>
../../../../crt1/gcrt1.S:88
      68:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:89
      6c:	0c 94 d3 0e 	jmp	0x1da6	; 0x1da6 <__vector_27>
../../../../crt1/gcrt1.S:90
      70:	0c 94 ad 0e 	jmp	0x1d5a	; 0x1d5a <__vector_28>
../../../../crt1/gcrt1.S:91
      74:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>
../../../../crt1/gcrt1.S:92
      78:	0c 94 35 04 	jmp	0x86a	; 0x86a <__bad_interrupt>

0000007c <__trampolines_end>:
__trampolines_start():
      7c:	fb 00       	.word	0x00fb	; ????
      7e:	00 3e       	cpi	r16, 0xE0	; 224
      80:	00 0b       	sbc	r16, r16
      82:	00 36       	cpi	r16, 0x60	; 96
      84:	00 01       	movw	r0, r0
      86:	00 02       	muls	r16, r16
      88:	00 03       	mulsu	r16, r16
      8a:	00 00       	nop
      8c:	00 65       	ori	r16, 0x50	; 80
      8e:	00 54       	subi	r16, 0x40	; 64
      90:	ff ef       	ldi	r31, 0xFF	; 255
      92:	00 00       	nop
      94:	fa 80       	ldd	r15, Y+2	; 0x02
      96:	00 0b       	sbc	r16, r16
      98:	12 82       	std	Z+2, r1	; 0x02
      9a:	00 01       	movw	r0, r0
      9c:	00 02       	muls	r16, r16
	...
      aa:	00 00       	nop
      ac:	00 28       	or	r0, r0
      ae:	00 00       	nop
      b0:	ff ff       	.word	0xffff	; ????
      b2:	45 81       	ldd	r20, Z+5	; 0x05
      b4:	ff ff       	.word	0xffff	; ????
      b6:	fa 72       	andi	r31, 0x2A	; 42
      b8:	00 00       	nop
      ba:	00 00       	nop
      bc:	00 00       	nop
      be:	03 e8       	ldi	r16, 0x83	; 131
      c0:	00 00       	nop
      c2:	00 01       	movw	r0, r0
      c4:	00 01       	movw	r0, r0
      c6:	7f ff       	.word	0xff7f	; ????
      c8:	ff fe       	.word	0xfeff	; ????
      ca:	80 01       	movw	r16, r0
      cc:	00 1b       	sub	r16, r16
	...
      da:	00 00       	nop
      dc:	00 40       	sbci	r16, 0x00	; 0
      de:	00 00       	nop
      e0:	40 00       	.word	0x0040	; ????
      e2:	00 00       	nop
      e4:	02 cb       	rjmp	.-2556   	; 0xfffff6ea <__eeprom_end+0xff7ef6ea>
      e6:	47 a2       	std	Z+39, r4	; 0x27
      e8:	20 00       	.word	0x0020	; ????
      ea:	00 00       	nop
      ec:	20 00       	.word	0x0020	; ????
      ee:	00 00       	nop
      f0:	00 00       	nop
      f2:	00 00       	nop
      f4:	40 00       	.word	0x0040	; ????
      f6:	00 00       	nop
      f8:	60 00       	.word	0x0060	; ????
      fa:	00 00       	nop
      fc:	41 ff       	sbrs	r20, 1
      fe:	00 00       	nop
     100:	00 00       	nop
     102:	0b 2a       	or	r0, r27
     104:	00 00       	nop
     106:	16 55       	subi	r17, 0x56	; 86
     108:	00 00       	nop
     10a:	21 82       	std	Z+1, r2	; 0x01
     10c:	fd 87       	std	Y+13, r31	; 0x0d
     10e:	26 50       	subi	r18, 0x06	; 6
     110:	fd 80       	ldd	r15, Y+5	; 0x05
     112:	00 00       	nop
     114:	00 1f       	adc	r16, r16
     116:	00 00       	nop
     118:	00 05       	cpc	r16, r0
     11a:	80 00       	.word	0x0080	; ????
     11c:	00 00       	nop
     11e:	00 00       	nop
     120:	00 01       	movw	r0, r0
     122:	00 00       	nop
     124:	00 02       	muls	r16, r16
     126:	00 00       	nop
     128:	00 03       	mulsu	r16, r16
     12a:	00 00       	nop
     12c:	40 00       	.word	0x0040	; ????
     12e:	00 00       	nop
     130:	00 00       	nop
     132:	04 6f       	ori	r16, 0xF4	; 244
     134:	00 02       	muls	r16, r16
     136:	65 32       	cpi	r22, 0x25	; 37
     138:	00 00       	nop
     13a:	5e c0       	rjmp	.+188    	; 0x1f8 <__trampolines_end+0x17c>
     13c:	40 00       	.word	0x0040	; ????
	...
     14a:	00 00       	nop
     14c:	fb 8c       	ldd	r15, Y+27	; 0x1b
     14e:	6f 5d       	subi	r22, 0xDF	; 223
     150:	fd 5d       	subi	r31, 0xDD	; 221
     152:	08 d9       	rcall	.-3568   	; 0xfffff364 <__eeprom_end+0xff7ef364>
     154:	00 7c       	andi	r16, 0xC0	; 192
     156:	73 3b       	cpi	r23, 0xB3	; 179
     158:	00 6c       	ori	r16, 0xC0	; 192
     15a:	12 cc       	rjmp	.-2012   	; 0xfffff980 <__eeprom_end+0xff7ef980>
     15c:	32 00       	.word	0x0032	; ????
     15e:	13 9d       	mul	r17, r3
     160:	32 00       	.word	0x0032	; ????
     162:	d0 d6       	rcall	.+3488   	; 0xf04 <TWI_MasterWriteRead>
     164:	32 00       	.word	0x0032	; ????
     166:	08 00       	.word	0x0008	; ????
     168:	40 00       	.word	0x0040	; ????
     16a:	01 f4       	brne	.+0      	; 0x16c <__trampolines_end+0xf0>
     16c:	ff e6       	ldi	r31, 0x6F	; 111
     16e:	80 79       	andi	r24, 0x90	; 144
     170:	02 00       	.word	0x0002	; ????
     172:	00 00       	nop
     174:	00 00       	nop
     176:	d0 d6       	rcall	.+3488   	; 0xf18 <TWI_MasterWriteRead+0x14>
     178:	00 00       	nop
     17a:	27 10       	cpse	r2, r7
     17c:	fb 00       	.word	0x00fb	; ????
     17e:	00 00       	nop
     180:	40 00       	.word	0x0040	; ????
	...
     18e:	00 01       	movw	r0, r0
     190:	00 00       	nop
     192:	00 00       	nop
     194:	00 00       	nop
     196:	01 00       	.word	0x0001	; ????
     198:	01 00       	.word	0x0001	; ????
     19a:	00 00       	nop
     19c:	00 00       	nop
     19e:	fa 36       	cpi	r31, 0x6A	; 106
     1a0:	ff bc       	out	0x2f, r15	; 47
     1a2:	30 8e       	std	Z+24, r3	; 0x18
     1a4:	00 05       	cpc	r16, r0
     1a6:	fb f0       	brvs	.+62     	; 0x1e6 <__trampolines_end+0x16a>
     1a8:	ff d9       	rcall	.-3074   	; 0xfffff5a8 <__eeprom_end+0xff7ef5a8>
     1aa:	5b c8       	rjmp	.-3914   	; 0xfffff262 <__eeprom_end+0xff7ef262>
     1ac:	ff d0       	rcall	.+510    	; 0x3ac <__trampolines_end+0x330>
     1ae:	9a be       	out	0x3a, r9	; 58
     1b0:	00 00       	nop
     1b2:	10 a9       	ldd	r17, Z+48	; 0x30
     1b4:	ff f4       	brid	.+62     	; 0x1f4 <__trampolines_end+0x178>
     1b6:	1e b2       	in	r1, 0x1e	; 30
     1b8:	00 ce       	rjmp	.-1024   	; 0xfffffdba <__eeprom_end+0xff7efdba>
     1ba:	bb f7       	brvc	.-18     	; 0x1aa <__trampolines_end+0x12e>
     1bc:	00 00       	nop
     1be:	00 01       	movw	r0, r0
     1c0:	00 00       	nop
     1c2:	00 04       	cpc	r0, r0
     1c4:	00 02       	muls	r16, r16
     1c6:	00 02       	muls	r16, r16
     1c8:	02 00       	.word	0x0002	; ????
     1ca:	00 0c       	add	r0, r0
     1cc:	ff c2       	rjmp	.+1534   	; 0x7cc <__LOCK_REGION_LENGTH__+0x3cc>
     1ce:	80 00       	.word	0x0080	; ????
     1d0:	00 01       	movw	r0, r0
     1d2:	80 00       	.word	0x0080	; ????
     1d4:	00 cf       	rjmp	.-512    	; 0xffffffd6 <__eeprom_end+0xff7effd6>
     1d6:	80 00       	.word	0x0080	; ????
     1d8:	40 00       	.word	0x0040	; ????
	...
     1e6:	06 00       	.word	0x0006	; ????
     1e8:	00 00       	nop
     1ea:	00 14       	cp	r0, r0
	...
     20c:	09 23       	and	r16, r25
     20e:	a1 35       	cpi	r26, 0x51	; 81
	...
     220:	03 3f       	cpi	r16, 0xF3	; 243
     222:	68 b6       	in	r6, 0x38	; 56
     224:	79 35       	cpi	r23, 0x59	; 89
     226:	28 bc       	out	0x28, r2	; 40
     228:	c6 7e       	andi	r28, 0xE6	; 230
     22a:	d1 6c       	ori	r29, 0xC1	; 193
     22c:	80 00       	.word	0x0080	; ????
     22e:	ff ff       	.word	0xffff	; ????
     230:	40 00       	.word	0x0040	; ????
     232:	00 00       	nop
     234:	00 00       	nop
     236:	b2 6a       	ori	r27, 0xA2	; 162
	...
     244:	00 00       	nop
     246:	3f f0       	brie	.+14     	; 0x256 <__trampolines_end+0x1da>
     248:	00 00       	nop
     24a:	00 30       	cpi	r16, 0x00	; 0
	...
     268:	00 00       	nop
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	25 4d       	sbci	r18, 0xD5	; 213
     270:	00 2f       	mov	r16, r16
     272:	70 6d       	ori	r23, 0xD0	; 208
     274:	00 00       	nop
     276:	05 ae       	std	Z+61, r0	; 0x3d
     278:	00 0c       	add	r0, r0
     27a:	02 d0       	rcall	.+4      	; 0x280 <__trampolines_end+0x204>
     27c:	00 00       	nop
     27e:	00 00       	nop
     280:	00 65       	ori	r16, 0x50	; 80
     282:	00 54       	subi	r16, 0x40	; 64
     284:	ff ef       	ldi	r31, 0xFF	; 255
	...
     28e:	01 00       	.word	0x0001	; ????
     290:	00 44       	sbci	r16, 0x40	; 64
     292:	00 01       	movw	r0, r0
     294:	00 05       	cpc	r16, r0
     296:	8b c1       	rjmp	.+790    	; 0x5ae <__LOCK_REGION_LENGTH__+0x1ae>
     298:	00 00       	nop
     29a:	01 00       	.word	0x0001	; ????
     29c:	00 00       	nop
     29e:	00 00       	nop
     2a0:	00 65       	ori	r16, 0x50	; 80
     2a2:	00 00       	nop
     2a4:	00 54       	subi	r16, 0x40	; 64
     2a6:	00 00       	nop
     2a8:	ff ef       	ldi	r31, 0xFF	; 255
	...
     2de:	00 01       	movw	r0, r0
     2e0:	00 00       	nop
     2e2:	00 02       	muls	r16, r16
	...
     30c:	00 1b       	sub	r16, r16
	...
     33a:	00 00       	nop
     33c:	00 1b       	sub	r16, r16
	...
     37a:	00 00       	nop
     37c:	d8 dc       	rcall	.-1616   	; 0xfffffd2e <__eeprom_end+0xff7efd2e>
     37e:	ba a2       	std	Y+34, r11	; 0x22
     380:	f1 de       	rcall	.-542    	; 0x164 <__trampolines_end+0xe8>
     382:	b2 b8       	out	0x02, r11	; 2
     384:	b4 a8       	ldd	r11, Z+52	; 0x34
     386:	81 91       	ld	r24, Z+
     388:	f7 4a       	sbci	r31, 0xA7	; 167
     38a:	90 7f       	andi	r25, 0xF0	; 240
     38c:	91 6a       	ori	r25, 0xA1	; 161
     38e:	f3 f9       	bld	r31, 3
     390:	db a8       	ldd	r13, Y+51	; 0x33
     392:	f9 b0       	in	r15, 0x09	; 9
     394:	ba a0       	ldd	r11, Y+34	; 0x22
     396:	80 f2       	brcs	.-96     	; 0x338 <__trampolines_end+0x2bc>
     398:	ce 81       	ldd	r28, Y+6	; 0x06
     39a:	f3 c2       	rjmp	.+1510   	; 0x982 <UartClass::_tx_data_empty_irq()+0x46>
     39c:	f1 c1       	rjmp	.+994    	; 0x780 <__LOCK_REGION_LENGTH__+0x380>
     39e:	f2 c3       	rjmp	.+2020   	; 0xb84 <digitalWrite.part.1+0x52>
     3a0:	f3 cc       	rjmp	.-1562   	; 0xfffffd88 <__eeprom_end+0xff7efd88>
     3a2:	a2 b2       	in	r10, 0x12	; 18
     3a4:	80 f1       	brcs	.+96     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3a6:	c6 d8       	rcall	.-3700   	; 0xfffff534 <__eeprom_end+0xff7ef534>
     3a8:	80 ba       	out	0x10, r8	; 16
     3aa:	a7 df       	rcall	.-178    	; 0x2fa <__trampolines_end+0x27e>
     3ac:	df df       	rcall	.-66     	; 0x36c <__trampolines_end+0x2f0>
     3ae:	f2 a7       	std	Z+42, r31	; 0x2a
     3b0:	c3 cb       	rjmp	.-2170   	; 0xfffffb38 <__eeprom_end+0xff7efb38>
     3b2:	c5 b6       	in	r12, 0x35	; 53
     3b4:	f0 87       	std	Z+8, r31	; 0x08
     3b6:	a2 94       	swap	r10
     3b8:	24 48       	sbci	r18, 0x84	; 132
     3ba:	70 3c       	cpi	r23, 0xC0	; 192
     3bc:	95 40       	sbci	r25, 0x05	; 5
     3be:	68 34       	cpi	r22, 0x48	; 72
     3c0:	58 9b       	sbis	0x0b, 0	; 11
     3c2:	78 a2       	std	Y+32, r7	; 0x20
     3c4:	f1 83       	std	Z+1, r31	; 0x01
     3c6:	92 2d       	mov	r25, r2
     3c8:	55 7d       	andi	r21, 0xD5	; 213
     3ca:	d8 b1       	in	r29, 0x08	; 8
     3cc:	b4 b8       	out	0x04, r11	; 4
     3ce:	a1 d0       	rcall	.+322    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
     3d0:	91 80       	ldd	r9, Z+1	; 0x01
     3d2:	f2 70       	andi	r31, 0x02	; 2
     3d4:	f3 70       	andi	r31, 0x03	; 3
     3d6:	f2 7c       	andi	r31, 0xC2	; 194
     3d8:	80 a8       	ldd	r8, Z+48	; 0x30
     3da:	f1 01       	movw	r30, r2
     3dc:	b0 98       	cbi	0x16, 0	; 22
     3de:	87 d9       	rcall	.-3314   	; 0xfffff6ee <__eeprom_end+0xff7ef6ee>
     3e0:	43 d8       	rcall	.-3962   	; 0xfffff468 <__eeprom_end+0xff7ef468>
     3e2:	86 c9       	rjmp	.-3316   	; 0xfffff6f0 <__eeprom_end+0xff7ef6f0>
     3e4:	88 ba       	out	0x18, r8	; 24
     3e6:	a1 f2       	breq	.-88     	; 0x390 <__trampolines_end+0x314>
     3e8:	0e b8       	out	0x0e, r0	; 14
     3ea:	97 80       	ldd	r9, Z+7	; 0x07
     3ec:	f1 a9       	ldd	r31, Z+49	; 0x31
     3ee:	df df       	rcall	.-66     	; 0x3ae <__trampolines_end+0x332>
     3f0:	df aa       	std	Y+55, r13	; 0x37
     3f2:	df df       	rcall	.-66     	; 0x3b2 <__trampolines_end+0x336>
     3f4:	df f2       	brie	.-74     	; 0x3ac <__trampolines_end+0x330>
     3f6:	aa 4c       	sbci	r26, 0xCA	; 202
     3f8:	cd 6c       	ori	r28, 0xCD	; 205
     3fa:	a9 0c       	add	r10, r9
     3fc:	c9 2c       	mov	r12, r9
     3fe:	97 97       	sbiw	r26, 0x27	; 39
     400:	97 97       	sbiw	r26, 0x27	; 39
     402:	f1 a9       	ldd	r31, Z+49	; 0x31
     404:	89 26       	eor	r8, r25
     406:	46 66       	ori	r20, 0x66	; 102
     408:	b0 b4       	in	r11, 0x20	; 32
     40a:	ba 80       	ldd	r11, Y+2	; 0x02
     40c:	ac de       	rcall	.-680    	; 0x166 <__trampolines_end+0xea>
     40e:	f2 ca       	rjmp	.-2588   	; 0xfffff9f4 <__eeprom_end+0xff7ef9f4>
     410:	f1 b2       	in	r15, 0x11	; 17
     412:	8c 02       	muls	r24, r28
     414:	a9 b6       	in	r10, 0x39	; 57
     416:	98 00       	.word	0x0098	; ????
     418:	89 0e       	add	r8, r25
     41a:	16 1e       	adc	r1, r22
     41c:	b8 a9       	ldd	r27, Y+48	; 0x30
     41e:	b4 99       	sbic	0x16, 4	; 22
     420:	2c 54       	subi	r18, 0x4C	; 76
     422:	7c b0       	in	r7, 0x0c	; 12
     424:	8a a8       	ldd	r8, Y+50	; 0x32
     426:	96 36       	cpi	r25, 0x66	; 102
     428:	56 76       	andi	r21, 0x66	; 102
     42a:	f1 b9       	out	0x01, r31	; 1
     42c:	af b4       	in	r10, 0x2f	; 47
     42e:	b0 83       	st	Z, r27
     430:	c0 b8       	out	0x00, r12	; 0
     432:	a8 97       	sbiw	r28, 0x28	; 40
     434:	11 b1       	in	r17, 0x01	; 1
     436:	8f 98       	cbi	0x11, 7	; 17
     438:	b9 af       	std	Y+57, r27	; 0x39
     43a:	f0 24       	eor	r15, r0
     43c:	08 44       	sbci	r16, 0x48	; 72
     43e:	10 64       	ori	r17, 0x40	; 64
     440:	18 f1       	brcs	.+70     	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
     442:	a3 29       	or	r26, r3
     444:	55 7d       	andi	r21, 0xD5	; 213
     446:	af 83       	std	Y+7, r26	; 0x07
     448:	b5 93       	las	Z, r27
     44a:	af f0       	brie	.+42     	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
     44c:	00 28       	or	r0, r0
     44e:	50 f1       	brcs	.+84     	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
     450:	a3 86       	std	Z+11, r10	; 0x0b
     452:	9f 61       	ori	r25, 0x1F	; 31
     454:	a6 da       	rcall	.-2740   	; 0xfffff9a2 <__eeprom_end+0xff7ef9a2>
     456:	de df       	rcall	.-68     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     458:	d9 fa       	.word	0xfad9	; ????
     45a:	a3 86       	std	Z+11, r10	; 0x0b
     45c:	96 db       	rcall	.-2260   	; 0xfffffb8a <__eeprom_end+0xff7efb8a>
     45e:	31 a6       	std	Z+41, r3	; 0x29
     460:	d9 f8       	.word	0xf8d9	; ????
     462:	df ba       	out	0x1f, r13	; 31
     464:	a6 8f       	std	Z+30, r26	; 0x1e
     466:	c2 c5       	rjmp	.+2948   	; 0xfec <TwoWire::peek()+0x14>
     468:	c7 b2       	in	r12, 0x17	; 23
     46a:	8c c1       	rjmp	.+792    	; 0x784 <__LOCK_REGION_LENGTH__+0x384>
     46c:	b8 a2       	std	Y+32, r11	; 0x20
     46e:	df df       	rcall	.-66     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     470:	df a3       	std	Y+39, r29	; 0x27
     472:	df df       	rcall	.-66     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     474:	df d8       	rcall	.-3650   	; 0xfffff634 <__eeprom_end+0xff7ef634>
     476:	d8 f1       	brcs	.+118    	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
     478:	b8 a8       	ldd	r11, Y+48	; 0x30
     47a:	b2 86       	std	Z+10, r11	; 0x0a
     47c:	b4 98       	cbi	0x16, 4	; 22
     47e:	0d 35       	cpi	r16, 0x5D	; 93
     480:	5d b8       	out	0x0d, r5	; 13
     482:	aa 98       	cbi	0x15, 2	; 21
     484:	b0 87       	std	Z+8, r27	; 0x08
     486:	2d 35       	cpi	r18, 0x5D	; 93
     488:	3d b2       	in	r3, 0x1d	; 29
     48a:	b6 ba       	out	0x16, r11	; 22
     48c:	af 8c       	ldd	r10, Y+31	; 0x1f
     48e:	96 19       	sub	r25, r6
     490:	8f 9f       	mul	r24, r31
     492:	a7 0e       	add	r10, r23
     494:	16 1e       	adc	r1, r22
     496:	b4 9a       	sbi	0x16, 4	; 22
     498:	b8 aa       	std	Y+48, r11	; 0x30
     49a:	87 2c       	mov	r8, r7
     49c:	54 7c       	andi	r21, 0xC4	; 196
     49e:	b9 a3       	std	Y+33, r27	; 0x21
     4a0:	de df       	rcall	.-68     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     4a2:	df a3       	std	Y+39, r29	; 0x27
     4a4:	b1 80       	ldd	r11, Z+1	; 0x01
     4a6:	f2 c4       	rjmp	.+2532   	; 0xe8c <port_interrupt_handler+0x3e>
     4a8:	cd c9       	rjmp	.-3174   	; 0xfffff844 <__eeprom_end+0xff7ef844>
     4aa:	f1 b8       	out	0x01, r15	; 1
     4ac:	a9 b4       	in	r10, 0x29	; 41
     4ae:	99 83       	std	Y+1, r25	; 0x01
     4b0:	0d 35       	cpi	r16, 0x5D	; 93
     4b2:	5d 89       	ldd	r21, Y+21	; 0x15
     4b4:	b9 a3       	std	Y+33, r27	; 0x21
     4b6:	2d 55       	subi	r18, 0x5D	; 93
     4b8:	7d b5       	in	r23, 0x2d	; 45
     4ba:	93 a3       	std	Z+35, r25	; 0x23
     4bc:	0e 16       	cp	r0, r30
     4be:	1e a9       	ldd	r17, Y+54	; 0x36
     4c0:	2c 54       	subi	r18, 0x4C	; 76
     4c2:	7c b8       	out	0x0c, r7	; 12
     4c4:	b4 b0       	in	r11, 0x04	; 4
     4c6:	f1 97       	sbiw	r30, 0x31	; 49
     4c8:	83 a8       	ldd	r8, Z+51	; 0x33
     4ca:	11 84       	ldd	r1, Z+9	; 0x09
     4cc:	a5 09       	sbc	r26, r5
     4ce:	98 a3       	std	Y+32, r25	; 0x20
     4d0:	83 f0       	brvs	.+32     	; 0x4f2 <__LOCK_REGION_LENGTH__+0xf2>
     4d2:	da 24       	eor	r13, r10
     4d4:	08 44       	sbci	r16, 0x48	; 72
     4d6:	10 64       	ori	r17, 0x40	; 64
     4d8:	18 d8       	rcall	.-4048   	; 0xfffff50a <__eeprom_end+0xff7ef50a>
     4da:	f1 a5       	ldd	r31, Z+41	; 0x29
     4dc:	29 55       	subi	r18, 0x59	; 89
     4de:	7d a5       	ldd	r23, Y+45	; 0x2d
     4e0:	85 95       	asr	r24
     4e2:	02 1a       	sub	r0, r18
     4e4:	2e 3a       	cpi	r18, 0xAE	; 174
     4e6:	56 5a       	subi	r21, 0xA6	; 166
     4e8:	40 48       	sbci	r20, 0x80	; 128
     4ea:	f9 f3       	breq	.-2      	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     4ec:	a3 d9       	rcall	.-3258   	; 0xfffff834 <__eeprom_end+0xff7ef834>
     4ee:	f8 f0       	brcs	.+62     	; 0x52e <__LOCK_REGION_LENGTH__+0x12e>
     4f0:	98 83       	st	Y, r25
     4f2:	24 08       	sbc	r2, r4
     4f4:	44 10       	cpse	r4, r4
     4f6:	64 18       	sub	r6, r4
     4f8:	97 82       	std	Z+7, r9	; 0x07
     4fa:	a8 f1       	brcs	.+106    	; 0x566 <__LOCK_REGION_LENGTH__+0x166>
     4fc:	11 f0       	breq	.+4      	; 0x502 <__LOCK_REGION_LENGTH__+0x102>
     4fe:	98 a2       	std	Y+32, r9	; 0x20
     500:	24 08       	sbc	r2, r4
     502:	44 10       	cpse	r4, r4
     504:	64 18       	sub	r6, r4
     506:	da f3       	brmi	.-10     	; 0x4fe <__LOCK_REGION_LENGTH__+0xfe>
     508:	de d8       	rcall	.-3652   	; 0xfffff6c6 <__eeprom_end+0xff7ef6c6>
     50a:	83 a5       	ldd	r24, Z+43	; 0x2b
     50c:	94 01       	movw	r18, r8
     50e:	d9 a3       	std	Y+33, r29	; 0x21
     510:	02 f1       	brmi	.+64     	; 0x552 <__LOCK_REGION_LENGTH__+0x152>
     512:	a2 c3       	rjmp	.+1860   	; 0xc58 <UartClass::begin(unsigned long, unsigned int)+0x1c>
     514:	c5 c7       	rjmp	.+3978   	; 0x14a0 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x66>
     516:	d8 f1       	brcs	.+118    	; 0x58e <__LOCK_REGION_LENGTH__+0x18e>
     518:	84 92       	xch	Z, r8
     51a:	a2 4d       	sbci	r26, 0xD2	; 210
     51c:	da 2a       	or	r13, r26
     51e:	d8 48       	sbci	r29, 0x88	; 136
     520:	69 d9       	rcall	.-3374   	; 0xfffff7f4 <__eeprom_end+0xff7ef7f4>
     522:	2a d8       	rcall	.-4012   	; 0xfffff578 <__eeprom_end+0xff7ef578>
     524:	68 55       	subi	r22, 0x58	; 88
     526:	da 32       	cpi	r29, 0x2A	; 42
     528:	d8 50       	subi	r29, 0x08	; 8
     52a:	71 d9       	rcall	.-3358   	; 0xfffff80e <__eeprom_end+0xff7ef80e>
     52c:	32 d8       	rcall	.-3996   	; 0xfffff592 <__eeprom_end+0xff7ef592>
     52e:	70 5d       	subi	r23, 0xD0	; 208
     530:	da 3a       	cpi	r29, 0xAA	; 170
     532:	d8 58       	subi	r29, 0x88	; 136
     534:	79 d9       	rcall	.-3342   	; 0xfffff828 <__eeprom_end+0xff7ef828>
     536:	3a d8       	rcall	.-3980   	; 0xfffff5ac <__eeprom_end+0xff7ef5ac>
     538:	78 93       	.word	0x9378	; ????
     53a:	a3 4d       	sbci	r26, 0xD3	; 211
     53c:	da 2a       	or	r13, r26
     53e:	d8 48       	sbci	r29, 0x88	; 136
     540:	69 d9       	rcall	.-3374   	; 0xfffff814 <__eeprom_end+0xff7ef814>
     542:	2a d8       	rcall	.-4012   	; 0xfffff598 <__eeprom_end+0xff7ef598>
     544:	68 55       	subi	r22, 0x58	; 88
     546:	da 32       	cpi	r29, 0x2A	; 42
     548:	d8 50       	subi	r29, 0x08	; 8
     54a:	71 d9       	rcall	.-3358   	; 0xfffff82e <__eeprom_end+0xff7ef82e>
     54c:	32 d8       	rcall	.-3996   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     54e:	70 5d       	subi	r23, 0xD0	; 208
     550:	da 3a       	cpi	r29, 0xAA	; 170
     552:	d8 58       	subi	r29, 0x88	; 136
     554:	79 d9       	rcall	.-3342   	; 0xfffff848 <__eeprom_end+0xff7ef848>
     556:	3a d8       	rcall	.-3980   	; 0xfffff5cc <__eeprom_end+0xff7ef5cc>
     558:	78 a8       	ldd	r7, Y+48	; 0x30
     55a:	8a 9a       	sbi	0x11, 2	; 17
     55c:	f0 28       	or	r15, r0
     55e:	50 78       	andi	r21, 0x80	; 128
     560:	9e f3       	brts	.-26     	; 0x548 <__LOCK_REGION_LENGTH__+0x148>
     562:	88 18       	sub	r8, r8
     564:	f1 9f       	mul	r31, r17
     566:	1d 98       	cbi	0x03, 5	; 3
     568:	a8 d9       	rcall	.-3248   	; 0xfffff8ba <__eeprom_end+0xff7ef8ba>
     56a:	08 d8       	rcall	.-4080   	; 0xfffff57c <__eeprom_end+0xff7ef57c>
     56c:	c8 9f       	mul	r28, r24
     56e:	12 9e       	mul	r1, r18
     570:	f3 15       	cp	r31, r3
     572:	a8 da       	rcall	.-2736   	; 0xfffffac4 <__eeprom_end+0xff7efac4>
     574:	12 10       	cpse	r1, r2
     576:	d8 f1       	brcs	.+118    	; 0x5ee <__LOCK_REGION_LENGTH__+0x1ee>
     578:	af c8       	rjmp	.-3746   	; 0xfffff6d8 <__eeprom_end+0xff7ef6d8>
     57a:	97 87       	std	Z+15, r25	; 0x0f
     57c:	34 b5       	in	r19, 0x24	; 36
     57e:	b9 94       	.word	0x94b9	; ????
     580:	a4 21       	and	r26, r4
     582:	f3 d9       	rcall	.-3098   	; 0xfffff96a <__eeprom_end+0xff7ef96a>
     584:	22 d8       	rcall	.-4028   	; 0xfffff5ca <__eeprom_end+0xff7ef5ca>
     586:	f2 2d       	mov	r31, r2
     588:	f3 d9       	rcall	.-3098   	; 0xfffff970 <__eeprom_end+0xff7ef970>
     58a:	2a d8       	rcall	.-4012   	; 0xfffff5e0 <__eeprom_end+0xff7ef5e0>
     58c:	f2 35       	cpi	r31, 0x52	; 82
     58e:	f3 d9       	rcall	.-3098   	; 0xfffff976 <__eeprom_end+0xff7ef976>
     590:	32 d8       	rcall	.-3996   	; 0xfffff5f6 <__eeprom_end+0xff7ef5f6>
     592:	81 a4       	ldd	r8, Z+41	; 0x29
     594:	60 60       	ori	r22, 0x00	; 0
     596:	61 d9       	rcall	.-3390   	; 0xfffff85a <__eeprom_end+0xff7ef85a>
     598:	61 d8       	rcall	.-3902   	; 0xfffff65c <__eeprom_end+0xff7ef65c>
     59a:	6c 68       	ori	r22, 0x8C	; 140
     59c:	69 d9       	rcall	.-3374   	; 0xfffff870 <__eeprom_end+0xff7ef870>
     59e:	69 d8       	rcall	.-3886   	; 0xfffff672 <__eeprom_end+0xff7ef672>
     5a0:	74 70       	andi	r23, 0x04	; 4
     5a2:	71 d9       	rcall	.-3358   	; 0xfffff886 <__eeprom_end+0xff7ef886>
     5a4:	71 d8       	rcall	.-3870   	; 0xfffff688 <__eeprom_end+0xff7ef688>
     5a6:	b1 a3       	std	Z+33, r27	; 0x21
     5a8:	84 19       	sub	r24, r4
     5aa:	3d 5d       	subi	r19, 0xDD	; 221
     5ac:	a3 83       	std	Z+3, r26	; 0x03
     5ae:	1a 3e       	cpi	r17, 0xEA	; 234
     5b0:	5e 93       	st	-X, r21
     5b2:	10 30       	cpi	r17, 0x00	; 0
     5b4:	81 10       	cpse	r8, r1
     5b6:	11 b8       	out	0x01, r1	; 1
     5b8:	b0 af       	std	Z+56, r27	; 0x38
     5ba:	8f 94 f2 da 	call	0x23b5e4	; 0x23b5e4 <__TEXT_REGION_LENGTH__+0x13b5e4>
     5be:	3e d8       	rcall	.-3972   	; 0xfffff63c <__eeprom_end+0xff7ef63c>
     5c0:	b4 9a       	sbi	0x16, 4	; 22
     5c2:	a8 87       	std	Y+8, r26	; 0x08
     5c4:	29 da       	rcall	.-2990   	; 0xfffffa18 <__eeprom_end+0xff7efa18>
     5c6:	f8 d8       	rcall	.-3600   	; 0xfffff7b8 <__eeprom_end+0xff7ef7b8>
     5c8:	87 9a       	sbi	0x10, 7	; 16
     5ca:	35 da       	rcall	.-2966   	; 0xfffffa36 <__eeprom_end+0xff7efa36>
     5cc:	f8 d8       	rcall	.-3600   	; 0xfffff7be <__eeprom_end+0xff7ef7be>
     5ce:	87 9a       	sbi	0x10, 7	; 16
     5d0:	3d da       	rcall	.-2950   	; 0xfffffa4c <__eeprom_end+0xff7efa4c>
     5d2:	f8 d8       	rcall	.-3600   	; 0xfffff7c4 <__eeprom_end+0xff7ef7c4>
     5d4:	b1 b9       	out	0x01, r27	; 1
     5d6:	a4 98       	cbi	0x14, 4	; 20
     5d8:	85 02       	muls	r24, r21
     5da:	2e 56       	subi	r18, 0x6E	; 110
     5dc:	a5 81       	ldd	r26, Z+5	; 0x05
     5de:	00 0c       	add	r0, r0
     5e0:	14 a3       	std	Z+36, r17	; 0x24
     5e2:	97 b0       	in	r9, 0x07	; 7
     5e4:	8a f1       	brmi	.+98     	; 0x648 <__LOCK_REGION_LENGTH__+0x248>
     5e6:	2d d9       	rcall	.-3494   	; 0xfffff842 <__eeprom_end+0xff7ef842>
     5e8:	28 d8       	rcall	.-4016   	; 0xfffff63a <__eeprom_end+0xff7ef63a>
     5ea:	4d d9       	rcall	.-3430   	; 0xfffff886 <__eeprom_end+0xff7ef886>
     5ec:	48 d8       	rcall	.-3952   	; 0xfffff67e <__eeprom_end+0xff7ef67e>
     5ee:	6d d9       	rcall	.-3366   	; 0xfffff8ca <__eeprom_end+0xff7ef8ca>
     5f0:	68 d8       	rcall	.-3888   	; 0xfffff6c2 <__eeprom_end+0xff7ef6c2>
     5f2:	b1 84       	ldd	r11, Z+9	; 0x09
     5f4:	0d da       	rcall	.-3046   	; 0xfffffa10 <__eeprom_end+0xff7efa10>
     5f6:	0e d8       	rcall	.-4068   	; 0xfffff614 <__eeprom_end+0xff7ef614>
     5f8:	a3 29       	or	r26, r3
     5fa:	83 da       	rcall	.-2810   	; 0xfffffb02 <__eeprom_end+0xff7efb02>
     5fc:	2c 0e       	add	r2, r28
     5fe:	d8 a3       	std	Y+32, r29	; 0x20
     600:	84 49       	sbci	r24, 0x94	; 148
     602:	83 da       	rcall	.-2810   	; 0xfffffb0a <__eeprom_end+0xff7efb0a>
     604:	2c 4c       	sbci	r18, 0xCC	; 204
     606:	0e d8       	rcall	.-4068   	; 0xfffff624 <__eeprom_end+0xff7ef624>
     608:	b8 b0       	in	r11, 0x08	; 8
     60a:	a8 8a       	std	Y+16, r10	; 0x10
     60c:	9a f5       	brpl	.+102    	; 0x674 <__LOCK_REGION_LENGTH__+0x274>
     60e:	20 aa       	std	Z+48, r2	; 0x30
     610:	da df       	rcall	.-76     	; 0x5c6 <__LOCK_REGION_LENGTH__+0x1c6>
     612:	d8 a8       	ldd	r13, Y+48	; 0x30
     614:	40 aa       	std	Z+48, r4	; 0x30
     616:	d0 da       	rcall	.-2656   	; 0xfffffbb8 <__eeprom_end+0xff7efbb8>
     618:	de d8       	rcall	.-3652   	; 0xfffff7d6 <__eeprom_end+0xff7ef7d6>
     61a:	a8 60       	ori	r26, 0x08	; 8
     61c:	aa da       	rcall	.-2732   	; 0xfffffb72 <__eeprom_end+0xff7efb72>
     61e:	d0 df       	rcall	.-96     	; 0x5c0 <__LOCK_REGION_LENGTH__+0x1c0>
     620:	d8 f1       	brcs	.+118    	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
     622:	97 86       	std	Z+15, r9	; 0x0f
     624:	a8 31       	cpi	r26, 0x18	; 24
     626:	9b 06       	cpc	r9, r27
     628:	99 07       	cpc	r25, r25
     62a:	ab 97       	sbiw	r28, 0x2b	; 43
     62c:	28 88       	ldd	r2, Y+16	; 0x10
     62e:	9b f0       	brvs	.+38     	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
     630:	0c 20       	and	r0, r12
     632:	14 40       	sbci	r17, 0x04	; 4
     634:	b8 b0       	in	r11, 0x08	; 8
     636:	b4 a8       	ldd	r11, Z+52	; 0x34
     638:	8c 9c       	mul	r8, r12
     63a:	f0 04       	cpc	r15, r0
     63c:	28 51       	subi	r18, 0x18	; 24
     63e:	79 1d       	adc	r23, r9
     640:	30 14       	cp	r3, r0
     642:	38 b2       	in	r3, 0x18	; 24
     644:	82 ab       	std	Z+50, r24	; 0x32
     646:	d0 98       	cbi	0x1a, 0	; 26
     648:	2c 50       	subi	r18, 0x0C	; 12
     64a:	50 78       	andi	r21, 0x80	; 128
     64c:	78 9b       	sbis	0x0f, 0	; 15
     64e:	f1 1a       	sub	r15, r17
     650:	b0 f0       	brcs	.+44     	; 0x67e <__LOCK_REGION_LENGTH__+0x27e>
     652:	8a 9c       	mul	r8, r10
     654:	a8 29       	or	r26, r8
     656:	51 79       	andi	r21, 0x91	; 145
     658:	8b 29       	or	r24, r11
     65a:	51 79       	andi	r21, 0x91	; 145
     65c:	8a 24       	eor	r8, r10
     65e:	70 59       	subi	r23, 0x90	; 144
     660:	8b 20       	and	r8, r11
     662:	58 71       	andi	r21, 0x18	; 24
     664:	8a 44       	sbci	r24, 0x4A	; 74
     666:	69 38       	cpi	r22, 0x89	; 137
     668:	8b 39       	cpi	r24, 0x9B	; 155
     66a:	40 68       	ori	r20, 0x80	; 128
     66c:	8a 64       	ori	r24, 0x4A	; 74
     66e:	48 31       	cpi	r20, 0x18	; 24
     670:	8b 30       	cpi	r24, 0x0B	; 11
     672:	49 60       	ori	r20, 0x09	; 9
     674:	a5 88       	ldd	r10, Z+21	; 0x15
     676:	20 09       	sbc	r18, r0
     678:	71 58       	subi	r23, 0x81	; 129
     67a:	44 68       	ori	r20, 0x84	; 132
     67c:	11 39       	cpi	r17, 0x91	; 145
     67e:	64 49       	sbci	r22, 0x94	; 148
     680:	30 19       	sub	r19, r0
     682:	f1 ac       	ldd	r15, Z+57	; 0x39
     684:	00 2c       	mov	r0, r0
     686:	54 7c       	andi	r21, 0xC4	; 196
     688:	f0 8c       	ldd	r15, Z+24	; 0x18
     68a:	a8 04       	cpc	r10, r8
     68c:	28 50       	subi	r18, 0x08	; 8
     68e:	78 f1       	brcs	.+94     	; 0x6ee <__LOCK_REGION_LENGTH__+0x2ee>
     690:	88 97       	sbiw	r24, 0x28	; 40
     692:	26 a8       	ldd	r2, Z+54	; 0x36
     694:	59 98       	cbi	0x0b, 1	; 11
     696:	ac 8c       	ldd	r10, Y+28	; 0x1c
     698:	02 26       	eor	r0, r18
     69a:	46 66       	ori	r20, 0x66	; 102
     69c:	f0 89       	ldd	r31, Z+16	; 0x10
     69e:	9c a8       	ldd	r9, Y+52	; 0x34
     6a0:	29 51       	subi	r18, 0x19	; 25
     6a2:	79 24       	eor	r7, r9
     6a4:	70 59       	subi	r23, 0x90	; 144
     6a6:	44 69       	ori	r20, 0x94	; 148
     6a8:	38 64       	ori	r19, 0x48	; 72
     6aa:	48 31       	cpi	r20, 0x18	; 24
     6ac:	a9 88       	ldd	r10, Y+17	; 0x11
     6ae:	09 20       	and	r0, r9
     6b0:	59 70       	andi	r21, 0x09	; 9
     6b2:	ab 11       	cpse	r26, r11
     6b4:	38 40       	sbci	r19, 0x08	; 8
     6b6:	69 a8       	ldd	r6, Y+49	; 0x31
     6b8:	19 31       	cpi	r17, 0x19	; 25
     6ba:	48 60       	ori	r20, 0x08	; 8
     6bc:	8c a8       	ldd	r8, Y+52	; 0x34
     6be:	3c 41       	sbci	r19, 0x1C	; 28
     6c0:	5c 20       	and	r5, r12
     6c2:	7c 00       	.word	0x007c	; ????
     6c4:	f1 87       	std	Z+9, r31	; 0x09
     6c6:	98 19       	sub	r25, r8
     6c8:	86 a8       	ldd	r8, Z+54	; 0x36
     6ca:	6e 76       	andi	r22, 0x6E	; 110
     6cc:	7e a9       	ldd	r23, Y+54	; 0x36
     6ce:	99 88       	ldd	r9, Y+17	; 0x11
     6d0:	2d 55       	subi	r18, 0x5D	; 93
     6d2:	7d 9e       	mul	r7, r29
     6d4:	b9 a3       	std	Y+33, r27	; 0x21
     6d6:	8a 22       	and	r8, r26
     6d8:	8a 6e       	ori	r24, 0xEA	; 234
     6da:	8a 56       	subi	r24, 0x6A	; 106
     6dc:	8a 5e       	subi	r24, 0xEA	; 234
     6de:	9f b1       	in	r25, 0x0f	; 15
     6e0:	83 06       	cpc	r8, r19
     6e2:	26 46       	sbci	r18, 0x66	; 102
     6e4:	66 0e       	add	r6, r22
     6e6:	2e 4e       	sbci	r18, 0xEE	; 238
     6e8:	6e 9d       	mul	r22, r14
     6ea:	b8 ad       	ldd	r27, Y+56	; 0x38
     6ec:	00 2c       	mov	r0, r0
     6ee:	54 7c       	andi	r21, 0xC4	; 196
     6f0:	f2 b1       	in	r31, 0x02	; 2
     6f2:	8c b4       	in	r8, 0x2c	; 44
     6f4:	99 b9       	out	0x09, r25	; 9
     6f6:	a3 2d       	mov	r26, r3
     6f8:	55 7d       	andi	r21, 0xD5	; 213
     6fa:	81 91       	ld	r24, Z+
     6fc:	ac 38       	cpi	r26, 0x8C	; 140
     6fe:	ad 3a       	cpi	r26, 0xAD	; 173
     700:	b5 83       	std	Z+5, r27	; 0x05
     702:	91 ac       	ldd	r9, Z+57	; 0x39
     704:	2d d9       	rcall	.-3494   	; 0xfffff960 <__eeprom_end+0xff7ef960>
     706:	28 d8       	rcall	.-4016   	; 0xfffff758 <__eeprom_end+0xff7ef758>
     708:	4d d9       	rcall	.-3430   	; 0xfffff9a4 <__eeprom_end+0xff7ef9a4>
     70a:	48 d8       	rcall	.-3952   	; 0xfffff79c <__eeprom_end+0xff7ef79c>
     70c:	6d d9       	rcall	.-3366   	; 0xfffff9e8 <__eeprom_end+0xff7ef9e8>
     70e:	68 d8       	rcall	.-3888   	; 0xfffff7e0 <__eeprom_end+0xff7ef7e0>
     710:	8c 9d       	mul	r24, r12
     712:	ae 29       	or	r26, r14
     714:	d9 04       	cpc	r13, r9
     716:	ae d8       	rcall	.-3748   	; 0xfffff874 <__eeprom_end+0xff7ef874>
     718:	51 d9       	rcall	.-3422   	; 0xfffff9bc <__eeprom_end+0xff7ef9bc>
     71a:	04 ae       	std	Z+60, r0	; 0x3c
     71c:	d8 79       	andi	r29, 0x98	; 152
     71e:	d9 04       	cpc	r13, r9
     720:	d8 81       	ld	r29, Y
     722:	f3 9d       	mul	r31, r3
     724:	ad 00       	.word	0x00ad	; ????
     726:	8d ae       	std	Y+61, r8	; 0x3d
     728:	19 81       	ldd	r17, Y+1	; 0x01
     72a:	ad d9       	rcall	.-3238   	; 0xfffffa86 <__eeprom_end+0xff7efa86>
     72c:	01 d8       	rcall	.-4094   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     72e:	f2 ae       	std	Z+58, r15	; 0x3a
     730:	da 26       	eor	r13, r26
     732:	d8 8e       	std	Y+24, r13	; 0x18
     734:	91 29       	or	r25, r1
     736:	83 a7       	std	Z+43, r24	; 0x2b
     738:	d9 ad       	ldd	r29, Y+57	; 0x39
     73a:	ad ad       	ldd	r26, Y+61	; 0x3d
     73c:	ad f3       	brhs	.-22     	; 0x728 <__LOCK_REGION_LENGTH__+0x328>
     73e:	2a d8       	rcall	.-4012   	; 0xfffff794 <__eeprom_end+0xff7ef794>
     740:	d8 f1       	brcs	.+118    	; 0x7b8 <__LOCK_REGION_LENGTH__+0x3b8>
     742:	b0 ac       	ldd	r11, Z+56	; 0x38
     744:	89 91       	ld	r24, Y+
     746:	3e 5e       	subi	r19, 0xEE	; 238
     748:	76 f3       	brts	.-36     	; 0x726 <__LOCK_REGION_LENGTH__+0x326>
     74a:	ac 2e       	mov	r10, r28
     74c:	2e f1       	brts	.+74     	; 0x798 <__LOCK_REGION_LENGTH__+0x398>
     74e:	b1 8c       	ldd	r11, Z+25	; 0x19
     750:	5a 9c       	mul	r5, r10
     752:	ac 2c       	mov	r10, r12
     754:	28 28       	or	r2, r8
     756:	28 9c       	mul	r2, r8
     758:	ac 30       	cpi	r26, 0x0C	; 12
     75a:	18 a8       	ldd	r1, Y+48	; 0x30
     75c:	98 81       	ld	r25, Y
     75e:	28 34       	cpi	r18, 0x48	; 72
     760:	3c 97       	sbiw	r30, 0x0c	; 12
     762:	24 a7       	std	Z+44, r18	; 0x2c
     764:	28 34       	cpi	r18, 0x48	; 72
     766:	3c 9c       	mul	r3, r12
     768:	24 f2       	brlt	.-120    	; 0x6f2 <__LOCK_REGION_LENGTH__+0x2f2>
     76a:	b0 89       	ldd	r27, Z+16	; 0x10
     76c:	ac 91       	ld	r26, X
     76e:	2c 4c       	sbci	r18, 0xCC	; 204
     770:	6c 8a       	std	Y+20, r6	; 0x14
     772:	9b 2d       	mov	r25, r11
     774:	d9 d8       	rcall	.-3662   	; 0xfffff928 <__eeprom_end+0xff7ef928>
     776:	d8 51       	subi	r29, 0x18	; 24
     778:	d9 d8       	rcall	.-3662   	; 0xfffff92c <__eeprom_end+0xff7ef92c>
     77a:	d8 79       	andi	r29, 0x98	; 152
     77c:	d9 d8       	rcall	.-3662   	; 0xfffff930 <__eeprom_end+0xff7ef930>
     77e:	d8 f1       	brcs	.+118    	; 0x7f6 <__LOCK_REGION_LENGTH__+0x3f6>
     780:	9e 88       	ldd	r9, Y+22	; 0x16
     782:	a3 31       	cpi	r26, 0x13	; 19
     784:	da d8       	rcall	.-3660   	; 0xfffff93a <__eeprom_end+0xff7ef93a>
     786:	d8 91       	.word	0x91d8	; ????
     788:	2d d9       	rcall	.-3494   	; 0xfffff9e4 <__eeprom_end+0xff7ef9e4>
     78a:	28 d8       	rcall	.-4016   	; 0xfffff7dc <__eeprom_end+0xff7ef7dc>
     78c:	4d d9       	rcall	.-3430   	; 0xfffffa28 <__eeprom_end+0xff7efa28>
     78e:	48 d8       	rcall	.-3952   	; 0xfffff820 <__eeprom_end+0xff7ef820>
     790:	6d d9       	rcall	.-3366   	; 0xfffffa6c <__eeprom_end+0xff7efa6c>
     792:	68 d8       	rcall	.-3888   	; 0xfffff864 <__eeprom_end+0xff7ef864>
     794:	b1 83       	std	Z+1, r27	; 0x01
     796:	93 35       	cpi	r25, 0x53	; 83
     798:	3d 80       	ldd	r3, Y+5	; 0x05
     79a:	25 da       	rcall	.-2998   	; 0xfffffbe6 <__eeprom_end+0xff7efbe6>
     79c:	d8 d8       	rcall	.-3664   	; 0xfffff94e <__eeprom_end+0xff7ef94e>
     79e:	85 69       	ori	r24, 0x95	; 149
     7a0:	da d8       	rcall	.-3660   	; 0xfffff956 <__eeprom_end+0xff7ef956>
     7a2:	d8 b4       	in	r13, 0x28	; 40
     7a4:	93 81       	ldd	r25, Z+3	; 0x03
     7a6:	a3 28       	or	r10, r3
     7a8:	34 3c       	cpi	r19, 0xC4	; 196
     7aa:	f3 ab       	std	Z+51, r31	; 0x33
     7ac:	8b f8       	.word	0xf88b	; ????
     7ae:	a3 91       	.word	0x91a3	; ????
     7b0:	b6 09       	sbc	r27, r6
     7b2:	b4 d9       	rcall	.-3224   	; 0xfffffb1c <__eeprom_end+0xff7efb1c>
     7b4:	ab de       	rcall	.-682    	; 0x50c <__LOCK_REGION_LENGTH__+0x10c>
     7b6:	fa b0       	in	r15, 0x0a	; 10
     7b8:	87 9c       	mul	r8, r7
     7ba:	b9 a3       	std	Y+33, r27	; 0x21
     7bc:	dd f1       	brhs	.+118    	; 0x834 <.do_clear_bss_start+0x4>
     7be:	20 28       	or	r2, r0
     7c0:	30 38       	cpi	r19, 0x80	; 128
     7c2:	9a f1       	brmi	.+102    	; 0x82a <__do_clear_bss+0x4>
     7c4:	28 30       	cpi	r18, 0x08	; 8
     7c6:	38 9d       	mul	r19, r8
     7c8:	f1 a3       	std	Z+33, r31	; 0x21
     7ca:	a3 a3       	std	Z+35, r26	; 0x23
     7cc:	a3 f2       	brvs	.-88     	; 0x776 <__LOCK_REGION_LENGTH__+0x376>
     7ce:	a3 b4       	in	r10, 0x23	; 35
     7d0:	90 80       	ld	r9, Z
     7d2:	f2 a3       	std	Z+34, r31	; 0x22
     7d4:	a3 a3       	std	Z+35, r26	; 0x23
     7d6:	a3 a3       	std	Z+35, r26	; 0x23
     7d8:	a3 a3       	std	Z+35, r26	; 0x23
     7da:	a3 a3       	std	Z+35, r26	; 0x23
     7dc:	a3 b2       	in	r10, 0x13	; 19
     7de:	a3 a3       	std	Z+35, r26	; 0x23
     7e0:	a3 a3       	std	Z+35, r26	; 0x23
     7e2:	a3 a3       	std	Z+35, r26	; 0x23
     7e4:	b0 87       	std	Z+8, r27	; 0x08
     7e6:	b5 99       	sbic	0x16, 5	; 22
     7e8:	f1 28       	or	r15, r1
     7ea:	30 38       	cpi	r19, 0x80	; 128
     7ec:	98 f1       	brcs	.+102    	; 0x854 <__do_global_ctors+0x8>
     7ee:	a3 a3       	std	Z+35, r26	; 0x23
     7f0:	a3 a3       	std	Z+35, r26	; 0x23
     7f2:	97 a3       	std	Z+39, r25	; 0x27
     7f4:	a3 a3       	std	Z+35, r26	; 0x23
     7f6:	a3 f3       	brvs	.-24     	; 0x7e0 <__LOCK_REGION_LENGTH__+0x3e0>
     7f8:	9b a3       	std	Y+35, r25	; 0x23
     7fa:	30 dc       	rcall	.-1952   	; 0x5c <__SREG__+0x1d>
     7fc:	b9 a7       	std	Y+41, r27	; 0x29
     7fe:	f1 26       	eor	r15, r17
     800:	26 26       	eor	r2, r22
     802:	fe d8       	rcall	.-3588   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
     804:	ff 11       	Address 0x00000804 is out of bounds.
.word	0xffff	; ????

00000805 <child_payload_size>:
     805:	11 12 13 14 15 16                                   ......

0000080b <child_pipe>:
     80b:	0a 0b 0c 0d 0e 0f                                   ......

00000811 <child_pipe_enable>:
     811:	00 01 02 03 04 05 00                                .......

00000818 <__ctors_start>:
__ctors_start():
     818:	fc 10       	cpse	r15, r12

0000081a <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:226
     81a:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:227
     81c:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:228
     81e:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:230
     820:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:232
     822:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:233
     824:	de bf       	out	0x3e, r29	; 62

00000826 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     826:	2a e3       	ldi	r18, 0x3A	; 58
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     828:	a6 e0       	ldi	r26, 0x06	; 6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     82a:	b8 e3       	ldi	r27, 0x38	; 56
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     82c:	01 c0       	rjmp	.+2      	; 0x830 <.do_clear_bss_start>

0000082e <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     82e:	1d 92       	st	X+, r1

00000830 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     830:	a4 31       	cpi	r26, 0x14	; 20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     832:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     834:	e1 f7       	brne	.-8      	; 0x82e <.do_clear_bss_loop>

00000836 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     836:	18 e3       	ldi	r17, 0x38	; 56
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     838:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     83a:	b8 e3       	ldi	r27, 0x38	; 56
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     83c:	e2 ed       	ldi	r30, 0xD2	; 210
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     83e:	fa e3       	ldi	r31, 0x3A	; 58
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     840:	02 c0       	rjmp	.+4      	; 0x846 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     842:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     844:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     846:	a6 30       	cpi	r26, 0x06	; 6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     848:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     84a:	d9 f7       	brne	.-10     	; 0x842 <__do_copy_data+0xc>

0000084c <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     84c:	14 e0       	ldi	r17, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     84e:	cd e0       	ldi	r28, 0x0D	; 13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     850:	d4 e0       	ldi	r29, 0x04	; 4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     852:	04 c0       	rjmp	.+8      	; 0x85c <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     854:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     856:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     858:	0e 94 a3 1b 	call	0x3746	; 0x3746 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     85c:	cc 30       	cpi	r28, 0x0C	; 12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     85e:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     860:	c9 f7       	brne	.-14     	; 0x854 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:310
     862:	0e 94 8e 11 	call	0x231c	; 0x231c <main>
../../../../crt1/gcrt1.S:311
     866:	0c 94 ea 1c 	jmp	0x39d4	; 0x39d4 <_exit>

0000086a <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:205
     86a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000086e <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:338
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
	return rxBufferLength - rxBufferIndex;
     86e:	80 91 ab 38 	lds	r24, 0x38AB	; 0x8038ab <TwoWire::rxBufferLength>
     872:	90 91 ac 38 	lds	r25, 0x38AC	; 0x8038ac <TwoWire::rxBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:339
}
     876:	89 1b       	sub	r24, r25
     878:	99 0b       	sbc	r25, r25
     87a:	08 95       	ret

0000087c <SPIClass::transfer(unsigned char) [clone .constprop.65]>:
_ZN8SPIClass8transferEh.constprop.65():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:345
  * The following NOP introduces a small delay that can prevent the wait
  * loop from iterating when running at the maximum speed. This gives
  * about 10% more speed, even if it seems counter-intuitive. At lower
  * speeds it is unnoticed.
  */
  asm volatile("nop");
     87c:	00 00       	nop
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:347

  SPI0.DATA = data;
     87e:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:348
  while ((SPI0.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
     882:	80 91 23 08 	lds	r24, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     886:	87 ff       	sbrs	r24, 7
     888:	fc cf       	rjmp	.-8      	; 0x882 <SPIClass::transfer(unsigned char) [clone .constprop.65]+0x6>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:349
  return SPI0.DATA;                             // read data back
     88a:	80 91 24 08 	lds	r24, 0x0824	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:350
}
     88e:	08 95       	ret

00000890 <UartClass::availableForWrite()>:
_ZN9UartClass17availableForWriteEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:297
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     890:	fc 01       	movw	r30, r24
     892:	50 8d       	ldd	r21, Z+24	; 0x18
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:298
    tail = _tx_buffer_tail;
     894:	41 8d       	ldd	r20, Z+25	; 0x19
     896:	25 2f       	mov	r18, r21
     898:	30 e0       	ldi	r19, 0x00	; 0
     89a:	84 2f       	mov	r24, r20
     89c:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:300
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     89e:	82 1b       	sub	r24, r18
     8a0:	93 0b       	sbc	r25, r19
     8a2:	54 17       	cp	r21, r20
     8a4:	10 f0       	brcs	.+4      	; 0x8aa <UartClass::availableForWrite()+0x1a>
     8a6:	cf 96       	adiw	r24, 0x3f	; 63
     8a8:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:301
  return tail - head - 1;
     8aa:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:302
}
     8ac:	08 95       	ret

000008ae <UartClass::read()>:
_ZN9UartClass4readEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:280
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void)
{
     8ae:	fc 01       	movw	r30, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:282
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     8b0:	96 89       	ldd	r25, Z+22	; 0x16
     8b2:	87 89       	ldd	r24, Z+23	; 0x17
     8b4:	98 17       	cp	r25, r24
     8b6:	61 f0       	breq	.+24     	; 0x8d0 <UartClass::read()+0x22>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:285
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     8b8:	a7 89       	ldd	r26, Z+23	; 0x17
     8ba:	ae 0f       	add	r26, r30
     8bc:	bf 2f       	mov	r27, r31
     8be:	b1 1d       	adc	r27, r1
     8c0:	5d 96       	adiw	r26, 0x1d	; 29
     8c2:	8c 91       	ld	r24, X
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:286
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     8c4:	97 89       	ldd	r25, Z+23	; 0x17
     8c6:	9f 5f       	subi	r25, 0xFF	; 255
     8c8:	9f 73       	andi	r25, 0x3F	; 63
     8ca:	97 8b       	std	Z+23, r25	; 0x17
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:287
    return c;
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:283

int UartClass::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:289
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     8d4:	08 95       	ret

000008d6 <UartClass::peek()>:
_ZN9UartClass4peekEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:271
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void)
{
     8d6:	fc 01       	movw	r30, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:272
  if (_rx_buffer_head == _rx_buffer_tail) {
     8d8:	96 89       	ldd	r25, Z+22	; 0x16
     8da:	87 89       	ldd	r24, Z+23	; 0x17
     8dc:	98 17       	cp	r25, r24
     8de:	31 f0       	breq	.+12     	; 0x8ec <UartClass::peek()+0x16>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:275
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     8e0:	87 89       	ldd	r24, Z+23	; 0x17
     8e2:	e8 0f       	add	r30, r24
     8e4:	f1 1d       	adc	r31, r1
     8e6:	85 8d       	ldd	r24, Z+29	; 0x1d
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:273
}

int UartClass::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     8ec:	8f ef       	ldi	r24, 0xFF	; 255
     8ee:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:277
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     8f0:	08 95       	ret

000008f2 <UartClass::available()>:
_ZN9UartClass9availableEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:266
  // Note: Does not change output pins
  _written = false;
}

int UartClass::available(void)
{
     8f2:	fc 01       	movw	r30, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:267
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     8f4:	96 89       	ldd	r25, Z+22	; 0x16
     8f6:	27 89       	ldd	r18, Z+23	; 0x17
     8f8:	89 2f       	mov	r24, r25
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	80 5c       	subi	r24, 0xC0	; 192
     8fe:	9f 4f       	sbci	r25, 0xFF	; 255
     900:	82 1b       	sub	r24, r18
     902:	91 09       	sbc	r25, r1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:268
}
     904:	8f 73       	andi	r24, 0x3F	; 63
     906:	99 27       	eor	r25, r25
     908:	08 95       	ret

0000090a <UartClass::end()>:
_ZN9UartClass3endEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:249
  // Restore SREG content
  SREG = oldSREG;
}

void UartClass::end()
{
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	ec 01       	movw	r28, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:251
  // wait for transmission of outgoing data
  flush();
     910:	e8 81       	ld	r30, Y
     912:	f9 81       	ldd	r31, Y+1	; 0x01
     914:	02 84       	ldd	r0, Z+10	; 0x0a
     916:	f3 85       	ldd	r31, Z+11	; 0x0b
     918:	e0 2d       	mov	r30, r0
     91a:	09 95       	icall
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:255

  // Disable receiver and transmitter as well as the RX complete and
  // data register empty interrupts.
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     91c:	ec 85       	ldd	r30, Y+12	; 0x0c
     91e:	fd 85       	ldd	r31, Y+13	; 0x0d
     920:	86 81       	ldd	r24, Z+6	; 0x06
     922:	8f 73       	andi	r24, 0x3F	; 63
     924:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:256
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm);
     926:	ec 85       	ldd	r30, Y+12	; 0x0c
     928:	fd 85       	ldd	r31, Y+13	; 0x0d
     92a:	85 81       	ldd	r24, Z+5	; 0x05
     92c:	8f 75       	andi	r24, 0x5F	; 95
     92e:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:259

  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     930:	8f 89       	ldd	r24, Y+23	; 0x17
     932:	8e 8b       	std	Y+22, r24	; 0x16
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:262

  // Note: Does not change output pins
  _written = false;
     934:	1d 8a       	std	Y+21, r1	; 0x15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:263
}
     936:	df 91       	pop	r29
     938:	cf 91       	pop	r28
     93a:	08 95       	ret

0000093c <UartClass::_tx_data_empty_irq()>:
_ZN9UartClass18_tx_data_empty_irqEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:89
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_tx_data_empty_irq(void)
{
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	fc 01       	movw	r30, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:91
  // Check if tx buffer already empty.
  if (_tx_buffer_head == _tx_buffer_tail) {
     942:	90 8d       	ldd	r25, Z+24	; 0x18
     944:	81 8d       	ldd	r24, Z+25	; 0x19
     946:	c4 85       	ldd	r28, Z+12	; 0x0c
     948:	d5 85       	ldd	r29, Z+13	; 0x0d
     94a:	98 13       	cpse	r25, r24
     94c:	06 c0       	rjmp	.+12     	; 0x95a <UartClass::_tx_data_empty_irq()+0x1e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:93
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     94e:	8d 81       	ldd	r24, Y+5	; 0x05
     950:	8f 7d       	andi	r24, 0xDF	; 223
     952:	8d 83       	std	Y+5, r24	; 0x05
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:119
    if(_hwserial_dre_interrupt_elevated) {
      CPUINT.LVL1VEC = _prev_lvl1_interrupt_vect;
      _hwserial_dre_interrupt_elevated = 0;
    }
  }
}
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:99
    return;
  }

  // There must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     95a:	a1 8d       	ldd	r26, Z+25	; 0x19
     95c:	ae 0f       	add	r26, r30
     95e:	bf 2f       	mov	r27, r31
     960:	b1 1d       	adc	r27, r1
     962:	a3 5a       	subi	r26, 0xA3	; 163
     964:	bf 4f       	sbci	r27, 0xFF	; 255
     966:	2c 91       	ld	r18, X
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:100
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     968:	81 8d       	ldd	r24, Z+25	; 0x19
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	01 96       	adiw	r24, 0x01	; 1
     96e:	8f 73       	andi	r24, 0x3F	; 63
     970:	99 27       	eor	r25, r25
     972:	81 8f       	std	Z+25, r24	; 0x19
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:105

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  (*_hwserial_module).STATUS = USART_TXCIF_bm;
     974:	80 e4       	ldi	r24, 0x40	; 64
     976:	8c 83       	std	Y+4, r24	; 0x04
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:107

  (*_hwserial_module).TXDATAL = c;
     978:	a4 85       	ldd	r26, Z+12	; 0x0c
     97a:	b5 85       	ldd	r27, Z+13	; 0x0d
     97c:	12 96       	adiw	r26, 0x02	; 2
     97e:	2c 93       	st	X, r18
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:109

  if (_tx_buffer_head == _tx_buffer_tail) {
     980:	90 8d       	ldd	r25, Z+24	; 0x18
     982:	81 8d       	ldd	r24, Z+25	; 0x19
     984:	98 13       	cpse	r25, r24
     986:	e6 cf       	rjmp	.-52     	; 0x954 <UartClass::_tx_data_empty_irq()+0x18>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:111
    // Buffer empty, so disable "data register empty" interrupt
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     988:	a4 85       	ldd	r26, Z+12	; 0x0c
     98a:	b5 85       	ldd	r27, Z+13	; 0x0d
     98c:	15 96       	adiw	r26, 0x05	; 5
     98e:	8c 91       	ld	r24, X
     990:	15 97       	sbiw	r26, 0x05	; 5
     992:	8f 7d       	andi	r24, 0xDF	; 223
     994:	15 96       	adiw	r26, 0x05	; 5
     996:	8c 93       	st	X, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:114

    //Take the DRE interrupt back no normal priority level if it has been elevated
    if(_hwserial_dre_interrupt_elevated) {
     998:	83 8d       	ldd	r24, Z+27	; 0x1b
     99a:	88 23       	and	r24, r24
     99c:	d9 f2       	breq	.-74     	; 0x954 <UartClass::_tx_data_empty_irq()+0x18>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:115
      CPUINT.LVL1VEC = _prev_lvl1_interrupt_vect;
     99e:	84 8d       	ldd	r24, Z+28	; 0x1c
     9a0:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x700113>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:116
      _hwserial_dre_interrupt_elevated = 0;
     9a4:	13 8e       	std	Z+27, r1	; 0x1b
     9a6:	d6 cf       	rjmp	.-84     	; 0x954 <UartClass::_tx_data_empty_irq()+0x18>

000009a8 <UartClass::_poll_tx_data_empty()>:
_ZN9UartClass19_poll_tx_data_emptyEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:123
  }
}

// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void)
{
     9a8:	dc 01       	movw	r26, r24
     9aa:	1c 96       	adiw	r26, 0x0c	; 12
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:124
  if ( (!(SREG & CPU_I_bm)) || (!((*_hwserial_module).CTRLA & USART_DREIE_bm)) ) {
     9b0:	0f b6       	in	r0, 0x3f	; 63
     9b2:	07 fe       	sbrs	r0, 7
     9b4:	03 c0       	rjmp	.+6      	; 0x9bc <UartClass::_poll_tx_data_empty()+0x14>
     9b6:	25 81       	ldd	r18, Z+5	; 0x05
     9b8:	25 fd       	sbrc	r18, 5
     9ba:	04 c0       	rjmp	.+8      	; 0x9c4 <UartClass::_poll_tx_data_empty()+0x1c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:131
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.

    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     9bc:	24 81       	ldd	r18, Z+4	; 0x04
     9be:	25 fd       	sbrc	r18, 5
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:132
      _tx_data_empty_irq();
     9c0:	0c 94 9e 04 	jmp	0x93c	; 0x93c <UartClass::_tx_data_empty_irq()>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:136
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
}
     9c4:	08 95       	ret

000009c6 <UartClass::write(unsigned char)>:
_ZN9UartClass5writeEh():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:336
  // If we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}

size_t UartClass::write(uint8_t c)
{
     9c6:	ef 92       	push	r14
     9c8:	ff 92       	push	r15
     9ca:	0f 93       	push	r16
     9cc:	1f 93       	push	r17
     9ce:	cf 93       	push	r28
     9d0:	df 93       	push	r29
     9d2:	ec 01       	movw	r28, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:337
  _written = true;
     9d4:	81 e0       	ldi	r24, 0x01	; 1
     9d6:	8d 8b       	std	Y+21, r24	; 0x15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:343

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ( (_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm) ) {
     9d8:	98 8d       	ldd	r25, Y+24	; 0x18
     9da:	89 8d       	ldd	r24, Y+25	; 0x19
     9dc:	98 13       	cpse	r25, r24
     9de:	1c c0       	rjmp	.+56     	; 0xa18 <UartClass::write(unsigned char)+0x52>
     9e0:	ac 85       	ldd	r26, Y+12	; 0x0c
     9e2:	bd 85       	ldd	r27, Y+13	; 0x0d
     9e4:	14 96       	adiw	r26, 0x04	; 4
     9e6:	8c 91       	ld	r24, X
     9e8:	14 97       	sbiw	r26, 0x04	; 4
     9ea:	85 ff       	sbrs	r24, 5
     9ec:	15 c0       	rjmp	.+42     	; 0xa18 <UartClass::write(unsigned char)+0x52>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:344
    (*_hwserial_module).TXDATAL = c;
     9ee:	12 96       	adiw	r26, 0x02	; 2
     9f0:	6c 93       	st	X, r22
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:345
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     9f2:	ac 85       	ldd	r26, Y+12	; 0x0c
     9f4:	bd 85       	ldd	r27, Y+13	; 0x0d
     9f6:	80 e4       	ldi	r24, 0x40	; 64
     9f8:	14 96       	adiw	r26, 0x04	; 4
     9fa:	8c 93       	st	X, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:349

    // Make sure data register empty interrupt is disabled to avoid
    // that the interrupt handler is called in this situation
    (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     9fc:	ec 85       	ldd	r30, Y+12	; 0x0c
     9fe:	fd 85       	ldd	r31, Y+13	; 0x0d
     a00:	85 81       	ldd	r24, Z+5	; 0x05
     a02:	8f 7d       	andi	r24, 0xDF	; 223
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:377

  _tx_buffer[_tx_buffer_head] = c;
  _tx_buffer_head = i;

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     a04:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:380

  return 1;
}
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	ff 90       	pop	r15
     a14:	ef 90       	pop	r14
     a16:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:356
    return 1;
  }

  //Check if we are inside an ISR already (could be from by a source other than UART),
  // in which case the UART ISRs will be blocked.
  if(CPUINT.STATUS & CPUINT_LVL0EX_bm) {
     a18:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
     a1c:	80 ff       	sbrs	r24, 0
     a1e:	08 c0       	rjmp	.+16     	; 0xa30 <UartClass::write(unsigned char)+0x6a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:359
    //Elevate the priority level of the Data Register Empty Interrupt vector
    //and copy whatever vector number that might be in the register already.
    _prev_lvl1_interrupt_vect = CPUINT.LVL1VEC;
     a20:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <__TEXT_REGION_LENGTH__+0x700113>
     a24:	8c 8f       	std	Y+28, r24	; 0x1c
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:360
    CPUINT.LVL1VEC = _hwserial_dre_interrupt_vect_num;
     a26:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a28:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x700113>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:362

    _hwserial_dre_interrupt_elevated = 1;
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	8b 8f       	std	Y+27, r24	; 0x1b
     a30:	f6 2e       	mov	r15, r22
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:365
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     a32:	08 8d       	ldd	r16, Y+24	; 0x18
     a34:	10 e0       	ldi	r17, 0x00	; 0
     a36:	0f 5f       	subi	r16, 0xFF	; 255
     a38:	1f 4f       	sbci	r17, 0xFF	; 255
     a3a:	0f 73       	andi	r16, 0x3F	; 63
     a3c:	11 27       	eor	r17, r17
     a3e:	e0 2e       	mov	r14, r16
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:369

  //If the output buffer is full, there's nothing for it other than to
  //wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
     a40:	89 8d       	ldd	r24, Y+25	; 0x19
     a42:	8e 11       	cpse	r24, r14
     a44:	04 c0       	rjmp	.+8      	; 0xa4e <UartClass::write(unsigned char)+0x88>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:370
    _poll_tx_data_empty();
     a46:	ce 01       	movw	r24, r28
     a48:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <UartClass::_poll_tx_data_empty()>
     a4c:	f9 cf       	rjmp	.-14     	; 0xa40 <UartClass::write(unsigned char)+0x7a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:373
  }

  _tx_buffer[_tx_buffer_head] = c;
     a4e:	e8 8d       	ldd	r30, Y+24	; 0x18
     a50:	ec 0f       	add	r30, r28
     a52:	fd 2f       	mov	r31, r29
     a54:	f1 1d       	adc	r31, r1
     a56:	e3 5a       	subi	r30, 0xA3	; 163
     a58:	ff 4f       	sbci	r31, 0xFF	; 255
     a5a:	f0 82       	st	Z, r15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:374
  _tx_buffer_head = i;
     a5c:	08 8f       	std	Y+24, r16	; 0x18
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:377

  // Enable data "register empty interrupt"
  (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     a5e:	ec 85       	ldd	r30, Y+12	; 0x0c
     a60:	fd 85       	ldd	r31, Y+13	; 0x0d
     a62:	85 81       	ldd	r24, Z+5	; 0x05
     a64:	80 62       	ori	r24, 0x20	; 32
     a66:	ce cf       	rjmp	.-100    	; 0xa04 <UartClass::write(unsigned char)+0x3e>

00000a68 <UartClass::flush()>:
_ZN9UartClass5flushEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:305
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void UartClass::flush()
{
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:309
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!_written) {
     a6c:	fc 01       	movw	r30, r24
     a6e:	25 89       	ldd	r18, Z+21	; 0x15
     a70:	22 23       	and	r18, r18
     a72:	c9 f0       	breq	.+50     	; 0xaa6 <UartClass::flush()+0x3e>
     a74:	ec 01       	movw	r28, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:315
    return;
  }

  //Check if we are inside an ISR already (e.g. connected to a different peripheral then UART), in which case the UART ISRs will not be called.
  //Temporarily elevate the DRE interrupt to allow it to run.
  if(CPUINT.STATUS & CPUINT_LVL0EX_bm) {
     a76:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x700111>
     a7a:	80 ff       	sbrs	r24, 0
     a7c:	08 c0       	rjmp	.+16     	; 0xa8e <UartClass::flush()+0x26>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:318
    //Elevate the priority level of the Data Register Empty Interrupt vector
    //and copy whatever vector number that might be in the register already.
    _prev_lvl1_interrupt_vect = CPUINT.LVL1VEC;
     a7e:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <__TEXT_REGION_LENGTH__+0x700113>
     a82:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:319
    CPUINT.LVL1VEC = _hwserial_dre_interrupt_vect_num;
     a84:	82 8d       	ldd	r24, Z+26	; 0x1a
     a86:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__TEXT_REGION_LENGTH__+0x700113>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:321

    _hwserial_dre_interrupt_elevated = 1;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	83 8f       	std	Z+27, r24	; 0x1b
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:325
  }

  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while ( ((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm)) ) {
     a8e:	ec 85       	ldd	r30, Y+12	; 0x0c
     a90:	fd 85       	ldd	r31, Y+13	; 0x0d
     a92:	85 81       	ldd	r24, Z+5	; 0x05
     a94:	85 fd       	sbrc	r24, 5
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <UartClass::flush()+0x36>
     a98:	84 81       	ldd	r24, Z+4	; 0x04
     a9a:	86 fd       	sbrc	r24, 6
     a9c:	04 c0       	rjmp	.+8      	; 0xaa6 <UartClass::flush()+0x3e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:329

    // If interrupts are globally disabled or the and DR empty interrupt is disabled,
    // poll the "data register empty" interrupt flag to prevent deadlock
    _poll_tx_data_empty();
     a9e:	ce 01       	movw	r24, r28
     aa0:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <UartClass::_poll_tx_data_empty()>
     aa4:	f4 cf       	rjmp	.-24     	; 0xa8e <UartClass::flush()+0x26>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:333
  }
  // If we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     aa6:	df 91       	pop	r29
     aa8:	cf 91       	pop	r28
     aaa:	08 95       	ret

00000aac <Serial0_available()>:
_Z17Serial0_availablev():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:64
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     aac:	80 ef       	ldi	r24, 0xF0	; 240
     aae:	98 e3       	ldi	r25, 0x38	; 56
     ab0:	0e 94 79 04 	call	0x8f2	; 0x8f2 <UartClass::available()>
     ab4:	21 e0       	ldi	r18, 0x01	; 1
     ab6:	89 2b       	or	r24, r25
     ab8:	09 f4       	brne	.+2      	; 0xabc <Serial0_available()+0x10>
     aba:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:65
}
     abc:	82 2f       	mov	r24, r18
     abe:	08 95       	ret

00000ac0 <serialEventRun()>:
_Z14serialEventRunv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:66
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	89 2b       	or	r24, r25
     ac6:	29 f0       	breq	.+10     	; 0xad2 <serialEventRun()+0x12>
     ac8:	0e 94 56 05 	call	0xaac	; 0xaac <Serial0_available()>
     acc:	81 11       	cpse	r24, r1
     ace:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:77
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     ad2:	08 95       	ret

00000ad4 <Print::write(unsigned char const*, unsigned int)>:
_ZN5Print5writeEPKhj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:30

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     ad4:	af 92       	push	r10
     ad6:	bf 92       	push	r11
     ad8:	cf 92       	push	r12
     ada:	df 92       	push	r13
     adc:	ef 92       	push	r14
     ade:	ff 92       	push	r15
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	6c 01       	movw	r12, r24
     aea:	7b 01       	movw	r14, r22
     aec:	8b 01       	movw	r16, r22
     aee:	04 0f       	add	r16, r20
     af0:	15 1f       	adc	r17, r21
     af2:	eb 01       	movw	r28, r22
     af4:	5e 01       	movw	r10, r28
     af6:	ae 18       	sub	r10, r14
     af8:	bf 08       	sbc	r11, r15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:32
  size_t n = 0;
  while (size--) {
     afa:	c0 17       	cp	r28, r16
     afc:	d1 07       	cpc	r29, r17
     afe:	59 f0       	breq	.+22     	; 0xb16 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:33
    if (write(*buffer++)) n++;
     b00:	69 91       	ld	r22, Y+
     b02:	d6 01       	movw	r26, r12
     b04:	ed 91       	ld	r30, X+
     b06:	fc 91       	ld	r31, X
     b08:	01 90       	ld	r0, Z+
     b0a:	f0 81       	ld	r31, Z
     b0c:	e0 2d       	mov	r30, r0
     b0e:	c6 01       	movw	r24, r12
     b10:	09 95       	icall
     b12:	89 2b       	or	r24, r25
     b14:	79 f7       	brne	.-34     	; 0xaf4 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:37
    else break;
  }
  return n;
}
     b16:	c5 01       	movw	r24, r10
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
     b1c:	1f 91       	pop	r17
     b1e:	0f 91       	pop	r16
     b20:	ff 90       	pop	r15
     b22:	ef 90       	pop	r14
     b24:	df 90       	pop	r13
     b26:	cf 90       	pop	r12
     b28:	bf 90       	pop	r11
     b2a:	af 90       	pop	r10
     b2c:	08 95       	ret

00000b2e <UartClass::operator bool()>:
_ZN9UartClasscvbEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.h:174
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    using Print::write; // pull in write(str) and write(buf, size) from Print
    explicit operator bool() { return true; }
     b2e:	81 e0       	ldi	r24, 0x01	; 1
     b30:	08 95       	ret

00000b32 <digitalWrite.part.1>:
digitalWrite.part.1():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:147
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	/* Get bit mask for pin */
	uint8_t bit_mask = digitalPinToBitMask(pin);
     b32:	28 2f       	mov	r18, r24
     b34:	30 e0       	ldi	r19, 0x00	; 0
     b36:	f9 01       	movw	r30, r18
     b38:	ee 5f       	subi	r30, 0xFE	; 254
     b3a:	f5 44       	sbci	r31, 0x45	; 69
     b3c:	40 81       	ld	r20, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:148
	if(bit_mask == NOT_A_PIN) return;
     b3e:	4f 3f       	cpi	r20, 0xFF	; 255
     b40:	09 f4       	brne	.+2      	; 0xb44 <digitalWrite.part.1+0x12>
     b42:	48 c0       	rjmp	.+144    	; 0xbd4 <digitalWrite.part.1+0xa2>
turnOffPWM():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:93
static void turnOffPWM(uint8_t pin)
{
	/* Actually turn off compare channel, not the timer */

	/* Get pin's timer */
	uint8_t timer = digitalPinToTimer(pin);
     b44:	8c 30       	cpi	r24, 0x0C	; 12
     b46:	50 f4       	brcc	.+20     	; 0xb5c <digitalWrite.part.1+0x2a>
     b48:	f9 01       	movw	r30, r18
     b4a:	e8 52       	subi	r30, 0x28	; 40
     b4c:	f6 44       	sbci	r31, 0x46	; 70
     b4e:	80 81       	ld	r24, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:94
	if(timer == NOT_ON_TIMER) return;
     b50:	88 23       	and	r24, r24
     b52:	21 f0       	breq	.+8      	; 0xb5c <digitalWrite.part.1+0x2a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:99

	uint8_t bit_pos = digitalPinToBitPosition(pin);
	//TCB_t *timerB;

	switch (timer) {
     b54:	80 31       	cpi	r24, 0x10	; 16
     b56:	91 f0       	breq	.+36     	; 0xb7c <digitalWrite.part.1+0x4a>
     b58:	80 38       	cpi	r24, 0x80	; 128
     b5a:	21 f1       	breq	.+72     	; 0xba4 <digitalWrite.part.1+0x72>
digitalWrite.part.1():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:159
	turnOffPWM(pin);

	/* Assuming the direction is already output !! */

	/* Get port */
	PORT_t *port = digitalPinToPortStruct(pin);
     b5c:	f9 01       	movw	r30, r18
     b5e:	ea 50       	subi	r30, 0x0A	; 10
     b60:	f6 44       	sbci	r31, 0x46	; 70
     b62:	e0 81       	ld	r30, Z
     b64:	80 e2       	ldi	r24, 0x20	; 32
     b66:	e8 9f       	mul	r30, r24
     b68:	f0 01       	movw	r30, r0
     b6a:	11 24       	eor	r1, r1
     b6c:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:162

	/* Output direction */
	if(port->DIR & bit_mask){
     b6e:	80 81       	ld	r24, Z
     b70:	84 23       	and	r24, r20
     b72:	e9 f0       	breq	.+58     	; 0xbae <digitalWrite.part.1+0x7c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:165

		/* Set output to value */
		if (val == LOW) { /* If LOW */
     b74:	61 11       	cpse	r22, r1
     b76:	19 c0       	rjmp	.+50     	; 0xbaa <digitalWrite.part.1+0x78>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:166
			port->OUTCLR = bit_mask;
     b78:	46 83       	std	Z+6, r20	; 0x06
     b7a:	08 95       	ret
turnOffPWM():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:96

	/* Get pin's timer */
	uint8_t timer = digitalPinToTimer(pin);
	if(timer == NOT_ON_TIMER) return;

	uint8_t bit_pos = digitalPinToBitPosition(pin);
     b7c:	f9 01       	movw	r30, r18
     b7e:	e6 51       	subi	r30, 0x16	; 22
     b80:	f6 44       	sbci	r31, 0x46	; 70
     b82:	50 81       	ld	r21, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:107
	case TIMERA0:
		/* Bit position will give output channel */
		#ifdef __AVR_ATtinyxy2__
		if (bit_pos==7) bit_pos=0; //on the xy2, WO0 is on PA7
		#endif
		if (bit_pos>2) 	bit_pos++; //there's a blank bit in the middle
     b84:	53 30       	cpi	r21, 0x03	; 3
     b86:	08 f0       	brcs	.+2      	; 0xb8a <digitalWrite.part.1+0x58>
     b88:	5f 5f       	subi	r21, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:109
		/* Disable corresponding channel */
		TCA0.SPLIT.CTRLB &= ~(1 << (TCA_SPLIT_LCMP0EN_bp + bit_pos));
     b8a:	70 91 01 0a 	lds	r23, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
     b8e:	81 e0       	ldi	r24, 0x01	; 1
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	01 c0       	rjmp	.+2      	; 0xb96 <digitalWrite.part.1+0x64>
     b94:	88 0f       	add	r24, r24
     b96:	5a 95       	dec	r21
     b98:	ea f7       	brpl	.-6      	; 0xb94 <digitalWrite.part.1+0x62>
     b9a:	80 95       	com	r24
     b9c:	87 23       	and	r24, r23
     b9e:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
     ba2:	dc cf       	rjmp	.-72     	; 0xb5c <digitalWrite.part.1+0x2a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:127

		break;
	*/
	#if defined(DAC0)
	case DACOUT:
		DAC0.CTRLA=0x00;
     ba4:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
     ba8:	d9 cf       	rjmp	.-78     	; 0xb5c <digitalWrite.part.1+0x2a>
digitalWrite.part.1():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:172

		} else if (val == CHANGE) { /* If TOGGLE */
			port->OUTTGL = bit_mask;
									/* If HIGH OR  > TOGGLE  */
		} else {
			port->OUTSET = bit_mask;
     baa:	45 83       	std	Z+5, r20	; 0x05
     bac:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:183
		pull up is enabled if this function is called.
		Should we purposely implement this side effect?
		*/

		/* Get bit position for getting pin ctrl reg */
		uint8_t bit_pos = digitalPinToBitPosition(pin);
     bae:	26 51       	subi	r18, 0x16	; 22
     bb0:	36 44       	sbci	r19, 0x46	; 70
     bb2:	d9 01       	movw	r26, r18
     bb4:	8c 91       	ld	r24, X
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:186

		/* Calculate where pin control register is */
		volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bb6:	30 97       	sbiw	r30, 0x00	; 0
     bb8:	71 f0       	breq	.+28     	; 0xbd6 <digitalWrite.part.1+0xa4>
     bba:	8f 3f       	cpi	r24, 0xFF	; 255
     bbc:	61 f0       	breq	.+24     	; 0xbd6 <digitalWrite.part.1+0xa4>
     bbe:	70 96       	adiw	r30, 0x10	; 16
     bc0:	e8 0f       	add	r30, r24
     bc2:	f1 1d       	adc	r31, r1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:189

		/* Save system status and disable interrupts */
		uint8_t status = SREG;
     bc4:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:190
		cli();
     bc6:	f8 94       	cli
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:194

		if(val == LOW){
			/* Disable pullup */
			*pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     bc8:	80 81       	ld	r24, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:192

		/* Save system status and disable interrupts */
		uint8_t status = SREG;
		cli();

		if(val == LOW){
     bca:	61 11       	cpse	r22, r1
     bcc:	07 c0       	rjmp	.+14     	; 0xbdc <digitalWrite.part.1+0xaa>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:194
			/* Disable pullup */
			*pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     bce:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:198

		} else {
			/* Enable pull-up */
			*pin_ctrl_reg |= PORT_PULLUPEN_bm;
     bd0:	80 83       	st	Z, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:202
		}

		/* Restore system status */
		SREG = status;
     bd2:	9f bf       	out	0x3f, r25	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:205
	}

}
     bd4:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:186

		/* Get bit position for getting pin ctrl reg */
		uint8_t bit_pos = digitalPinToBitPosition(pin);

		/* Calculate where pin control register is */
		volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     bd6:	f0 e0       	ldi	r31, 0x00	; 0
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f4 cf       	rjmp	.-24     	; 0xbc4 <digitalWrite.part.1+0x92>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:198
			/* Disable pullup */
			*pin_ctrl_reg &= ~PORT_PULLUPEN_bm;

		} else {
			/* Enable pull-up */
			*pin_ctrl_reg |= PORT_PULLUPEN_bm;
     bdc:	88 60       	ori	r24, 0x08	; 8
     bde:	f8 cf       	rjmp	.-16     	; 0xbd0 <digitalWrite.part.1+0x9e>

00000be0 <pinMode.part.0>:
pinMode.part.0():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:30
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"


void pinMode(uint8_t pin, uint8_t mode)
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:32
{
	uint8_t bit_mask = digitalPinToBitMask(pin);
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	fc 01       	movw	r30, r24
     be8:	ee 5f       	subi	r30, 0xFE	; 254
     bea:	f5 44       	sbci	r31, 0x45	; 69
     bec:	20 81       	ld	r18, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:34

	if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) return;
     bee:	2f 3f       	cpi	r18, 0xFF	; 255
     bf0:	61 f0       	breq	.+24     	; 0xc0a <pinMode.part.0+0x2a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:36

	PORT_t* port = digitalPinToPortStruct(pin);
     bf2:	fc 01       	movw	r30, r24
     bf4:	ea 50       	subi	r30, 0x0A	; 10
     bf6:	f6 44       	sbci	r31, 0x46	; 70
     bf8:	e0 81       	ld	r30, Z
     bfa:	30 e2       	ldi	r19, 0x20	; 32
     bfc:	e3 9f       	mul	r30, r19
     bfe:	f0 01       	movw	r30, r0
     c00:	11 24       	eor	r1, r1
     c02:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:39
	if(port == NULL) return;

	if(mode == OUTPUT){
     c04:	61 30       	cpi	r22, 0x01	; 1
     c06:	21 f4       	brne	.+8      	; 0xc10 <pinMode.part.0+0x30>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:42

		/* Configure direction as output */
		port->DIRSET = bit_mask;
     c08:	21 83       	std	Z+1, r18	; 0x01
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:72
		}

		/* Restore state */
		SREG = status;
	}
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:46
		/* Configure direction as output */
		port->DIRSET = bit_mask;

	} else { /* mode == INPUT or INPUT_PULLUP */

		uint8_t bit_pos = digitalPinToBitPosition(pin);
     c10:	86 51       	subi	r24, 0x16	; 22
     c12:	96 44       	sbci	r25, 0x46	; 70
     c14:	ec 01       	movw	r28, r24
     c16:	a8 81       	ld	r26, Y
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:48
		/* Calculate where pin control register is */
		volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     c18:	af 3f       	cpi	r26, 0xFF	; 255
     c1a:	69 f0       	breq	.+26     	; 0xc36 <pinMode.part.0+0x56>
     c1c:	cf 01       	movw	r24, r30
     c1e:	40 96       	adiw	r24, 0x10	; 16
     c20:	a8 0f       	add	r26, r24
     c22:	b9 2f       	mov	r27, r25
     c24:	b1 1d       	adc	r27, r1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:51

		/* Save state */
		uint8_t status = SREG;
     c26:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:52
		cli();
     c28:	f8 94       	cli
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:55

		/* Configure direction as input */
		port->DIRCLR = bit_mask;
     c2a:	22 83       	std	Z+2, r18	; 0x02
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:61

		/* Configure pull-up resistor */
		if(mode == INPUT_PULLUP){

			/* Enable pull-up */
			*pin_ctrl_reg |= PORT_PULLUPEN_bm;
     c2c:	8c 91       	ld	r24, X
     c2e:	88 60       	ori	r24, 0x08	; 8
     c30:	8c 93       	st	X, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:70
			/* Disable pull-up */
			*pin_ctrl_reg &= ~(PORT_PULLUPEN_bm);
		}

		/* Restore state */
		SREG = status;
     c32:	9f bf       	out	0x3f, r25	; 63
     c34:	ea cf       	rjmp	.-44     	; 0xc0a <pinMode.part.0+0x2a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:48

	} else { /* mode == INPUT or INPUT_PULLUP */

		uint8_t bit_pos = digitalPinToBitPosition(pin);
		/* Calculate where pin control register is */
		volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     c36:	b0 e0       	ldi	r27, 0x00	; 0
     c38:	a0 e0       	ldi	r26, 0x00	; 0
     c3a:	f5 cf       	rjmp	.-22     	; 0xc26 <pinMode.part.0+0x46>

00000c3c <UartClass::begin(unsigned long, unsigned int)>:
_ZN9UartClass5beginEmj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:174
    return false;
  }
}

void UartClass::begin(unsigned long baud, uint16_t config)
{
     c3c:	8f 92       	push	r8
     c3e:	9f 92       	push	r9
     c40:	af 92       	push	r10
     c42:	bf 92       	push	r11
     c44:	df 92       	push	r13
     c46:	ef 92       	push	r14
     c48:	ff 92       	push	r15
     c4a:	0f 93       	push	r16
     c4c:	1f 93       	push	r17
     c4e:	cf 93       	push	r28
     c50:	df 93       	push	r29
     c52:	ec 01       	movw	r28, r24
     c54:	4a 01       	movw	r8, r20
     c56:	5b 01       	movw	r10, r22
     c58:	f2 2e       	mov	r15, r18
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:177
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if(_written) {
     c5a:	8d 89       	ldd	r24, Y+21	; 0x15
     c5c:	88 23       	and	r24, r24
     c5e:	39 f0       	breq	.+14     	; 0xc6e <UartClass::begin(unsigned long, unsigned int)+0x32>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:178
    this->end();
     c60:	e8 81       	ld	r30, Y
     c62:	f9 81       	ldd	r31, Y+1	; 0x01
     c64:	00 88       	ldd	r0, Z+16	; 0x10
     c66:	f1 89       	ldd	r31, Z+17	; 0x11
     c68:	e0 2d       	mov	r30, r0
     c6a:	ce 01       	movw	r24, r28
     c6c:	09 95       	icall
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:181
  }

  struct UartPinSet *set = &_hw_set[_pin_set];
     c6e:	0c 89       	ldd	r16, Y+20	; 0x14
     c70:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:186

  int32_t baud_setting = 0;

  //Make sure global interrupts are disabled during initialization
  uint8_t oldSREG = SREG;
     c72:	df b6       	in	r13, 0x3f	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:187
  cli();
     c74:	f8 94       	cli
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:189

  baud_setting = (((8 * F_CPU) / baud) + 1) / 2;
     c76:	60 e0       	ldi	r22, 0x00	; 0
     c78:	74 eb       	ldi	r23, 0xB4	; 180
     c7a:	84 ec       	ldi	r24, 0xC4	; 196
     c7c:	94 e0       	ldi	r25, 0x04	; 4
     c7e:	a5 01       	movw	r20, r10
     c80:	94 01       	movw	r18, r8
     c82:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <__udivmodsi4>
     c86:	2f 5f       	subi	r18, 0xFF	; 255
     c88:	3f 4f       	sbci	r19, 0xFF	; 255
     c8a:	4f 4f       	sbci	r20, 0xFF	; 255
     c8c:	5f 4f       	sbci	r21, 0xFF	; 255
     c8e:	56 95       	lsr	r21
     c90:	47 95       	ror	r20
     c92:	37 95       	ror	r19
     c94:	27 95       	ror	r18
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:191
  // Disable CLK2X
  (*_hwserial_module).CTRLB &= (~USART_RXMODE_CLK2X_gc);
     c96:	ec 85       	ldd	r30, Y+12	; 0x0c
     c98:	fd 85       	ldd	r31, Y+13	; 0x0d
     c9a:	86 81       	ldd	r24, Z+6	; 0x06
     c9c:	8d 7f       	andi	r24, 0xFD	; 253
     c9e:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:192
  (*_hwserial_module).CTRLB |= USART_RXMODE_NORMAL_gc;
     ca0:	ec 85       	ldd	r30, Y+12	; 0x0c
     ca2:	fd 85       	ldd	r31, Y+13	; 0x0d
     ca4:	86 81       	ldd	r24, Z+6	; 0x06
     ca6:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:194

  _written = false;
     ca8:	1d 8a       	std	Y+21, r1	; 0x15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:202

  //See #131 for more info on this
  #if !defined(USE_EXTERNAL_OSCILLATOR)
    #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL) //this means we are on the 20MHz oscillator
      #ifdef UARTBAUD3V
        int8_t sigrow_val = SIGROW.OSC20ERR3V;
     caa:	a0 91 24 11 	lds	r26, 0x1124	; 0x801124 <__TEXT_REGION_LENGTH__+0x701124>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:217
    #endif
  #else
    int8_t sigrow_val = 0;
  #endif
  //baud_setting += (baud_setting * sigrow_val) / 1024;
  baud_setting *= (1024 + sigrow_val);
     cae:	0a 2e       	mov	r0, r26
     cb0:	00 0c       	add	r0, r0
     cb2:	bb 0b       	sbc	r27, r27
     cb4:	bc 5f       	subi	r27, 0xFC	; 252
     cb6:	0e 94 9b 1b 	call	0x3736	; 0x3736 <__mulshisi3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:221
  baud_setting /= 1024;

  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     cba:	ec 85       	ldd	r30, Y+12	; 0x0c
     cbc:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:218
  #else
    int8_t sigrow_val = 0;
  #endif
  //baud_setting += (baud_setting * sigrow_val) / 1024;
  baud_setting *= (1024 + sigrow_val);
  baud_setting /= 1024;
     cbe:	2a e0       	ldi	r18, 0x0A	; 10
     cc0:	95 95       	asr	r25
     cc2:	87 95       	ror	r24
     cc4:	77 95       	ror	r23
     cc6:	67 95       	ror	r22
     cc8:	2a 95       	dec	r18
     cca:	d1 f7       	brne	.-12     	; 0xcc0 <UartClass::begin(unsigned long, unsigned int)+0x84>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:221

  // assign the baud_setting, a.k.a. BAUD (USART Baud Rate Register)
  (*_hwserial_module).BAUD = (uint16_t)baud_setting;
     ccc:	60 87       	std	Z+8, r22	; 0x08
     cce:	71 87       	std	Z+9, r23	; 0x09
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:224

  // Set USART mode of operation
  (*_hwserial_module).CTRLC = config;
     cd0:	ec 85       	ldd	r30, Y+12	; 0x0c
     cd2:	fd 85       	ldd	r31, Y+13	; 0x0d
     cd4:	f7 82       	std	Z+7, r15	; 0x07
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:227

  // Enable transmitter and receiver
  (*_hwserial_module).CTRLB |= (USART_RXEN_bm | USART_TXEN_bm);
     cd6:	ec 85       	ldd	r30, Y+12	; 0x0c
     cd8:	fd 85       	ldd	r31, Y+13	; 0x0d
     cda:	86 81       	ldd	r24, Z+6	; 0x06
     cdc:	80 6c       	ori	r24, 0xC0	; 192
     cde:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:229

  (*_hwserial_module).CTRLA |= USART_RXCIE_bm;
     ce0:	ec 85       	ldd	r30, Y+12	; 0x0c
     ce2:	fd 85       	ldd	r31, Y+13	; 0x0d
     ce4:	85 81       	ldd	r24, Z+5	; 0x05
     ce6:	80 68       	ori	r24, 0x80	; 128
     ce8:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:234


  // Let PORTMUX point to alternative UART pins as requested
  #ifdef PORTMUX_CTRLB
    PORTMUX.CTRLB = set->mux | (PORTMUX.CTRLB & ~_hw_set[1].mux);
     cea:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     cee:	8b 89       	ldd	r24, Y+19	; 0x13
     cf0:	80 95       	com	r24
     cf2:	89 23       	and	r24, r25
     cf4:	78 01       	movw	r14, r16
     cf6:	ee 0c       	add	r14, r14
     cf8:	ff 1c       	adc	r15, r15
     cfa:	f7 01       	movw	r30, r14
     cfc:	e0 0f       	add	r30, r16
     cfe:	f1 1f       	adc	r31, r17
     d00:	ec 0f       	add	r30, r28
     d02:	fd 1f       	adc	r31, r29
     d04:	90 89       	ldd	r25, Z+16	; 0x10
     d06:	89 2b       	or	r24, r25
     d08:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:240
  #else
    PORTMUX.USARTROUTEA = set->mux | (PORTMUX.USARTROUTEA & ~_hw_set[1].mux);
  #endif

  // Set pin state for swapped UART pins
  pinMode(set->rx_pin, INPUT_PULLUP);
     d0c:	86 85       	ldd	r24, Z+14	; 0x0e
pinMode():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:32
#include "pins_arduino.h"


void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit_mask = digitalPinToBitMask(pin);
     d0e:	8c 30       	cpi	r24, 0x0C	; 12
     d10:	18 f4       	brcc	.+6      	; 0xd18 <UartClass::begin(unsigned long, unsigned int)+0xdc>
     d12:	62 e0       	ldi	r22, 0x02	; 2
     d14:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
_ZN9UartClass5beginEmj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:241
  digitalWrite(set->tx_pin, HIGH);
     d18:	f7 01       	movw	r30, r14
     d1a:	e0 0f       	add	r30, r16
     d1c:	f1 1f       	adc	r31, r17
     d1e:	ec 0f       	add	r30, r28
     d20:	fd 1f       	adc	r31, r29
     d22:	87 85       	ldd	r24, Z+15	; 0x0f
digitalWrite():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:147
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	/* Get bit mask for pin */
	uint8_t bit_mask = digitalPinToBitMask(pin);
     d24:	8c 30       	cpi	r24, 0x0C	; 12
     d26:	18 f4       	brcc	.+6      	; 0xd2e <UartClass::begin(unsigned long, unsigned int)+0xf2>
     d28:	61 e0       	ldi	r22, 0x01	; 1
     d2a:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
_ZN9UartClass5beginEmj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:242
  pinMode(set->tx_pin, OUTPUT);
     d2e:	0e 0d       	add	r16, r14
     d30:	1f 1d       	adc	r17, r15
     d32:	c0 0f       	add	r28, r16
     d34:	d1 1f       	adc	r29, r17
     d36:	8f 85       	ldd	r24, Y+15	; 0x0f
pinMode():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:32
#include "pins_arduino.h"


void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit_mask = digitalPinToBitMask(pin);
     d38:	8c 30       	cpi	r24, 0x0C	; 12
     d3a:	18 f4       	brcc	.+6      	; 0xd42 <UartClass::begin(unsigned long, unsigned int)+0x106>
     d3c:	61 e0       	ldi	r22, 0x01	; 1
     d3e:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
_ZN9UartClass5beginEmj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:245

  // Restore SREG content
  SREG = oldSREG;
     d42:	df be       	out	0x3f, r13	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:246
}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	bf 90       	pop	r11
     d54:	af 90       	pop	r10
     d56:	9f 90       	pop	r9
     d58:	8f 90       	pop	r8
     d5a:	08 95       	ret

00000d5c <micros>:
micros():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:192
    #else
      uint8_t ticks;
    #endif

    /* Save current state and disable interrupts */
    uint8_t status = SREG;
     d5c:	8f b7       	in	r24, 0x3f	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:193
    cli();
     d5e:	f8 94       	cli
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:199



    /* Get current number of overflows and timer count */
    #if !(defined(MILLIS_USE_TIMERB0)  || defined(MILLIS_USE_TIMERB1) )
      overflows = timer_overflow_count;
     d60:	20 91 1a 38 	lds	r18, 0x381A	; 0x80381a <timer_overflow_count>
     d64:	30 91 1b 38 	lds	r19, 0x381B	; 0x80381b <timer_overflow_count+0x1>
     d68:	40 91 1c 38 	lds	r20, 0x381C	; 0x80381c <timer_overflow_count+0x2>
     d6c:	50 91 1d 38 	lds	r21, 0x381D	; 0x80381d <timer_overflow_count+0x3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:207
    #endif

    #if defined(MILLIS_USE_TIMERA0)
      ticks = 0xFF-TCA0.SPLIT.LCNT;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CTRLE=TCD_SCAPTUREA_bm;
     d70:	98 e0       	ldi	r25, 0x08	; 8
     d72:	90 93 84 0a 	sts	0x0A84, r25	; 0x800a84 <__TEXT_REGION_LENGTH__+0x700a84>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:208
      while(!(TCD0.STATUS&TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
     d76:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <__TEXT_REGION_LENGTH__+0x700a8e>
     d7a:	91 ff       	sbrs	r25, 1
     d7c:	fc cf       	rjmp	.-8      	; 0xd76 <micros+0x1a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:209
      ticks=TCD0.CAPTUREA;
     d7e:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <__TEXT_REGION_LENGTH__+0x700aa2>
     d82:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <__TEXT_REGION_LENGTH__+0x700aa3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:218
    /* If the timer overflow flag is raised, and the ticks we read are low, then the timer has rolled over but
    ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
    so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it doesn't matter
    */
    #if defined(MILLIS_USE_TIMERD0)
      if ((TCD0.INTFLAGS & TCD_OVF_bm) && !(ticks&0xFF00)){
     d86:	90 91 8d 0a 	lds	r25, 0x0A8D	; 0x800a8d <__TEXT_REGION_LENGTH__+0x700a8d>
     d8a:	90 ff       	sbrs	r25, 0
     d8c:	08 c0       	rjmp	.+16     	; 0xd9e <micros+0x42>
     d8e:	bf 01       	movw	r22, r30
     d90:	66 27       	eor	r22, r22
     d92:	67 2b       	or	r22, r23
     d94:	21 f4       	brne	.+8      	; 0xd9e <micros+0x42>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:227
      if ((_timer->INTFLAGS & TCB_CAPT_bm) && !(ticks&0xFF00)) {
    #endif
    #if ((defined(MILLIS_USE_TIMERB0)|defined(MILLIS_USE_TIMERB1))&&(F_CPU>1000000))
      overflows++;
    #else
      overflows+=2;
     d96:	2e 5f       	subi	r18, 0xFE	; 254
     d98:	3f 4f       	sbci	r19, 0xFF	; 255
     d9a:	4f 4f       	sbci	r20, 0xFF	; 255
     d9c:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:234
    }

    //end getting ticks

    /* Restore state */
    SREG = status;
     d9e:	8f bf       	out	0x3f, r24	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:237
    #if defined(MILLIS_USE_TIMERD0)
      #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL)
        uint8_t ticks_l=ticks>>1;
     da0:	bf 01       	movw	r22, r30
     da2:	76 95       	lsr	r23
     da4:	67 95       	ror	r22
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:238
        ticks=ticks+ticks_l+((ticks_l>>2)-(ticks_l>>4)+(ticks_l>>7));
     da6:	cf 01       	movw	r24, r30
     da8:	86 0f       	add	r24, r22
     daa:	91 1d       	adc	r25, r1
     dac:	e6 2f       	mov	r30, r22
     dae:	e6 95       	lsr	r30
     db0:	e6 95       	lsr	r30
     db2:	76 2f       	mov	r23, r22
     db4:	72 95       	swap	r23
     db6:	7f 70       	andi	r23, 0x0F	; 15
     db8:	e7 1b       	sub	r30, r23
     dba:	ff 0b       	sbc	r31, r31
     dbc:	67 fd       	sbrc	r22, 7
     dbe:	31 96       	adiw	r30, 0x01	; 1
     dc0:	e8 0f       	add	r30, r24
     dc2:	f9 1f       	adc	r31, r25
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:239
        microseconds = overflows * (TIME_TRACKING_CYCLES_PER_OVF/(20))
     dc4:	a0 e3       	ldi	r26, 0x30	; 48
     dc6:	b3 e0       	ldi	r27, 0x03	; 3
     dc8:	0e 94 90 1b 	call	0x3720	; 0x3720 <__muluhisi3>
     dcc:	6e 0f       	add	r22, r30
     dce:	7f 1f       	adc	r23, r31
     dd0:	81 1d       	adc	r24, r1
     dd2:	91 1d       	adc	r25, r1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:284
        microseconds = ((overflows * clockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
          + (ticks * (clockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF)/TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif //end of timer-specific part of micros calculations
    return microseconds;
  }
     dd4:	08 95       	ret

00000dd6 <delay>:
delay():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:292

#endif //end of non-DISABLE_MILLIS code

#if !(defined(DISABLE_MILLIS) || defined(MILLIS_USE_TIMERRTC)) //delay implementation when we do have micros()
void delay(unsigned long ms)
{
     dd6:	8f 92       	push	r8
     dd8:	9f 92       	push	r9
     dda:	af 92       	push	r10
     ddc:	bf 92       	push	r11
     dde:	cf 92       	push	r12
     de0:	df 92       	push	r13
     de2:	ef 92       	push	r14
     de4:	ff 92       	push	r15
     de6:	4b 01       	movw	r8, r22
     de8:	5c 01       	movw	r10, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:293
  uint32_t start_time = micros(), delay_time = 1000*ms;
     dea:	0e 94 ae 06 	call	0xd5c	; 0xd5c <micros>
     dee:	6b 01       	movw	r12, r22
     df0:	7c 01       	movw	r14, r24
     df2:	a8 ee       	ldi	r26, 0xE8	; 232
     df4:	b3 e0       	ldi	r27, 0x03	; 3
     df6:	a5 01       	movw	r20, r10
     df8:	94 01       	movw	r18, r8
     dfa:	0e 94 90 1b 	call	0x3720	; 0x3720 <__muluhisi3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:296

  /* Calculate future time to return */
  uint32_t return_time = start_time + delay_time;
     dfe:	c6 0e       	add	r12, r22
     e00:	d7 1e       	adc	r13, r23
     e02:	e8 1e       	adc	r14, r24
     e04:	f9 1e       	adc	r15, r25
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:299

  /* If return time overflows */
  if(return_time < delay_time){
     e06:	c6 16       	cp	r12, r22
     e08:	d7 06       	cpc	r13, r23
     e0a:	e8 06       	cpc	r14, r24
     e0c:	f9 06       	cpc	r15, r25
     e0e:	18 f4       	brcc	.+6      	; 0xe16 <delay+0x40>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:301
    /* Wait until micros overflows */
    while(micros() > return_time);
     e10:	0e 94 ae 06 	call	0xd5c	; 0xd5c <micros>
     e14:	f8 cf       	rjmp	.-16     	; 0xe06 <delay+0x30>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:305
  }

  /* Wait until return time */
  while(micros() < return_time);
     e16:	0e 94 ae 06 	call	0xd5c	; 0xd5c <micros>
     e1a:	6c 15       	cp	r22, r12
     e1c:	7d 05       	cpc	r23, r13
     e1e:	8e 05       	cpc	r24, r14
     e20:	9f 05       	cpc	r25, r15
     e22:	c8 f3       	brcs	.-14     	; 0xe16 <delay+0x40>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:306
}
     e24:	ff 90       	pop	r15
     e26:	ef 90       	pop	r14
     e28:	df 90       	pop	r13
     e2a:	cf 90       	pop	r12
     e2c:	bf 90       	pop	r11
     e2e:	af 90       	pop	r10
     e30:	9f 90       	pop	r9
     e32:	8f 90       	pop	r8
     e34:	08 95       	ret

00000e36 <millis>:
millis():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:160
  //return timer_overflow_count; //for debugging timekeeping issues where these variables are out of scope from the sketch
  unsigned long m;

  // disable interrupts while we read timer0_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to timer0_millis)
  uint8_t status = SREG;
     e36:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:161
  cli();
     e38:	f8 94       	cli
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:173
    m=(m<<16);
    m+=RTC.CNT;
    //now correct for there being 1000ms to the second instead of 1024
    m=m-(m>>5)-(m>>6);
  #else
    m = timer_millis;
     e3a:	60 91 16 38 	lds	r22, 0x3816	; 0x803816 <timer_millis>
     e3e:	70 91 17 38 	lds	r23, 0x3817	; 0x803817 <timer_millis+0x1>
     e42:	80 91 18 38 	lds	r24, 0x3818	; 0x803818 <timer_millis+0x2>
     e46:	90 91 19 38 	lds	r25, 0x3819	; 0x803819 <timer_millis+0x3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:174
    SREG = status;
     e4a:	2f bf       	out	0x3f, r18	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:177
  #endif
  return m;
}
     e4c:	08 95       	ret

00000e4e <port_interrupt_handler>:
port_interrupt_handler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:106

    intFunc[interruptNum] = 0;
  }
}

static void port_interrupt_handler(uint8_t port) {
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	1f 93       	push	r17
     e56:	cf 93       	push	r28
     e58:	df 93       	push	r29
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:108

  PORT_t *portStruct = portToPortStruct(port);
     e5a:	90 e2       	ldi	r25, 0x20	; 32
     e5c:	89 9f       	mul	r24, r25
     e5e:	e0 01       	movw	r28, r0
     e60:	11 24       	eor	r1, r1
     e62:	dc 5f       	subi	r29, 0xFC	; 252
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:110
  /* Copy flags */
  uint8_t int_flags = portStruct->INTFLAGS;
     e64:	e9 84       	ldd	r14, Y+9	; 0x09
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:121

    /* Check if flag raised */
    if(int_flags & bit_mask){

    /* Get interrupt */
    uint8_t interrupt_num = port*8 + bit_pos;
     e66:	08 2f       	mov	r16, r24
     e68:	00 0f       	add	r16, r16
     e6a:	00 0f       	add	r16, r16
     e6c:	00 0f       	add	r16, r16
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:112

  PORT_t *portStruct = portToPortStruct(port);
  /* Copy flags */
  uint8_t int_flags = portStruct->INTFLAGS;

  uint8_t bit_pos = PIN0_bp, bit_mask = PIN0_bm;
     e6e:	ff 24       	eor	r15, r15
     e70:	f3 94       	inc	r15
     e72:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:118

  /* Iterate through flags */
  while(bit_pos <= PIN7_bp){

    /* Check if flag raised */
    if(int_flags & bit_mask){
     e74:	8e 2d       	mov	r24, r14
     e76:	8f 21       	and	r24, r15
     e78:	79 f0       	breq	.+30     	; 0xe98 <port_interrupt_handler+0x4a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:124

    /* Get interrupt */
    uint8_t interrupt_num = port*8 + bit_pos;

      /* Check if function defined */
      if(intFunc[interrupt_num] != 0){
     e7a:	e0 2f       	mov	r30, r16
     e7c:	e1 0f       	add	r30, r17
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	ee 0f       	add	r30, r30
     e82:	ff 1f       	adc	r31, r31
     e84:	ed 5d       	subi	r30, 0xDD	; 221
     e86:	f7 4c       	sbci	r31, 0xC7	; 199
     e88:	80 81       	ld	r24, Z
     e8a:	91 81       	ldd	r25, Z+1	; 0x01
     e8c:	89 2b       	or	r24, r25
     e8e:	21 f0       	breq	.+8      	; 0xe98 <port_interrupt_handler+0x4a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:127

        /* Call function */
        intFunc[interrupt_num]();
     e90:	01 90       	ld	r0, Z+
     e92:	f0 81       	ld	r31, Z
     e94:	e0 2d       	mov	r30, r0
     e96:	09 95       	icall
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:130
      }
    }
    bit_pos++;
     e98:	1f 5f       	subi	r17, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:131
    bit_mask = (bit_mask << 1);
     e9a:	ff 0c       	add	r15, r15
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:115
  uint8_t int_flags = portStruct->INTFLAGS;

  uint8_t bit_pos = PIN0_bp, bit_mask = PIN0_bm;

  /* Iterate through flags */
  while(bit_pos <= PIN7_bp){
     e9c:	18 30       	cpi	r17, 0x08	; 8
     e9e:	51 f7       	brne	.-44     	; 0xe74 <port_interrupt_handler+0x26>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:135
    bit_pos++;
    bit_mask = (bit_mask << 1);
  }

  /* Clear flags that have been handled */
  portStruct->INTFLAGS = int_flags;
     ea0:	e9 86       	std	Y+9, r14	; 0x09
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:136
}
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	08 95       	ret

00000eb0 <TWI_SlaveTransactionFinished>:
TWI_SlaveTransactionFinished():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:762
 *
 *  \param result  The result of the operation.
 */
void TWI_SlaveTransactionFinished(uint8_t result)
{
	TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
     eb0:	e0 e1       	ldi	r30, 0x10	; 16
     eb2:	f8 e0       	ldi	r31, 0x08	; 8
     eb4:	91 85       	ldd	r25, Z+9	; 0x09
     eb6:	90 66       	ori	r25, 0x60	; 96
     eb8:	91 87       	std	Z+9, r25	; 0x09
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:763
	twi_mode = TWI_MODE_SLAVE;
     eba:	92 e0       	ldi	r25, 0x02	; 2
     ebc:	90 93 22 38 	sts	0x3822, r25	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:764
	slave_result = result;
     ec0:	80 93 08 38 	sts	0x3808, r24	; 0x803808 <slave_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:765
	slave_trans_status = TWIM_STATUS_READY;
     ec4:	10 92 07 38 	sts	0x3807, r1	; 0x803807 <slave_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:766
}
     ec8:	08 95       	ret

00000eca <TWI_SlaveAddressMatchHandler>:
TWI_SlaveAddressMatchHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:606
 *  This is the slave address match handler that takes care of responding to
 *  being addressed by a master
 *
 */
void TWI_SlaveAddressMatchHandler(){
	slave_trans_status = TWIS_STATUS_BUSY;
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	80 93 07 38 	sts	0x3807, r24	; 0x803807 <slave_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:607
	slave_result = TWIS_RESULT_UNKNOWN;
     ed0:	10 92 08 38 	sts	0x3808, r1	; 0x803808 <slave_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:610

	/* Send ACK, wait for data interrupt */
	TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
     ed4:	93 e0       	ldi	r25, 0x03	; 3
     ed6:	90 93 1a 08 	sts	0x081A, r25	; 0x80081a <__TEXT_REGION_LENGTH__+0x70081a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:613

	/* If Master Read/Slave Write */
	if(TWI0.SSTATUS & TWI_DIR_bm){
     eda:	90 91 1b 08 	lds	r25, 0x081B	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
     ede:	91 ff       	sbrs	r25, 1
     ee0:	0b c0       	rjmp	.+22     	; 0xef8 <TWI_SlaveAddressMatchHandler+0x2e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:614
		slave_bytesWritten = 0;
     ee2:	10 92 12 38 	sts	0x3812, r1	; 0x803812 <slave_bytesWritten>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:616
		/* Call user function  */
		slave_bytesToWrite = TWI_onSlaveTransmit();
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	e0 e0       	ldi	r30, 0x00	; 0
     eea:	09 95       	icall
     eec:	80 93 11 38 	sts	0x3811, r24	; 0x803811 <slave_bytesToWrite>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:617
		twi_mode = TWI_MODE_SLAVE_TRANSMIT;
     ef0:	85 e0       	ldi	r24, 0x05	; 5
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:623
	}
	/* If Master Write/Slave Read */
	else {
		slave_bytesRead = 0;
		slave_callUserReceive = 1;
		twi_mode = TWI_MODE_SLAVE_RECEIVE;
     ef2:	80 93 22 38 	sts	0x3822, r24	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:627
	}

	/* Data interrupt to follow... */
}
     ef6:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:621
		slave_bytesToWrite = TWI_onSlaveTransmit();
		twi_mode = TWI_MODE_SLAVE_TRANSMIT;
	}
	/* If Master Write/Slave Read */
	else {
		slave_bytesRead = 0;
     ef8:	10 92 13 38 	sts	0x3813, r1	; 0x803813 <slave_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:622
		slave_callUserReceive = 1;
     efc:	80 93 10 38 	sts	0x3810, r24	; 0x803810 <slave_callUserReceive>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:623
		twi_mode = TWI_MODE_SLAVE_RECEIVE;
     f00:	86 e0       	ldi	r24, 0x06	; 6
     f02:	f7 cf       	rjmp	.-18     	; 0xef2 <TWI_SlaveAddressMatchHandler+0x28>

00000f04 <TWI_MasterWriteRead>:
TWI_MasterWriteRead():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:287
uint8_t TWI_MasterWriteRead(uint8_t slave_address,
                         uint8_t *write_data,
                         uint8_t bytes_to_write,
                         uint8_t bytes_to_read,
						 uint8_t send_stop)
{
     f04:	0f 93       	push	r16
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:288
	if(twi_mode != TWI_MODE_MASTER) return false;
     f06:	90 91 22 38 	lds	r25, 0x3822	; 0x803822 <twi_mode>
     f0a:	91 30       	cpi	r25, 0x01	; 1
     f0c:	09 f0       	breq	.+2      	; 0xf10 <TWI_MasterWriteRead+0xc>
     f0e:	4e c0       	rjmp	.+156    	; 0xfac <TWI_MasterWriteRead+0xa8>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:291

	/*Initiate transaction if bus is ready. */
	if (master_trans_status == TWIM_STATUS_READY) {
     f10:	30 91 1f 38 	lds	r19, 0x381F	; 0x80381f <master_trans_status>
     f14:	31 11       	cpse	r19, r1
     f16:	4c c0       	rjmp	.+152    	; 0xfb0 <TWI_MasterWriteRead+0xac>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:293

		master_trans_status = TWIM_STATUS_BUSY;
     f18:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <master_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:294
		master_result = TWIM_RESULT_UNKNOWN;
     f1c:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:296

		master_writeData = write_data;
     f20:	60 93 0a 38 	sts	0x380A, r22	; 0x80380a <master_writeData>
     f24:	70 93 0b 38 	sts	0x380B, r23	; 0x80380b <master_writeData+0x1>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:298

		master_bytesToWrite = bytes_to_write;
     f28:	40 93 0c 38 	sts	0x380C, r20	; 0x80380c <master_bytesToWrite>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:299
		master_bytesToRead = bytes_to_read;
     f2c:	20 93 0e 38 	sts	0x380E, r18	; 0x80380e <master_bytesToRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:300
		master_bytesWritten = 0;
     f30:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <master_bytesWritten>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:301
		master_bytesRead = 0;
     f34:	10 92 21 38 	sts	0x3821, r1	; 0x803821 <master_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:302
		master_sendStop = send_stop;
     f38:	00 93 0d 38 	sts	0x380D, r16	; 0x80380d <master_sendStop>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:303
		master_slaveAddress = slave_address<<1;
     f3c:	88 0f       	add	r24, r24
     f3e:	80 93 09 38 	sts	0x3809, r24	; 0x803809 <master_slaveAddress>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:326
			uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
			TWI0.MADDR = readAddress;
		}

		else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
			twi_mode = TWI_MODE_MASTER_TRANSMIT;
     f42:	93 e0       	ldi	r25, 0x03	; 3
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:320

		/* If read command, send the START condition + Address +
		 * 'R/_W = 1'
		 */
		else if (master_bytesToRead > 0) {
			twi_mode = TWI_MODE_MASTER_RECEIVE;
     f44:	24 e0       	ldi	r18, 0x04	; 4
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:310
trigger_action:

		/* If write command, send the START condition + Address +
		 * 'R/_W = 0'
		 */
		if (master_bytesToWrite > 0) {
     f46:	80 91 0c 38 	lds	r24, 0x380C	; 0x80380c <master_bytesToWrite>
     f4a:	88 23       	and	r24, r24
     f4c:	31 f0       	breq	.+12     	; 0xf5a <TWI_MasterWriteRead+0x56>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:326
			uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
			TWI0.MADDR = readAddress;
		}

		else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
			twi_mode = TWI_MODE_MASTER_TRANSMIT;
     f4e:	90 93 22 38 	sts	0x3822, r25	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:327
			uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
     f52:	80 91 09 38 	lds	r24, 0x3809	; 0x803809 <master_slaveAddress>
     f56:	8e 7f       	andi	r24, 0xFE	; 254
     f58:	09 c0       	rjmp	.+18     	; 0xf6c <TWI_MasterWriteRead+0x68>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:319
		}

		/* If read command, send the START condition + Address +
		 * 'R/_W = 1'
		 */
		else if (master_bytesToRead > 0) {
     f5a:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <master_bytesToRead>
     f5e:	88 23       	and	r24, r24
     f60:	41 f0       	breq	.+16     	; 0xf72 <TWI_MasterWriteRead+0x6e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:320
			twi_mode = TWI_MODE_MASTER_RECEIVE;
     f62:	20 93 22 38 	sts	0x3822, r18	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:321
			uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
     f66:	80 91 09 38 	lds	r24, 0x3809	; 0x803809 <master_slaveAddress>
     f6a:	81 60       	ori	r24, 0x01	; 1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:328
		}

		else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
			twi_mode = TWI_MODE_MASTER_TRANSMIT;
			uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
			TWI0.MADDR = writeAddress;
     f6c:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
     f70:	08 c0       	rjmp	.+16     	; 0xf82 <TWI_MasterWriteRead+0x7e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:325
			twi_mode = TWI_MODE_MASTER_RECEIVE;
			uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
			TWI0.MADDR = readAddress;
		}

		else if (master_bytesToWrite == 0 && master_bytesToRead == 0) {
     f72:	80 91 0c 38 	lds	r24, 0x380C	; 0x80380c <master_bytesToWrite>
     f76:	81 11       	cpse	r24, r1
     f78:	04 c0       	rjmp	.+8      	; 0xf82 <TWI_MasterWriteRead+0x7e>
     f7a:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <master_bytesToRead>
     f7e:	88 23       	and	r24, r24
     f80:	31 f3       	breq	.-52     	; 0xf4e <TWI_MasterWriteRead+0x4a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:332
			uint8_t writeAddress = ADD_WRITE_BIT(master_slaveAddress);
			TWI0.MADDR = writeAddress;
		}

		/* Arduino requires blocking function */
		while(master_result == TWIM_RESULT_UNKNOWN) {}
     f82:	80 91 1e 38 	lds	r24, 0x381E	; 0x80381e <master_result>
     f86:	88 23       	and	r24, r24
     f88:	e1 f3       	breq	.-8      	; 0xf82 <TWI_MasterWriteRead+0x7e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:335

		// in case of arbitration lost, retry sending
		if (master_result == TWIM_RESULT_ARBITRATION_LOST) {
     f8a:	80 91 1e 38 	lds	r24, 0x381E	; 0x80381e <master_result>
     f8e:	83 30       	cpi	r24, 0x03	; 3
     f90:	d1 f2       	breq	.-76     	; 0xf46 <TWI_MasterWriteRead+0x42>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:340
			goto trigger_action;
		}

		uint8_t ret = 0;
		if (master_bytesToRead > 0) {
     f92:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <master_bytesToRead>
     f96:	88 23       	and	r24, r24
     f98:	21 f0       	breq	.+8      	; 0xfa2 <TWI_MasterWriteRead+0x9e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:342
			// return bytes really read
			ret = master_bytesRead;
     f9a:	80 91 21 38 	lds	r24, 0x3821	; 0x803821 <master_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:352

		return ret;
	} else {
		return 1;
	}
}
     f9e:	0f 91       	pop	r16
     fa0:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:345
		if (master_bytesToRead > 0) {
			// return bytes really read
			ret = master_bytesRead;
		} else {
			// return 0 if success, >0 otherwise
			ret = (master_result == TWIM_RESULT_OK ? 0 : 1);
     fa2:	90 91 1e 38 	lds	r25, 0x381E	; 0x80381e <master_result>
     fa6:	81 e0       	ldi	r24, 0x01	; 1
     fa8:	91 30       	cpi	r25, 0x01	; 1
     faa:	c9 f7       	brne	.-14     	; 0xf9e <TWI_MasterWriteRead+0x9a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:288
                         uint8_t *write_data,
                         uint8_t bytes_to_write,
                         uint8_t bytes_to_read,
						 uint8_t send_stop)
{
	if(twi_mode != TWI_MODE_MASTER) return false;
     fac:	80 e0       	ldi	r24, 0x00	; 0
     fae:	f7 cf       	rjmp	.-18     	; 0xf9e <TWI_MasterWriteRead+0x9a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:350
			ret = (master_result == TWIM_RESULT_OK ? 0 : 1);
		}

		return ret;
	} else {
		return 1;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	f5 cf       	rjmp	.-22     	; 0xf9e <TWI_MasterWriteRead+0x9a>

00000fb4 <TwoWire::endTransmission() [clone .constprop.122]>:
_ZN7TwoWire15endTransmissionEv.constprop.122():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:294
}

//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
     fb4:	0f 93       	push	r16
TWI_MasterWrite():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:232
uint8_t TWI_MasterWrite(uint8_t slave_address,
					 uint8_t *write_data,
					 uint8_t bytes_to_write,
					 uint8_t send_stop)
{
	return TWI_MasterWriteRead(slave_address,
     fb6:	01 e0       	ldi	r16, 0x01	; 1
     fb8:	20 e0       	ldi	r18, 0x00	; 0
     fba:	40 91 ef 38 	lds	r20, 0x38EF	; 0x8038ef <TwoWire::txBufferLength>
     fbe:	6e ec       	ldi	r22, 0xCE	; 206
     fc0:	78 e3       	ldi	r23, 0x38	; 56
     fc2:	80 91 ee 38 	lds	r24, 0x38EE	; 0x8038ee <TwoWire::txAddress>
     fc6:	0e 94 82 07 	call	0xf04	; 0xf04 <TWI_MasterWriteRead>
endTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:282
{
	// transmit buffer (blocking)
	uint8_t status = TWI_MasterWrite(txAddress, txBuffer, txBufferLength, sendStop);

	// reset tx buffer iterator vars
	txBufferIndex = 0;
     fca:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:283
	txBufferLength = 0;
     fce:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN7TwoWire15endTransmissionEv.constprop.122():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:297
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
}
     fd2:	0f 91       	pop	r16
     fd4:	08 95       	ret

00000fd6 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:389
// 	rxBufferIndex = 0;
// 	rxBufferLength = 0;
//
// 	/* Turn off and on TWI module */
// 	TWI_Flush();
}
     fd6:	08 95       	ret

00000fd8 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:364
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
	int value = -1;

	if(rxBufferIndex < rxBufferLength){
     fd8:	e0 91 ac 38 	lds	r30, 0x38AC	; 0x8038ac <TwoWire::rxBufferIndex>
     fdc:	80 91 ab 38 	lds	r24, 0x38AB	; 0x8038ab <TwoWire::rxBufferLength>
     fe0:	e8 17       	cp	r30, r24
     fe2:	30 f4       	brcc	.+12     	; 0xff0 <TwoWire::peek()+0x18>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:365
		value = rxBuffer[rxBufferIndex];
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	e3 55       	subi	r30, 0x53	; 83
     fe8:	f7 4c       	sbci	r31, 0xC7	; 199
     fea:	80 81       	ld	r24, Z
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:362
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
	int value = -1;
     ff0:	8f ef       	ldi	r24, 0xFF	; 255
     ff2:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:369
	if(rxBufferIndex < rxBufferLength){
		value = rxBuffer[rxBufferIndex];
	}

	return value;
}
     ff4:	08 95       	ret

00000ff6 <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:349
int TwoWire::read(void)
{
	int value = -1;

	// get each successive byte on each call
	if(rxBufferIndex < rxBufferLength){
     ff6:	90 91 ac 38 	lds	r25, 0x38AC	; 0x8038ac <TwoWire::rxBufferIndex>
     ffa:	80 91 ab 38 	lds	r24, 0x38AB	; 0x8038ab <TwoWire::rxBufferLength>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:346
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
	int value = -1;
     ffe:	2f ef       	ldi	r18, 0xFF	; 255
    1000:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:349

	// get each successive byte on each call
	if(rxBufferIndex < rxBufferLength){
    1002:	98 17       	cp	r25, r24
    1004:	48 f4       	brcc	.+18     	; 0x1018 <TwoWire::read()+0x22>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:350
		value = rxBuffer[rxBufferIndex];
    1006:	e9 2f       	mov	r30, r25
    1008:	f0 e0       	ldi	r31, 0x00	; 0
    100a:	e3 55       	subi	r30, 0x53	; 83
    100c:	f7 4c       	sbci	r31, 0xC7	; 199
    100e:	20 81       	ld	r18, Z
    1010:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:351
		rxBufferIndex++;
    1012:	9f 5f       	subi	r25, 0xFF	; 255
    1014:	90 93 ac 38 	sts	0x38AC, r25	; 0x8038ac <TwoWire::rxBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:355
	}

	return value;
}
    1018:	c9 01       	movw	r24, r18
    101a:	08 95       	ret

0000101c <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:324

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    101c:	cf 92       	push	r12
    101e:	df 92       	push	r13
    1020:	ef 92       	push	r14
    1022:	ff 92       	push	r15
    1024:	0f 93       	push	r16
    1026:	1f 93       	push	r17
    1028:	cf 93       	push	r28
    102a:	df 93       	push	r29
    102c:	7c 01       	movw	r14, r24
    102e:	8a 01       	movw	r16, r20
    1030:	eb 01       	movw	r28, r22
    1032:	6b 01       	movw	r12, r22
    1034:	c4 0e       	add	r12, r20
    1036:	d5 1e       	adc	r13, r21
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:326

	for(size_t i = 0; i < quantity; i++){
    1038:	cc 15       	cp	r28, r12
    103a:	dd 05       	cpc	r29, r13
    103c:	51 f0       	breq	.+20     	; 0x1052 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:327
		write(*(data + i));
    103e:	69 91       	ld	r22, Y+
    1040:	d7 01       	movw	r26, r14
    1042:	ed 91       	ld	r30, X+
    1044:	fc 91       	ld	r31, X
    1046:	01 90       	ld	r0, Z+
    1048:	f0 81       	ld	r31, Z
    104a:	e0 2d       	mov	r30, r0
    104c:	c7 01       	movw	r24, r14
    104e:	09 95       	icall
    1050:	f3 cf       	rjmp	.-26     	; 0x1038 <TwoWire::write(unsigned char const*, unsigned int)+0x1c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:331
	}

	return quantity;
}
    1052:	c8 01       	movw	r24, r16
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	df 90       	pop	r13
    1062:	cf 90       	pop	r12
    1064:	08 95       	ret

00001066 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:305
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
	/* Check if buffer is full */
	if(txBufferLength >= BUFFER_LENGTH){
    1066:	20 91 ef 38 	lds	r18, 0x38EF	; 0x8038ef <TwoWire::txBufferLength>
    106a:	20 32       	cpi	r18, 0x20	; 32
    106c:	40 f0       	brcs	.+16     	; 0x107e <TwoWire::write(unsigned char)+0x18>
_ZN5Print13setWriteErrorEi():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.h:39
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    106e:	21 e0       	ldi	r18, 0x01	; 1
    1070:	30 e0       	ldi	r19, 0x00	; 0
    1072:	fc 01       	movw	r30, r24
    1074:	22 83       	std	Z+2, r18	; 0x02
    1076:	33 83       	std	Z+3, r19	; 0x03
_ZN7TwoWire5writeEh():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:307
	  setWriteError();
	  return 0;
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	80 e0       	ldi	r24, 0x00	; 0
    107c:	08 95       	ret
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:311
	}

	/* Put byte in txBuffer */
	txBuffer[txBufferIndex] = data;
    107e:	80 91 cd 38 	lds	r24, 0x38CD	; 0x8038cd <TwoWire::txBufferIndex>
    1082:	e8 2f       	mov	r30, r24
    1084:	f0 e0       	ldi	r31, 0x00	; 0
    1086:	e2 53       	subi	r30, 0x32	; 50
    1088:	f7 4c       	sbci	r31, 0xC7	; 199
    108a:	60 83       	st	Z, r22
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:312
	txBufferIndex++;
    108c:	8f 5f       	subi	r24, 0xFF	; 255
    108e:	80 93 cd 38 	sts	0x38CD, r24	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:315

	/* Update buffer length */
	txBufferLength = txBufferIndex;
    1092:	80 93 ef 38 	sts	0x38EF, r24	; 0x8038ef <TwoWire::txBufferLength>
    1096:	81 e0       	ldi	r24, 0x01	; 1
    1098:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:318

	return 1;
}
    109a:	08 95       	ret

0000109c <I2Cdev::writeWords(unsigned char, unsigned char, unsigned char, unsigned int*) [clone .constprop.120]>:
_ZN6I2Cdev10writeWordsEhhhPj.constprop.120():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:649
 * @param regAddr First register address to write to
 * @param length Number of words to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {
    109c:	cf 93       	push	r28
    109e:	df 93       	push	r29
    10a0:	ea 01       	movw	r28, r20
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:252
void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    10a2:	80 93 ee 38 	sts	0x38EE, r24	; 0x8038ee <TwoWire::txAddress>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    10a6:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    10aa:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN6I2Cdev10writeWordsEhhhPj.constprop.120():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:667
        Wire.send(regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        Wire.beginTransmission(devAddr);
        Wire.write(regAddr); // send address
    10ae:	8b ea       	ldi	r24, 0xAB	; 171
    10b0:	99 e3       	ldi	r25, 0x39	; 57
    10b2:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:683
            Wire.send((uint8_t)(data[i] >> 8));     // send MSB
            Wire.send((uint8_t)data[i]);          // send LSB
        #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
                || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
                || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
            Wire.write((uint8_t)(data[i] >> 8));    // send MSB
    10b6:	69 81       	ldd	r22, Y+1	; 0x01
    10b8:	8b ea       	ldi	r24, 0xAB	; 171
    10ba:	99 e3       	ldi	r25, 0x39	; 57
    10bc:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:684
            Wire.write((uint8_t)data[i]);         // send LSB
    10c0:	68 81       	ld	r22, Y
    10c2:	8b ea       	ldi	r24, 0xAB	; 171
    10c4:	99 e3       	ldi	r25, 0x39	; 57
    10c6:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:696
    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
        Wire.endTransmission();
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        status = Wire.endTransmission();
    10ca:	0e 94 da 07 	call	0xfb4	; 0xfb4 <TwoWire::endTransmission() [clone .constprop.122]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:704
        //status = Fastwire::endTransmission();
    #endif
    #ifdef I2CDEV_SERIAL_DEBUG
        Serial.println(". Done.");
    #endif
    return status == 0;
    10ce:	91 e0       	ldi	r25, 0x01	; 1
    10d0:	81 11       	cpse	r24, r1
    10d2:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:705
}
    10d4:	89 2f       	mov	r24, r25
    10d6:	df 91       	pop	r29
    10d8:	cf 91       	pop	r28
    10da:	08 95       	ret

000010dc <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]>:
_ZN6I2Cdev9readWordsEhhhPjj.constprop.115():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:331
 * @param length Number of words to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of words read (-1 indicates failure)
 */
int8_t I2Cdev::readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data, uint16_t timeout) {
    10dc:	4f 92       	push	r4
    10de:	5f 92       	push	r5
    10e0:	6f 92       	push	r6
    10e2:	7f 92       	push	r7
    10e4:	8f 92       	push	r8
    10e6:	9f 92       	push	r9
    10e8:	af 92       	push	r10
    10ea:	bf 92       	push	r11
    10ec:	df 92       	push	r13
    10ee:	ef 92       	push	r14
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	18 2f       	mov	r17, r24
    10fc:	06 2f       	mov	r16, r22
    10fe:	7a 01       	movw	r14, r20
    1100:	e9 01       	movw	r28, r18
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:343
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    uint32_t t1 = millis();
    1102:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    1106:	4b 01       	movw	r8, r22
    1108:	5c 01       	movw	r10, r24
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:252
void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    110a:	10 93 ee 38 	sts	0x38EE, r17	; 0x8038ee <TwoWire::txAddress>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    110e:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    1112:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN6I2Cdev9readWordsEhhhPjj.constprop.115():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:421
            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {
                Wire.beginTransmission(devAddr);
                Wire.write(regAddr);
    1116:	60 2f       	mov	r22, r16
    1118:	8b ea       	ldi	r24, 0xAB	; 171
    111a:	99 e3       	ldi	r25, 0x39	; 57
    111c:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:422
                Wire.endTransmission();
    1120:	0e 94 da 07 	call	0xfb4	; 0xfb4 <TwoWire::endTransmission() [clone .constprop.122]>
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    1124:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    1128:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
TWI_MasterRead():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:256
uint8_t TWI_MasterRead(uint8_t slave_address,
					uint8_t* read_data,
					uint8_t bytes_to_read,
					uint8_t send_stop)
{
	master_readData = read_data;
    112c:	8d ea       	ldi	r24, 0xAD	; 173
    112e:	98 e3       	ldi	r25, 0x38	; 56
    1130:	80 93 a9 38 	sts	0x38A9, r24	; 0x8038a9 <master_readData>
    1134:	90 93 aa 38 	sts	0x38AA, r25	; 0x8038aa <master_readData+0x1>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:258

	uint8_t bytes_read = TWI_MasterWriteRead(slave_address,
    1138:	01 e0       	ldi	r16, 0x01	; 1
    113a:	22 e0       	ldi	r18, 0x02	; 2
    113c:	40 e0       	ldi	r20, 0x00	; 0
    113e:	70 e0       	ldi	r23, 0x00	; 0
    1140:	60 e0       	ldi	r22, 0x00	; 0
    1142:	81 2f       	mov	r24, r17
    1144:	0e 94 82 07 	call	0xf04	; 0xf04 <TWI_MasterWriteRead>
requestFrom():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:226
	}

	uint8_t bytes_read = TWI_MasterRead(address, rxBuffer, quantity, sendStop);

	/* Initialize read variables */
	rxBufferIndex = 0;
    1148:	10 92 ac 38 	sts	0x38AC, r1	; 0x8038ac <TwoWire::rxBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:227
	rxBufferLength = bytes_read;
    114c:	80 93 ab 38 	sts	0x38AB, r24	; 0x8038ab <TwoWire::rxBufferLength>
_ZN6I2Cdev9readWordsEhhhPjj.constprop.115():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:342
        Serial.print(" words from 0x");
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    1150:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:427
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes
        
                bool msb = true; // starts with MSB, then LSB
                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {
    1152:	2e 01       	movw	r4, r28
    1154:	71 2c       	mov	r7, r1
    1156:	61 2c       	mov	r6, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:438
                        data[count] |= Wire.read();
                        #ifdef I2CDEV_SERIAL_DEBUG
                            Serial.print(data[count], HEX);
                            if (count + 1 < length) Serial.print(" ");
                        #endif
                        count++;
    1158:	dd 24       	eor	r13, r13
    115a:	d3 94       	inc	r13
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:427
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes
        
                bool msb = true; // starts with MSB, then LSB
                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {
    115c:	90 91 ab 38 	lds	r25, 0x38AB	; 0x8038ab <TwoWire::rxBufferLength>
    1160:	80 91 ac 38 	lds	r24, 0x38AC	; 0x8038ac <TwoWire::rxBufferIndex>
    1164:	98 17       	cp	r25, r24
    1166:	39 f1       	breq	.+78     	; 0x11b6 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0xda>
    1168:	11 11       	cpse	r17, r1
    116a:	25 c0       	rjmp	.+74     	; 0x11b6 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0xda>
    116c:	20 97       	sbiw	r28, 0x00	; 0
    116e:	c1 f4       	brne	.+48     	; 0x11a0 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0xc4>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:428
                    if (msb) {
    1170:	01 11       	cpse	r16, r1
    1172:	0e c0       	rjmp	.+28     	; 0x1190 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0xb4>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:433
                        // first byte is bits 15-8 (MSb=15)
                        data[count] = Wire.read() << 8;
                    } else {
                        // second byte is bits 7-0 (LSb=0)
                        data[count] |= Wire.read();
    1174:	8b ea       	ldi	r24, 0xAB	; 171
    1176:	99 e3       	ldi	r25, 0x39	; 57
    1178:	0e 94 fb 07 	call	0xff6	; 0xff6 <TwoWire::read()>
    117c:	f7 01       	movw	r30, r14
    117e:	20 81       	ld	r18, Z
    1180:	31 81       	ldd	r19, Z+1	; 0x01
    1182:	82 2b       	or	r24, r18
    1184:	93 2b       	or	r25, r19
    1186:	80 83       	st	Z, r24
    1188:	91 83       	std	Z+1, r25	; 0x01
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:438
                        #ifdef I2CDEV_SERIAL_DEBUG
                            Serial.print(data[count], HEX);
                            if (count + 1 < length) Serial.print(" ");
                        #endif
                        count++;
    118a:	11 e0       	ldi	r17, 0x01	; 1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:440
                    }
                    msb = !msb;
    118c:	0d 25       	eor	r16, r13
    118e:	e6 cf       	rjmp	.-52     	; 0x115c <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0x80>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:430
        
                bool msb = true; // starts with MSB, then LSB
                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {
                    if (msb) {
                        // first byte is bits 15-8 (MSb=15)
                        data[count] = Wire.read() << 8;
    1190:	8b ea       	ldi	r24, 0xAB	; 171
    1192:	99 e3       	ldi	r25, 0x39	; 57
    1194:	0e 94 fb 07 	call	0xff6	; 0xff6 <TwoWire::read()>
    1198:	f7 01       	movw	r30, r14
    119a:	10 82       	st	Z, r1
    119c:	81 83       	std	Z+1, r24	; 0x01
    119e:	f6 cf       	rjmp	.-20     	; 0x118c <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0xb0>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:427
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes
        
                bool msb = true; // starts with MSB, then LSB
                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {
    11a0:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    11a4:	68 19       	sub	r22, r8
    11a6:	79 09       	sbc	r23, r9
    11a8:	8a 09       	sbc	r24, r10
    11aa:	9b 09       	sbc	r25, r11
    11ac:	64 15       	cp	r22, r4
    11ae:	75 05       	cpc	r23, r5
    11b0:	86 05       	cpc	r24, r6
    11b2:	97 05       	cpc	r25, r7
    11b4:	e8 f2       	brcs	.-70     	; 0x1170 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0x94>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:443
                        count++;
                    }
                    msb = !msb;
                }
        
                Wire.endTransmission();
    11b6:	0e 94 da 07 	call	0xfb4	; 0xfb4 <TwoWire::endTransmission() [clone .constprop.122]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:464
            count = -1; // error
        }

    #endif

    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout
    11ba:	20 97       	sbiw	r28, 0x00	; 0
    11bc:	99 f0       	breq	.+38     	; 0x11e4 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0x108>
    11be:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    11c2:	ab 01       	movw	r20, r22
    11c4:	bc 01       	movw	r22, r24
    11c6:	48 19       	sub	r20, r8
    11c8:	59 09       	sbc	r21, r9
    11ca:	6a 09       	sbc	r22, r10
    11cc:	7b 09       	sbc	r23, r11
    11ce:	ce 01       	movw	r24, r28
    11d0:	b0 e0       	ldi	r27, 0x00	; 0
    11d2:	a0 e0       	ldi	r26, 0x00	; 0
    11d4:	48 17       	cp	r20, r24
    11d6:	59 07       	cpc	r21, r25
    11d8:	6a 07       	cpc	r22, r26
    11da:	7b 07       	cpc	r23, r27
    11dc:	18 f0       	brcs	.+6      	; 0x11e4 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0x108>
    11de:	11 11       	cpse	r17, r1
    11e0:	01 c0       	rjmp	.+2      	; 0x11e4 <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]+0x108>
    11e2:	1f ef       	ldi	r17, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:473
        Serial.print(count, DEC);
        Serial.println(" read).");
    #endif
    
    return count;
}
    11e4:	81 2f       	mov	r24, r17
    11e6:	df 91       	pop	r29
    11e8:	cf 91       	pop	r28
    11ea:	1f 91       	pop	r17
    11ec:	0f 91       	pop	r16
    11ee:	ff 90       	pop	r15
    11f0:	ef 90       	pop	r14
    11f2:	df 90       	pop	r13
    11f4:	bf 90       	pop	r11
    11f6:	af 90       	pop	r10
    11f8:	9f 90       	pop	r9
    11fa:	8f 90       	pop	r8
    11fc:	7f 90       	pop	r7
    11fe:	6f 90       	pop	r6
    1200:	5f 90       	pop	r5
    1202:	4f 90       	pop	r4
    1204:	08 95       	ret

00001206 <UartClass::begin(unsigned long)>:
_ZN9UartClass5beginEm():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.h:160

  public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t hwserial_rx_pin, uint8_t hwserial_tx_pin, uint8_t hwserial_rx_pin_swap, uint8_t hwserial_tx_pin_swap, uint8_t dre_vect_num, uint8_t uart_mux, uint8_t uart_mux_swap);
    bool pins(uint8_t tx, uint8_t rx);
    bool swap(uint8_t state = 1);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1206:	dc 01       	movw	r26, r24
    1208:	ed 91       	ld	r30, X+
    120a:	fc 91       	ld	r31, X
    120c:	06 84       	ldd	r0, Z+14	; 0x0e
    120e:	f7 85       	ldd	r31, Z+15	; 0x0f
    1210:	e0 2d       	mov	r30, r0
    1212:	23 e0       	ldi	r18, 0x03	; 3
    1214:	30 e0       	ldi	r19, 0x00	; 0
    1216:	09 94       	ijmp

00001218 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*)>:
_ZN6I2Cdev10writeBytesEhhhPh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:588
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data) {
    1218:	ff 92       	push	r15
    121a:	0f 93       	push	r16
    121c:	1f 93       	push	r17
    121e:	cf 93       	push	r28
    1220:	df 93       	push	r29
    1222:	04 2f       	mov	r16, r20
    1224:	f2 2e       	mov	r15, r18
    1226:	13 2f       	mov	r17, r19
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:252
void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    1228:	80 93 ee 38 	sts	0x38EE, r24	; 0x8038ee <TwoWire::txAddress>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    122c:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    1230:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN6I2Cdev10writeBytesEhhhPh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:606
        Wire.send((uint8_t) regAddr); // send address
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        Wire.beginTransmission(devAddr);
        Wire.write((uint8_t) regAddr); // send address
    1234:	8b ea       	ldi	r24, 0xAB	; 171
    1236:	99 e3       	ldi	r25, 0x39	; 57
    1238:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
    123c:	cf 2d       	mov	r28, r15
    123e:	d1 2f       	mov	r29, r17
    1240:	0c 0f       	add	r16, r28
    1242:	1d 2f       	mov	r17, r29
    1244:	11 1d       	adc	r17, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:611
    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)
        Fastwire::beginTransmission(devAddr);
        Fastwire::write(regAddr);
    #endif
    for (uint8_t i = 0; i < length; i++) {
    1246:	c0 17       	cp	r28, r16
    1248:	d1 07       	cpc	r29, r17
    124a:	31 f0       	breq	.+12     	; 0x1258 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*)+0x40>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:621
        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
            Wire.send((uint8_t) data[i]);
        #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
                || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
                || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
            Wire.write((uint8_t) data[i]);
    124c:	69 91       	ld	r22, Y+
    124e:	8b ea       	ldi	r24, 0xAB	; 171
    1250:	99 e3       	ldi	r25, 0x39	; 57
    1252:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
    1256:	f7 cf       	rjmp	.-18     	; 0x1246 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*)+0x2e>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:631
    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)
        Wire.endTransmission();
    #elif ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100) \
            || (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE && ARDUINO >= 100) \
            || I2CDEV_IMPLEMENTATION == I2CDEV_TEENSY_3X_WIRE)
        status = Wire.endTransmission();
    1258:	0e 94 da 07 	call	0xfb4	; 0xfb4 <TwoWire::endTransmission() [clone .constprop.122]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:639
        //status = Fastwire::endTransmission();
    #endif
    #ifdef I2CDEV_SERIAL_DEBUG
        Serial.println(". Done.");
    #endif
    return status == 0;
    125c:	91 e0       	ldi	r25, 0x01	; 1
    125e:	81 11       	cpse	r24, r1
    1260:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:640
}
    1262:	89 2f       	mov	r24, r25
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	ff 90       	pop	r15
    126e:	08 95       	ret

00001270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>:
_ZN6I2Cdev9writeByteEhhh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:567
 * @param devAddr I2C slave device address
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	1f 92       	push	r1
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	49 83       	std	Y+1, r20	; 0x01
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:568
    return writeBytes(devAddr, regAddr, 1, &data);
    127c:	9e 01       	movw	r18, r28
    127e:	2f 5f       	subi	r18, 0xFF	; 255
    1280:	3f 4f       	sbci	r19, 0xFF	; 255
    1282:	41 e0       	ldi	r20, 0x01	; 1
    1284:	0e 94 0c 09 	call	0x1218	; 0x1218 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:569
}
    1288:	0f 90       	pop	r0
    128a:	df 91       	pop	r29
    128c:	cf 91       	pop	r28
    128e:	08 95       	ret

00001290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>:
_ZN6I2Cdev9readBytesEhhhPhj():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:211
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {
    1290:	2f 92       	push	r2
    1292:	3f 92       	push	r3
    1294:	4f 92       	push	r4
    1296:	5f 92       	push	r5
    1298:	6f 92       	push	r6
    129a:	7f 92       	push	r7
    129c:	8f 92       	push	r8
    129e:	9f 92       	push	r9
    12a0:	af 92       	push	r10
    12a2:	bf 92       	push	r11
    12a4:	cf 92       	push	r12
    12a6:	df 92       	push	r13
    12a8:	ef 92       	push	r14
    12aa:	ff 92       	push	r15
    12ac:	0f 93       	push	r16
    12ae:	1f 93       	push	r17
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	cd b7       	in	r28, 0x3d	; 61
    12b6:	de b7       	in	r29, 0x3e	; 62
    12b8:	25 97       	sbiw	r28, 0x05	; 5
    12ba:	cd bf       	out	0x3d, r28	; 61
    12bc:	de bf       	out	0x3e, r29	; 62
    12be:	8a 83       	std	Y+2, r24	; 0x02
    12c0:	6b 83       	std	Y+3, r22	; 0x03
    12c2:	f4 2e       	mov	r15, r20
    12c4:	69 01       	movw	r12, r18
    12c6:	0c 83       	std	Y+4, r16	; 0x04
    12c8:	1d 83       	std	Y+5, r17	; 0x05
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:223
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    uint32_t t1 = millis();
    12ca:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    12ce:	4b 01       	movw	r8, r22
    12d0:	5c 01       	movw	r10, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:286
            for (uint8_t k = 0; k < length; k += min((int)length, BUFFER_LENGTH)) {
                Wire.beginTransmission(devAddr);
                Wire.write(regAddr);
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));
    12d2:	2f 2c       	mov	r2, r15
    12d4:	31 2c       	mov	r3, r1
    12d6:	f9 82       	std	Y+1, r15	; 0x01
    12d8:	20 e2       	ldi	r18, 0x20	; 32
    12da:	2f 15       	cp	r18, r15
    12dc:	10 f4       	brcc	.+4      	; 0x12e2 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x52>
    12de:	30 e2       	ldi	r19, 0x20	; 32
    12e0:	39 83       	std	Y+1, r19	; 0x01
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:281
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (uint8_t k = 0; k < length; k += min((int)length, BUFFER_LENGTH)) {
    12e2:	e1 2c       	mov	r14, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:222
        Serial.print(" bytes from 0x");
        Serial.print(regAddr, HEX);
        Serial.print("...");
    #endif

    int8_t count = 0;
    12e4:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:288
                Wire.write(regAddr);
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));
        
                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    12e6:	8c 81       	ldd	r24, Y+4	; 0x04
    12e8:	9d 81       	ldd	r25, Y+5	; 0x05
    12ea:	2c 01       	movw	r4, r24
    12ec:	71 2c       	mov	r7, r1
    12ee:	61 2c       	mov	r6, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:281
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (uint8_t k = 0; k < length; k += min((int)length, BUFFER_LENGTH)) {
    12f0:	ef 14       	cp	r14, r15
    12f2:	08 f0       	brcs	.+2      	; 0x12f6 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x66>
    12f4:	54 c0       	rjmp	.+168    	; 0x139e <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x10e>
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:252
void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
    12f6:	9a 81       	ldd	r25, Y+2	; 0x02
    12f8:	90 93 ee 38 	sts	0x38EE, r25	; 0x8038ee <TwoWire::txAddress>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    12fc:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    1300:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN6I2Cdev9readBytesEhhhPhj():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:283
                Wire.beginTransmission(devAddr);
                Wire.write(regAddr);
    1304:	6b 81       	ldd	r22, Y+3	; 0x03
    1306:	8b ea       	ldi	r24, 0xAB	; 171
    1308:	99 e3       	ldi	r25, 0x39	; 57
    130a:	0e 94 33 08 	call	0x1066	; 0x1066 <TwoWire::write(unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:284
                Wire.endTransmission();
    130e:	0e 94 da 07 	call	0xfb4	; 0xfb4 <TwoWire::endTransmission() [clone .constprop.122]>
beginTransmission():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:254
  // indicate that we are transmitting
  transmitting = 1;
  // set address of targeted slave
  txAddress = address;
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    1312:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:255
  txBufferLength = 0;
    1316:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
_ZN6I2Cdev9readBytesEhhhPhj():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:286
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));
    131a:	91 01       	movw	r18, r2
    131c:	2e 19       	sub	r18, r14
    131e:	31 09       	sbc	r19, r1
    1320:	20 32       	cpi	r18, 0x20	; 32
    1322:	31 05       	cpc	r19, r1
    1324:	14 f0       	brlt	.+4      	; 0x132a <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x9a>
    1326:	20 e2       	ldi	r18, 0x20	; 32
    1328:	30 e0       	ldi	r19, 0x00	; 0
TWI_MasterRead():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:256
uint8_t TWI_MasterRead(uint8_t slave_address,
					uint8_t* read_data,
					uint8_t bytes_to_read,
					uint8_t send_stop)
{
	master_readData = read_data;
    132a:	8d ea       	ldi	r24, 0xAD	; 173
    132c:	98 e3       	ldi	r25, 0x38	; 56
    132e:	80 93 a9 38 	sts	0x38A9, r24	; 0x8038a9 <master_readData>
    1332:	90 93 aa 38 	sts	0x38AA, r25	; 0x8038aa <master_readData+0x1>
requestFrom():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:223
uint8_t TwoWire::requestFrom(uint8_t address, size_t quantity, bool sendStop) {
	if(quantity > BUFFER_LENGTH){
		quantity = BUFFER_LENGTH;
	}

	uint8_t bytes_read = TWI_MasterRead(address, rxBuffer, quantity, sendStop);
    1336:	33 27       	eor	r19, r19
    1338:	21 32       	cpi	r18, 0x21	; 33
    133a:	31 05       	cpc	r19, r1
    133c:	14 f0       	brlt	.+4      	; 0x1342 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0xb2>
    133e:	20 e2       	ldi	r18, 0x20	; 32
    1340:	30 e0       	ldi	r19, 0x00	; 0
TWI_MasterRead():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:258

	uint8_t bytes_read = TWI_MasterWriteRead(slave_address,
    1342:	01 e0       	ldi	r16, 0x01	; 1
    1344:	40 e0       	ldi	r20, 0x00	; 0
    1346:	70 e0       	ldi	r23, 0x00	; 0
    1348:	60 e0       	ldi	r22, 0x00	; 0
    134a:	8a 81       	ldd	r24, Y+2	; 0x02
    134c:	0e 94 82 07 	call	0xf04	; 0xf04 <TWI_MasterWriteRead>
    1350:	08 2f       	mov	r16, r24
requestFrom():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:226

	/* Initialize read variables */
	rxBufferIndex = 0;
    1352:	10 92 ac 38 	sts	0x38AC, r1	; 0x8038ac <TwoWire::rxBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:227
	rxBufferLength = bytes_read;
    1356:	80 93 ab 38 	sts	0x38AB, r24	; 0x8038ab <TwoWire::rxBufferLength>
_ZN6I2Cdev9readBytesEhhhPhj():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:288
        
                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    135a:	80 91 ac 38 	lds	r24, 0x38AC	; 0x8038ac <TwoWire::rxBufferIndex>
    135e:	08 17       	cp	r16, r24
    1360:	d9 f0       	breq	.+54     	; 0x1398 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x108>
    1362:	2c 81       	ldd	r18, Y+4	; 0x04
    1364:	3d 81       	ldd	r19, Y+5	; 0x05
    1366:	23 2b       	or	r18, r19
    1368:	61 f4       	brne	.+24     	; 0x1382 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0xf2>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:289
                    data[count] = Wire.read();
    136a:	8b ea       	ldi	r24, 0xAB	; 171
    136c:	99 e3       	ldi	r25, 0x39	; 57
    136e:	0e 94 fb 07 	call	0xff6	; 0xff6 <TwoWire::read()>
    1372:	f6 01       	movw	r30, r12
    1374:	e1 0f       	add	r30, r17
    1376:	f1 1d       	adc	r31, r1
    1378:	17 fd       	sbrc	r17, 7
    137a:	fa 95       	dec	r31
    137c:	80 83       	st	Z, r24
    137e:	1f 5f       	subi	r17, 0xFF	; 255
    1380:	ec cf       	rjmp	.-40     	; 0x135a <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0xca>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:288
                Wire.write(regAddr);
                Wire.endTransmission();
                Wire.beginTransmission(devAddr);
                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));
        
                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {
    1382:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    1386:	68 19       	sub	r22, r8
    1388:	79 09       	sbc	r23, r9
    138a:	8a 09       	sbc	r24, r10
    138c:	9b 09       	sbc	r25, r11
    138e:	64 15       	cp	r22, r4
    1390:	75 05       	cpc	r23, r5
    1392:	86 05       	cpc	r24, r6
    1394:	97 05       	cpc	r25, r7
    1396:	48 f3       	brcs	.-46     	; 0x136a <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0xda>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:281
            // Adds official support for repeated start condition, yay!

            // I2C/TWI subsystem uses internal buffer that breaks with large data requests
            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in
            // smaller chunks instead of all at once
            for (uint8_t k = 0; k < length; k += min((int)length, BUFFER_LENGTH)) {
    1398:	39 81       	ldd	r19, Y+1	; 0x01
    139a:	e3 0e       	add	r14, r19
    139c:	a9 cf       	rjmp	.-174    	; 0x12f0 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x60>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:312
        }

    #endif

    // check for timeout
    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout
    139e:	8c 81       	ldd	r24, Y+4	; 0x04
    13a0:	9d 81       	ldd	r25, Y+5	; 0x05
    13a2:	89 2b       	or	r24, r25
    13a4:	d1 f0       	breq	.+52     	; 0x13da <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x14a>
    13a6:	0e 94 1b 07 	call	0xe36	; 0xe36 <millis>
    13aa:	ab 01       	movw	r20, r22
    13ac:	bc 01       	movw	r22, r24
    13ae:	48 19       	sub	r20, r8
    13b0:	59 09       	sbc	r21, r9
    13b2:	6a 09       	sbc	r22, r10
    13b4:	7b 09       	sbc	r23, r11
    13b6:	2c 81       	ldd	r18, Y+4	; 0x04
    13b8:	3d 81       	ldd	r19, Y+5	; 0x05
    13ba:	c9 01       	movw	r24, r18
    13bc:	b0 e0       	ldi	r27, 0x00	; 0
    13be:	a0 e0       	ldi	r26, 0x00	; 0
    13c0:	48 17       	cp	r20, r24
    13c2:	59 07       	cpc	r21, r25
    13c4:	6a 07       	cpc	r22, r26
    13c6:	7b 07       	cpc	r23, r27
    13c8:	40 f0       	brcs	.+16     	; 0x13da <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x14a>
    13ca:	81 2f       	mov	r24, r17
    13cc:	01 2e       	mov	r0, r17
    13ce:	00 0c       	add	r0, r0
    13d0:	99 0b       	sbc	r25, r25
    13d2:	82 15       	cp	r24, r2
    13d4:	93 05       	cpc	r25, r3
    13d6:	0c f4       	brge	.+2      	; 0x13da <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)+0x14a>
    13d8:	1f ef       	ldi	r17, 0xFF	; 255
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:321
        Serial.print(count, DEC);
        Serial.println(" read).");
    #endif

    return count;
}
    13da:	81 2f       	mov	r24, r17
    13dc:	25 96       	adiw	r28, 0x05	; 5
    13de:	cd bf       	out	0x3d, r28	; 61
    13e0:	de bf       	out	0x3e, r29	; 62
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	df 90       	pop	r13
    13f0:	cf 90       	pop	r12
    13f2:	bf 90       	pop	r11
    13f4:	af 90       	pop	r10
    13f6:	9f 90       	pop	r9
    13f8:	8f 90       	pop	r8
    13fa:	7f 90       	pop	r7
    13fc:	6f 90       	pop	r6
    13fe:	5f 90       	pop	r5
    1400:	4f 90       	pop	r4
    1402:	3f 90       	pop	r3
    1404:	2f 90       	pop	r2
    1406:	08 95       	ret

00001408 <MPU6050::getFIFOCount() [clone .constprop.90]>:
_ZN7MPU605012getFIFOCountEv.constprop.90():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2700
 * number is in turn the number of bytes that can be read from the FIFO buffer
 * and it is directly proportional to the number of samples available given the
 * set of sensor data bound to be stored in the FIFO (register 35 and 36).
 * @return Current FIFO buffer size
 */
uint16_t MPU6050::getFIFOCount() {
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
    140e:	df 93       	push	r29
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2701
    I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_COUNTH, 2, buffer);
    1410:	c5 ee       	ldi	r28, 0xE5	; 229
    1412:	d9 e3       	ldi	r29, 0x39	; 57
    1414:	08 ee       	ldi	r16, 0xE8	; 232
    1416:	13 e0       	ldi	r17, 0x03	; 3
    1418:	26 ee       	ldi	r18, 0xE6	; 230
    141a:	39 e3       	ldi	r19, 0x39	; 57
    141c:	42 e0       	ldi	r20, 0x02	; 2
    141e:	62 e7       	ldi	r22, 0x72	; 114
    1420:	88 81       	ld	r24, Y
    1422:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2702
    return (((uint16_t)buffer[0]) << 8) | buffer[1];
    1426:	89 81       	ldd	r24, Y+1	; 0x01
    1428:	9a 81       	ldd	r25, Y+2	; 0x02
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2703
}
    142a:	98 27       	eor	r25, r24
    142c:	89 27       	eor	r24, r25
    142e:	98 27       	eor	r25, r24
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	1f 91       	pop	r17
    1436:	0f 91       	pop	r16
    1438:	08 95       	ret

0000143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
_ZN6I2Cdev9writeBitsEhhhhh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:511
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
    143a:	bf 92       	push	r11
    143c:	cf 92       	push	r12
    143e:	df 92       	push	r13
    1440:	ef 92       	push	r14
    1442:	ff 92       	push	r15
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	1f 92       	push	r1
    144e:	cd b7       	in	r28, 0x3d	; 61
    1450:	de b7       	in	r29, 0x3e	; 62
    1452:	f8 2e       	mov	r15, r24
    1454:	e6 2e       	mov	r14, r22
    1456:	c4 2e       	mov	r12, r20
    1458:	b2 2e       	mov	r11, r18
    145a:	d0 2e       	mov	r13, r16
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return readBytes(devAddr, regAddr, 1, data, timeout);
    145c:	08 ee       	ldi	r16, 0xE8	; 232
    145e:	13 e0       	ldi	r17, 0x03	; 3
    1460:	9e 01       	movw	r18, r28
    1462:	2f 5f       	subi	r18, 0xFF	; 255
    1464:	3f 4f       	sbci	r19, 0xFF	; 255
    1466:	41 e0       	ldi	r20, 0x01	; 1
    1468:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
_ZN6I2Cdev9writeBitsEhhhhh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:520
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b) != 0) {
    146c:	88 23       	and	r24, r24
    146e:	71 f1       	breq	.+92     	; 0x14cc <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x92>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:521
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
    1470:	8c 2d       	mov	r24, r12
    1472:	8b 19       	sub	r24, r11
    1474:	99 0b       	sbc	r25, r25
    1476:	ac 01       	movw	r20, r24
    1478:	4f 5f       	subi	r20, 0xFF	; 255
    147a:	5f 4f       	sbci	r21, 0xFF	; 255
    147c:	81 e0       	ldi	r24, 0x01	; 1
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	02 c0       	rjmp	.+4      	; 0x1486 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x4c>
    1482:	88 0f       	add	r24, r24
    1484:	99 1f       	adc	r25, r25
    1486:	ba 94       	dec	r11
    1488:	e2 f7       	brpl	.-8      	; 0x1482 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x48>
    148a:	01 97       	sbiw	r24, 0x01	; 1
    148c:	04 2e       	mov	r0, r20
    148e:	01 c0       	rjmp	.+2      	; 0x1492 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x58>
    1490:	88 0f       	add	r24, r24
    1492:	0a 94       	dec	r0
    1494:	ea f7       	brpl	.-6      	; 0x1490 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x56>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:522
        data <<= (bitStart - length + 1); // shift data into correct position
    1496:	0d 2d       	mov	r16, r13
    1498:	01 c0       	rjmp	.+2      	; 0x149c <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x62>
    149a:	00 0f       	add	r16, r16
    149c:	4a 95       	dec	r20
    149e:	ea f7       	brpl	.-6      	; 0x149a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x60>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:524
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
    14a0:	48 2f       	mov	r20, r24
    14a2:	40 95       	com	r20
    14a4:	99 81       	ldd	r25, Y+1	; 0x01
    14a6:	49 23       	and	r20, r25
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:523
    // 10101011 masked | value
    uint8_t b;
    if (readByte(devAddr, regAddr, &b) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
    14a8:	80 23       	and	r24, r16
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:525
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
    14aa:	48 2b       	or	r20, r24
    14ac:	49 83       	std	Y+1, r20	; 0x01
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:526
        return writeByte(devAddr, regAddr, b);
    14ae:	6e 2d       	mov	r22, r14
    14b0:	8f 2d       	mov	r24, r15
    14b2:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:530
    } else {
        return false;
    }
}
    14b6:	0f 90       	pop	r0
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	df 90       	pop	r13
    14c6:	cf 90       	pop	r12
    14c8:	bf 90       	pop	r11
    14ca:	08 95       	ret
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:528
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
        return writeByte(devAddr, regAddr, b);
    } else {
        return false;
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	f3 cf       	rjmp	.-26     	; 0x14b6 <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x7c>

000014d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>:
_ZN6I2Cdev8writeBitEhhhh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:482
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
    14d0:	cf 92       	push	r12
    14d2:	df 92       	push	r13
    14d4:	ef 92       	push	r14
    14d6:	ff 92       	push	r15
    14d8:	0f 93       	push	r16
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	1f 92       	push	r1
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
    14e6:	f8 2e       	mov	r15, r24
    14e8:	e6 2e       	mov	r14, r22
    14ea:	c4 2e       	mov	r12, r20
    14ec:	d2 2e       	mov	r13, r18
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return readBytes(devAddr, regAddr, 1, data, timeout);
    14ee:	08 ee       	ldi	r16, 0xE8	; 232
    14f0:	13 e0       	ldi	r17, 0x03	; 3
    14f2:	9e 01       	movw	r18, r28
    14f4:	2f 5f       	subi	r18, 0xFF	; 255
    14f6:	3f 4f       	sbci	r19, 0xFF	; 255
    14f8:	41 e0       	ldi	r20, 0x01	; 1
    14fa:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
    14fe:	81 e0       	ldi	r24, 0x01	; 1
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	01 c0       	rjmp	.+2      	; 0x1506 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)+0x36>
    1504:	88 0f       	add	r24, r24
    1506:	ca 94       	dec	r12
    1508:	ea f7       	brpl	.-6      	; 0x1504 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)+0x34>
    150a:	49 81       	ldd	r20, Y+1	; 0x01
_ZN6I2Cdev8writeBitEhhhh():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:485
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
    uint8_t b;
    readByte(devAddr, regAddr, &b);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    150c:	dd 20       	and	r13, r13
    150e:	81 f0       	breq	.+32     	; 0x1530 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)+0x60>
    1510:	48 2b       	or	r20, r24
    1512:	49 83       	std	Y+1, r20	; 0x01
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:486
    return writeByte(devAddr, regAddr, b);
    1514:	6e 2d       	mov	r22, r14
    1516:	8f 2d       	mov	r24, r15
    1518:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:487
}
    151c:	0f 90       	pop	r0
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	1f 91       	pop	r17
    1524:	0f 91       	pop	r16
    1526:	ff 90       	pop	r15
    1528:	ef 90       	pop	r14
    152a:	df 90       	pop	r13
    152c:	cf 90       	pop	r12
    152e:	08 95       	ret
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:485
 * @return Status of operation (true = success)
 */
bool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
    uint8_t b;
    readByte(devAddr, regAddr, &b);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    1530:	80 95       	com	r24
    1532:	48 23       	and	r20, r24
    1534:	ee cf       	rjmp	.-36     	; 0x1512 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)+0x42>

00001536 <MPU6050::resetFIFO() [clone .constprop.96]>:
_ZN7MPU60509resetFIFOEv.constprop.96():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2384
 * bit automatically clears to 0 after the reset has been triggered.
 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_FIFO_RESET_BIT
 */
void MPU6050::resetFIFO() {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, true);
    1536:	21 e0       	ldi	r18, 0x01	; 1
    1538:	42 e0       	ldi	r20, 0x02	; 2
    153a:	6a e6       	ldi	r22, 0x6A	; 106
    153c:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1540:	0c 94 68 0a 	jmp	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>

00001544 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]>:
_ZN7MPU605016writeMemoryBlockEPKhjhhbb.constprop.80():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3076
            setMemoryBank(bank);
            setMemoryStartAddress(address);
        }
    }
}
bool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {
    1544:	2f 92       	push	r2
    1546:	3f 92       	push	r3
    1548:	4f 92       	push	r4
    154a:	5f 92       	push	r5
    154c:	6f 92       	push	r6
    154e:	7f 92       	push	r7
    1550:	8f 92       	push	r8
    1552:	9f 92       	push	r9
    1554:	af 92       	push	r10
    1556:	bf 92       	push	r11
    1558:	cf 92       	push	r12
    155a:	df 92       	push	r13
    155c:	ef 92       	push	r14
    155e:	ff 92       	push	r15
    1560:	0f 93       	push	r16
    1562:	1f 93       	push	r17
    1564:	cf 93       	push	r28
    1566:	df 93       	push	r29
    1568:	3c 01       	movw	r6, r24
    156a:	5b 01       	movw	r10, r22
    156c:	24 2e       	mov	r2, r20
    156e:	52 2e       	mov	r5, r18
    1570:	30 2e       	mov	r3, r16
setMemoryBank():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3027

void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
    1572:	6d e6       	ldi	r22, 0x6D	; 109
    1574:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1578:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setMemoryStartAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3033
}

// MEM_START_ADDR register

void MPU6050::setMemoryStartAddress(uint8_t address) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
    157c:	45 2d       	mov	r20, r5
    157e:	6e e6       	ldi	r22, 0x6E	; 110
    1580:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1584:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
_ZN7MPU605016writeMemoryBlockEPKhjhhbb.constprop.80():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3084
    uint8_t chunkSize;
    uint8_t *verifyBuffer=0;
    uint8_t *progBuffer=0;
    uint16_t i;
    uint8_t j;
    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    1588:	80 e1       	ldi	r24, 0x10	; 16
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	0e 94 b8 1b 	call	0x3770	; 0x3770 <malloc>
    1590:	6c 01       	movw	r12, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3081
bool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {
    setMemoryBank(bank);
    setMemoryStartAddress(address);
    uint8_t chunkSize;
    uint8_t *verifyBuffer=0;
    uint8_t *progBuffer=0;
    1592:	d0 e0       	ldi	r29, 0x00	; 0
    1594:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3085
    uint16_t i;
    uint8_t j;
    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    1596:	00 23       	and	r16, r16
    1598:	29 f0       	breq	.+10     	; 0x15a4 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x60>
    159a:	80 e1       	ldi	r24, 0x10	; 16
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	0e 94 b8 1b 	call	0x3770	; 0x3770 <malloc>
    15a2:	ec 01       	movw	r28, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3081
bool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {
    setMemoryBank(bank);
    setMemoryStartAddress(address);
    uint8_t chunkSize;
    uint8_t *verifyBuffer=0;
    uint8_t *progBuffer=0;
    15a4:	f1 2c       	mov	r15, r1
    15a6:	e1 2c       	mov	r14, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3091
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;
    15a8:	c7 01       	movw	r24, r14
    15aa:	40 96       	adiw	r24, 0x10	; 16
    15ac:	4a 2c       	mov	r4, r10
    15ae:	4e 18       	sub	r4, r14
    15b0:	a8 16       	cp	r10, r24
    15b2:	b9 06       	cpc	r11, r25
    15b4:	10 f0       	brcs	.+4      	; 0x15ba <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x76>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3088
    uint8_t j;
    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
    15b6:	80 e1       	ldi	r24, 0x10	; 16
    15b8:	48 2e       	mov	r4, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3094

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	91 e0       	ldi	r25, 0x01	; 1
    15be:	85 19       	sub	r24, r5
    15c0:	91 09       	sbc	r25, r1
    15c2:	48 16       	cp	r4, r24
    15c4:	19 06       	cpc	r1, r25
    15c6:	19 f0       	breq	.+6      	; 0x15ce <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x8a>
    15c8:	14 f0       	brlt	.+4      	; 0x15ce <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x8a>
    15ca:	45 2c       	mov	r4, r5
    15cc:	41 94       	neg	r4
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3096
        
        if (useProgMem) {
    15ce:	33 20       	and	r3, r3
    15d0:	79 f0       	breq	.+30     	; 0x15f0 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0xac>
    15d2:	de 01       	movw	r26, r28
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3098
            // write the chunk of data as specified
            for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);
    15d8:	93 01       	movw	r18, r6
    15da:	2e 0d       	add	r18, r14
    15dc:	3f 1d       	adc	r19, r15
    15de:	84 15       	cp	r24, r4
    15e0:	50 f4       	brcc	.+20     	; 0x15f6 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0xb2>
    15e2:	f9 01       	movw	r30, r18
    15e4:	e8 0f       	add	r30, r24
    15e6:	f9 1f       	adc	r31, r25
    15e8:	e4 91       	lpm	r30, Z
    15ea:	ed 93       	st	X+, r30
    15ec:	01 96       	adiw	r24, 0x01	; 1
    15ee:	f7 cf       	rjmp	.-18     	; 0x15de <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x9a>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3101
        } else {
            // write the chunk of data as specified
            progBuffer = (uint8_t *)data + i;
    15f0:	e3 01       	movw	r28, r6
    15f2:	ce 0d       	add	r28, r14
    15f4:	df 1d       	adc	r29, r15
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3104
        }

        I2Cdev::writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer);
    15f6:	9e 01       	movw	r18, r28
    15f8:	44 2d       	mov	r20, r4
    15fa:	6f e6       	ldi	r22, 0x6F	; 111
    15fc:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1600:	0e 94 0c 09 	call	0x1218	; 0x1218 <I2Cdev::writeBytes(unsigned char, unsigned char, unsigned char, unsigned char*)>
    1604:	84 2c       	mov	r8, r4
    1606:	91 2c       	mov	r9, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3107

        // verify data if needed
        if (verify && verifyBuffer) {
    1608:	c1 14       	cp	r12, r1
    160a:	d1 04       	cpc	r13, r1
    160c:	d1 f1       	breq	.+116    	; 0x1682 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x13e>
setMemoryBank():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3024
}

// BANK_SEL register

void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
    bank &= 0x1F;
    160e:	42 2d       	mov	r20, r2
    1610:	4f 71       	andi	r20, 0x1F	; 31
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3027
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
    1612:	6d e6       	ldi	r22, 0x6D	; 109
    1614:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1618:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setMemoryStartAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3033
}

// MEM_START_ADDR register

void MPU6050::setMemoryStartAddress(uint8_t address) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
    161c:	45 2d       	mov	r20, r5
    161e:	6e e6       	ldi	r22, 0x6E	; 110
    1620:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1624:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
_ZN7MPU605016writeMemoryBlockEPKhjhhbb.constprop.80():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3110

        // verify data if needed
        if (verify && verifyBuffer) {
            setMemoryBank(bank);
            setMemoryStartAddress(address);
            I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);
    1628:	08 ee       	ldi	r16, 0xE8	; 232
    162a:	13 e0       	ldi	r17, 0x03	; 3
    162c:	96 01       	movw	r18, r12
    162e:	44 2d       	mov	r20, r4
    1630:	6f e6       	ldi	r22, 0x6F	; 111
    1632:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1636:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3111
            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {
    163a:	a4 01       	movw	r20, r8
    163c:	b6 01       	movw	r22, r12
    163e:	ce 01       	movw	r24, r28
    1640:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <memcmp>
    1644:	89 2b       	or	r24, r25
    1646:	e9 f0       	breq	.+58     	; 0x1682 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x13e>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3129
                    Serial.print(" 0x");
                    if (verifyBuffer[i + j] < 16) Serial.print("0");
                    Serial.print(verifyBuffer[i + j], HEX);
                }
                Serial.print("\n");*/
                free(verifyBuffer);
    1648:	c6 01       	movw	r24, r12
    164a:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <free>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3130
                if (useProgMem) free(progBuffer);
    164e:	33 20       	and	r3, r3
    1650:	21 f0       	breq	.+8      	; 0x165a <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x116>
    1652:	ce 01       	movw	r24, r28
    1654:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <free>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3131
                return false; // uh oh.
    1658:	31 2c       	mov	r3, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3151
        }
    }
    if (verify) free(verifyBuffer);
    if (useProgMem) free(progBuffer);
    return true;
}
    165a:	83 2d       	mov	r24, r3
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	ff 90       	pop	r15
    1666:	ef 90       	pop	r14
    1668:	df 90       	pop	r13
    166a:	cf 90       	pop	r12
    166c:	bf 90       	pop	r11
    166e:	af 90       	pop	r10
    1670:	9f 90       	pop	r9
    1672:	8f 90       	pop	r8
    1674:	7f 90       	pop	r7
    1676:	6f 90       	pop	r6
    1678:	5f 90       	pop	r5
    167a:	4f 90       	pop	r4
    167c:	3f 90       	pop	r3
    167e:	2f 90       	pop	r2
    1680:	08 95       	ret
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3136
                return false; // uh oh.
            }
        }

        // increase byte index by [chunkSize]
        i += chunkSize;
    1682:	e8 0c       	add	r14, r8
    1684:	f9 1c       	adc	r15, r9
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3142

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
    1686:	ea 14       	cp	r14, r10
    1688:	fb 04       	cpc	r15, r11
    168a:	a8 f4       	brcc	.+42     	; 0x16b6 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x172>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3139

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;
    168c:	54 0c       	add	r5, r4
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3143

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
            if (address == 0) bank++;
    168e:	09 f4       	brne	.+2      	; 0x1692 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x14e>
    1690:	23 94       	inc	r2
setMemoryBank():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3024
}

// BANK_SEL register

void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
    bank &= 0x1F;
    1692:	42 2d       	mov	r20, r2
    1694:	4f 71       	andi	r20, 0x1F	; 31
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3027
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
    1696:	6d e6       	ldi	r22, 0x6D	; 109
    1698:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    169c:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setMemoryStartAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3033
}

// MEM_START_ADDR register

void MPU6050::setMemoryStartAddress(uint8_t address) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
    16a0:	45 2d       	mov	r20, r5
    16a2:	6e e6       	ldi	r22, 0x6E	; 110
    16a4:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    16a8:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
    16ac:	7d cf       	rjmp	.-262    	; 0x15a8 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x64>
_ZN7MPU605016writeMemoryBlockEPKhjhhbb.constprop.80():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3149
            setMemoryBank(bank);
            setMemoryStartAddress(address);
        }
    }
    if (verify) free(verifyBuffer);
    if (useProgMem) free(progBuffer);
    16ae:	ce 01       	movw	r24, r28
    16b0:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <free>
    16b4:	d2 cf       	rjmp	.-92     	; 0x165a <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x116>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3148
            if (address == 0) bank++;
            setMemoryBank(bank);
            setMemoryStartAddress(address);
        }
    }
    if (verify) free(verifyBuffer);
    16b6:	c6 01       	movw	r24, r12
    16b8:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <free>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3149
    if (useProgMem) free(progBuffer);
    16bc:	31 10       	cpse	r3, r1
    16be:	f7 cf       	rjmp	.-18     	; 0x16ae <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x16a>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3150
    return true;
    16c0:	33 24       	eor	r3, r3
    16c2:	33 94       	inc	r3
    16c4:	ca cf       	rjmp	.-108    	; 0x165a <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]+0x116>

000016c6 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]>:
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3287
	kP *= x;
	kI *= x;
	PID( 0x3B, kP, kI,  Loops);
}

void MPU6050::PID(uint8_t ReadAddress, float kP,float kI, uint8_t Loops){
    16c6:	2f 92       	push	r2
    16c8:	3f 92       	push	r3
    16ca:	4f 92       	push	r4
    16cc:	5f 92       	push	r5
    16ce:	6f 92       	push	r6
    16d0:	7f 92       	push	r7
    16d2:	8f 92       	push	r8
    16d4:	9f 92       	push	r9
    16d6:	af 92       	push	r10
    16d8:	bf 92       	push	r11
    16da:	cf 92       	push	r12
    16dc:	df 92       	push	r13
    16de:	ef 92       	push	r14
    16e0:	ff 92       	push	r15
    16e2:	0f 93       	push	r16
    16e4:	1f 93       	push	r17
    16e6:	cf 93       	push	r28
    16e8:	df 93       	push	r29
    16ea:	cd b7       	in	r28, 0x3d	; 61
    16ec:	de b7       	in	r29, 0x3e	; 62
    16ee:	e1 97       	sbiw	r28, 0x31	; 49
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	de bf       	out	0x3e, r29	; 62
    16f4:	8d 8f       	std	Y+29, r24	; 0x1d
    16f6:	2a 01       	movw	r4, r20
    16f8:	3b 01       	movw	r6, r22
    16fa:	68 01       	movw	r12, r16
    16fc:	79 01       	movw	r14, r18
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3288
	uint8_t SaveAddress = (ReadAddress == 0x3B)?((getDeviceID() < 0x38 )? 0x06:0x77):0x13;
    16fe:	8b 33       	cpi	r24, 0x3B	; 59
    1700:	09 f0       	breq	.+2      	; 0x1704 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x3e>
    1702:	d3 c1       	rjmp	.+934    	; 0x1aaa <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x3e4>
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return readBytes(devAddr, regAddr, 1, data, timeout);
    1704:	08 ee       	ldi	r16, 0xE8	; 232
    1706:	13 e0       	ldi	r17, 0x03	; 3
    1708:	9e 01       	movw	r18, r28
    170a:	2f 5f       	subi	r18, 0xFF	; 255
    170c:	3f 4f       	sbci	r19, 0xFF	; 255
    170e:	41 e0       	ldi	r20, 0x01	; 1
    1710:	65 e7       	ldi	r22, 0x75	; 117
    1712:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1716:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
readBits():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:146
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    uint8_t count, b;
    if ((count = readByte(devAddr, regAddr, &b, timeout)) != 0) {
    171a:	88 23       	and	r24, r24
    171c:	39 f0       	breq	.+14     	; 0x172c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x66>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:148
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        b &= mask;
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	8e 77       	andi	r24, 0x7E	; 126
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:149
        b >>= (bitStart - length + 1);
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	95 95       	asr	r25
    1726:	87 95       	ror	r24
    1728:	80 93 e6 39 	sts	0x39E6, r24	; 0x8039e6 <mpu+0x1>
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3288
    172c:	80 91 e6 39 	lds	r24, 0x39E6	; 0x8039e6 <mpu+0x1>
    1730:	88 33       	cpi	r24, 0x38	; 56
    1732:	08 f4       	brcc	.+2      	; 0x1736 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x70>
    1734:	bf c1       	rjmp	.+894    	; 0x1ab4 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x3ee>
    1736:	27 e7       	ldi	r18, 0x77	; 119
    1738:	2f 8b       	std	Y+23, r18	; 0x17
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3293

	int16_t  Data;
	float Reading;
	int16_t BitZero[3];
	uint8_t shift =(SaveAddress == 0x77)?3:2;
    173a:	33 e0       	ldi	r19, 0x03	; 3
    173c:	38 8f       	std	Y+24, r19	; 0x18
write():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.h:172
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    173e:	6e e3       	ldi	r22, 0x3E	; 62
    1740:	80 ef       	ldi	r24, 0xF0	; 240
    1742:	98 e3       	ldi	r25, 0x38	; 56
    1744:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <UartClass::write(unsigned char)>
    1748:	de 01       	movw	r26, r28
    174a:	1d 96       	adiw	r26, 0x0d	; 13
    174c:	ad 8b       	std	Y+21, r26	; 0x15
    174e:	be 8b       	std	Y+22, r27	; 0x16
    1750:	fe 01       	movw	r30, r28
    1752:	31 96       	adiw	r30, 0x01	; 1
    1754:	1f 01       	movw	r2, r30
    1756:	5d 01       	movw	r10, r26
    1758:	9f 88       	ldd	r9, Y+23	; 0x17
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3299
	float Error, PTerm, ITerm[3];
	int16_t eSample;
	uint32_t eSum ;
	Serial.write('>');
	for (int i = 0; i < 3; i++) {
		I2Cdev::readWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data); // reads 1 or more 16 bit integers (Word)
    175a:	28 ee       	ldi	r18, 0xE8	; 232
    175c:	33 e0       	ldi	r19, 0x03	; 3
    175e:	ae 01       	movw	r20, r28
    1760:	4d 5e       	subi	r20, 0xED	; 237
    1762:	5f 4f       	sbci	r21, 0xFF	; 255
    1764:	69 2d       	mov	r22, r9
    1766:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    176a:	0e 94 6e 08 	call	0x10dc	; 0x10dc <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3300
		Reading = Data;
    176e:	0b 89       	ldd	r16, Y+19	; 0x13
    1770:	1c 89       	ldd	r17, Y+20	; 0x14
    1772:	b8 01       	movw	r22, r16
    1774:	01 2e       	mov	r0, r17
    1776:	00 0c       	add	r0, r0
    1778:	88 0b       	sbc	r24, r24
    177a:	99 0b       	sbc	r25, r25
    177c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3301
		if(SaveAddress != 0x13){
    1780:	3f 89       	ldd	r19, Y+23	; 0x17
    1782:	33 31       	cpi	r19, 0x13	; 19
    1784:	09 f4       	brne	.+2      	; 0x1788 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0xc2>
    1786:	9b c1       	rjmp	.+822    	; 0x1abe <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x3f8>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3302
			BitZero[i] = Data & 1;										 // Capture Bit Zero to properly handle Accelerometer calibration
    1788:	01 70       	andi	r16, 0x01	; 1
    178a:	11 27       	eor	r17, r17
    178c:	d5 01       	movw	r26, r10
    178e:	0d 93       	st	X+, r16
    1790:	1c 93       	st	X, r17
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3303
			ITerm[i] = ((float)Reading) * 8;
    1792:	20 e0       	ldi	r18, 0x00	; 0
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	40 e0       	ldi	r20, 0x00	; 0
    1798:	51 e4       	ldi	r21, 0x41	; 65
    179a:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    179e:	f1 01       	movw	r30, r2
    17a0:	60 83       	st	Z, r22
    17a2:	71 83       	std	Z+1, r23	; 0x01
    17a4:	82 83       	std	Z+2, r24	; 0x02
    17a6:	93 83       	std	Z+3, r25	; 0x03
    17a8:	b8 8d       	ldd	r27, Y+24	; 0x18
    17aa:	9b 0e       	add	r9, r27
    17ac:	e2 e0       	ldi	r30, 0x02	; 2
    17ae:	ae 0e       	add	r10, r30
    17b0:	b1 1c       	adc	r11, r1
    17b2:	f4 e0       	ldi	r31, 0x04	; 4
    17b4:	2f 0e       	add	r2, r31
    17b6:	31 1c       	adc	r3, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3298
	uint8_t shift =(SaveAddress == 0x77)?3:2;
	float Error, PTerm, ITerm[3];
	int16_t eSample;
	uint32_t eSum ;
	Serial.write('>');
	for (int i = 0; i < 3; i++) {
    17b8:	2d 89       	ldd	r18, Y+21	; 0x15
    17ba:	3e 89       	ldd	r19, Y+22	; 0x16
    17bc:	22 15       	cp	r18, r2
    17be:	33 05       	cpc	r19, r3
    17c0:	61 f6       	brne	.-104    	; 0x175a <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x94>
    17c2:	3d 8d       	ldd	r19, Y+29	; 0x1d
    17c4:	3b 33       	cpi	r19, 0x3B	; 59
    17c6:	09 f0       	breq	.+2      	; 0x17ca <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x104>
    17c8:	87 c1       	rjmp	.+782    	; 0x1ad8 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x412>
    17ca:	8d ec       	ldi	r24, 0xCD	; 205
    17cc:	9c ec       	ldi	r25, 0xCC	; 204
    17ce:	ac e4       	ldi	r26, 0x4C	; 76
    17d0:	bd e3       	ldi	r27, 0x3D	; 61
    17d2:	8a a7       	std	Y+42, r24	; 0x2a
    17d4:	9b a7       	std	Y+43, r25	; 0x2b
    17d6:	ac a7       	std	Y+44, r26	; 0x2c
    17d8:	bd a7       	std	Y+45, r27	; 0x2d
    17da:	46 e0       	ldi	r20, 0x06	; 6
    17dc:	50 e0       	ldi	r21, 0x00	; 0
    17de:	4c a3       	std	Y+36, r20	; 0x24
    17e0:	5d a3       	std	Y+37, r21	; 0x25
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3309
			} else {
			ITerm[i] = Reading * 4;
		}
	}
	for (int L = 0; L < Loops; L++) {
		eSample = 0;
    17e2:	1a a2       	std	Y+34, r1	; 0x22
    17e4:	1b a2       	std	Y+35, r1	; 0x23
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3310
		for (int c = 0; c < 100; c++) {// 100 PI Calculations
    17e6:	10 e0       	ldi	r17, 0x00	; 0
    17e8:	00 e0       	ldi	r16, 0x00	; 0
    17ea:	ce 01       	movw	r24, r28
    17ec:	01 96       	adiw	r24, 0x01	; 1
    17ee:	8b 8f       	std	Y+27, r24	; 0x1b
    17f0:	9c 8f       	std	Y+28, r25	; 0x1c
    17f2:	de 01       	movw	r26, r28
    17f4:	1d 96       	adiw	r26, 0x0d	; 13
    17f6:	a8 a3       	std	Y+32, r26	; 0x20
    17f8:	b9 a3       	std	Y+33, r27	; 0x21
    17fa:	bf 89       	ldd	r27, Y+23	; 0x17
    17fc:	be 8f       	std	Y+30, r27	; 0x1e
    17fe:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1800:	ef 8f       	std	Y+31, r30	; 0x1f
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3311
			eSum = 0;
    1802:	81 2c       	mov	r8, r1
    1804:	91 2c       	mov	r9, r1
    1806:	54 01       	movw	r10, r8
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3312
			for (int i = 0; i < 3; i++) {
    1808:	19 8e       	std	Y+25, r1	; 0x19
    180a:	1a 8e       	std	Y+26, r1	; 0x1a
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3313
				I2Cdev::readWords(devAddr, ReadAddress + (i * 2), 1, (uint16_t *)&Data); // reads 1 or more 16 bit integers (Word)
    180c:	28 ee       	ldi	r18, 0xE8	; 232
    180e:	33 e0       	ldi	r19, 0x03	; 3
    1810:	ae 01       	movw	r20, r28
    1812:	4d 5e       	subi	r20, 0xED	; 237
    1814:	5f 4f       	sbci	r21, 0xFF	; 255
    1816:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1818:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    181c:	0e 94 6e 08 	call	0x10dc	; 0x10dc <I2Cdev::readWords(unsigned char, unsigned char, unsigned char, unsigned int*, unsigned int) [clone .constprop.115]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3314
				Reading = Data;
    1820:	6b 89       	ldd	r22, Y+19	; 0x13
    1822:	7c 89       	ldd	r23, Y+20	; 0x14
    1824:	07 2e       	mov	r0, r23
    1826:	00 0c       	add	r0, r0
    1828:	88 0b       	sbc	r24, r24
    182a:	99 0b       	sbc	r25, r25
    182c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3315
				if ((ReadAddress == 0x3B)&&(i == 2)) Reading -= 16384;	//remove Gravity
    1830:	fd 8d       	ldd	r31, Y+29	; 0x1d
    1832:	fb 33       	cpi	r31, 0x3B	; 59
    1834:	59 f4       	brne	.+22     	; 0x184c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x186>
    1836:	29 8d       	ldd	r18, Y+25	; 0x19
    1838:	3a 8d       	ldd	r19, Y+26	; 0x1a
    183a:	22 30       	cpi	r18, 0x02	; 2
    183c:	31 05       	cpc	r19, r1
    183e:	31 f4       	brne	.+12     	; 0x184c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x186>
    1840:	20 e0       	ldi	r18, 0x00	; 0
    1842:	30 e0       	ldi	r19, 0x00	; 0
    1844:	40 e8       	ldi	r20, 0x80	; 128
    1846:	56 e4       	ldi	r21, 0x46	; 70
    1848:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3316
				Error = -Reading;
    184c:	9b 01       	movw	r18, r22
    184e:	ac 01       	movw	r20, r24
    1850:	50 58       	subi	r21, 0x80	; 128
    1852:	2e a3       	std	Y+38, r18	; 0x26
    1854:	3f a3       	std	Y+39, r19	; 0x27
    1856:	48 a7       	std	Y+40, r20	; 0x28
    1858:	59 a7       	std	Y+41, r21	; 0x29
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3317
				eSum += abs(Reading);
    185a:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    185e:	9b 01       	movw	r18, r22
    1860:	77 ff       	sbrs	r23, 7
    1862:	04 c0       	rjmp	.+8      	; 0x186c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x1a6>
    1864:	22 27       	eor	r18, r18
    1866:	33 27       	eor	r19, r19
    1868:	26 1b       	sub	r18, r22
    186a:	37 0b       	sbc	r19, r23
    186c:	c9 01       	movw	r24, r18
    186e:	33 0f       	add	r19, r19
    1870:	aa 0b       	sbc	r26, r26
    1872:	bb 0b       	sbc	r27, r27
    1874:	88 0e       	add	r8, r24
    1876:	99 1e       	adc	r9, r25
    1878:	aa 1e       	adc	r10, r26
    187a:	bb 1e       	adc	r11, r27
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3319
				PTerm = kP * Error;
				ITerm[i] += (Error * 0.001) * kI;				// Integral term 1000 Calculations a second = 0.001
    187c:	2f e6       	ldi	r18, 0x6F	; 111
    187e:	32 e1       	ldi	r19, 0x12	; 18
    1880:	43 e8       	ldi	r20, 0x83	; 131
    1882:	5a e3       	ldi	r21, 0x3A	; 58
    1884:	6e a1       	ldd	r22, Y+38	; 0x26
    1886:	7f a1       	ldd	r23, Y+39	; 0x27
    1888:	88 a5       	ldd	r24, Y+40	; 0x28
    188a:	99 a5       	ldd	r25, Y+41	; 0x29
    188c:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1890:	a7 01       	movw	r20, r14
    1892:	96 01       	movw	r18, r12
    1894:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1898:	ab 8d       	ldd	r26, Y+27	; 0x1b
    189a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    189c:	2d 91       	ld	r18, X+
    189e:	3d 91       	ld	r19, X+
    18a0:	4d 91       	ld	r20, X+
    18a2:	5c 91       	ld	r21, X
    18a4:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    18a8:	6e a7       	std	Y+46, r22	; 0x2e
    18aa:	7f a7       	std	Y+47, r23	; 0x2f
    18ac:	88 ab       	std	Y+48, r24	; 0x30
    18ae:	99 ab       	std	Y+49, r25	; 0x31
    18b0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    18b2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    18b4:	60 83       	st	Z, r22
    18b6:	71 83       	std	Z+1, r23	; 0x01
    18b8:	82 83       	std	Z+2, r24	; 0x02
    18ba:	93 83       	std	Z+3, r25	; 0x03
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3318
				I2Cdev::readWords(devAddr, ReadAddress + (i * 2), 1, (uint16_t *)&Data); // reads 1 or more 16 bit integers (Word)
				Reading = Data;
				if ((ReadAddress == 0x3B)&&(i == 2)) Reading -= 16384;	//remove Gravity
				Error = -Reading;
				eSum += abs(Reading);
				PTerm = kP * Error;
    18bc:	a3 01       	movw	r20, r6
    18be:	92 01       	movw	r18, r4
    18c0:	6e a1       	ldd	r22, Y+38	; 0x26
    18c2:	7f a1       	ldd	r23, Y+39	; 0x27
    18c4:	88 a5       	ldd	r24, Y+40	; 0x28
    18c6:	99 a5       	ldd	r25, Y+41	; 0x29
    18c8:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    18cc:	2e a5       	ldd	r18, Y+46	; 0x2e
    18ce:	3f a5       	ldd	r19, Y+47	; 0x2f
    18d0:	48 a9       	ldd	r20, Y+48	; 0x30
    18d2:	59 a9       	ldd	r21, Y+49	; 0x31
    18d4:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3320
				ITerm[i] += (Error * 0.001) * kI;				// Integral term 1000 Calculations a second = 0.001
				if(SaveAddress != 0x13){
    18d8:	ff 89       	ldd	r31, Y+23	; 0x17
    18da:	f3 31       	cpi	r31, 0x13	; 19
    18dc:	09 f4       	brne	.+2      	; 0x18e0 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x21a>
    18de:	05 c1       	rjmp	.+522    	; 0x1aea <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x424>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3321
					Data = round((PTerm + ITerm[i] ) / 8);		//Compute PID Output
    18e0:	20 e0       	ldi	r18, 0x00	; 0
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	40 e0       	ldi	r20, 0x00	; 0
    18e6:	5e e3       	ldi	r21, 0x3E	; 62
    18e8:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    18ec:	0e 94 21 1b 	call	0x3642	; 0x3642 <round>
    18f0:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3322
					Data = ((Data)&0xFFFE) |BitZero[i];			// Insert Bit0 Saved at beginning
    18f4:	6e 7f       	andi	r22, 0xFE	; 254
    18f6:	a8 a1       	ldd	r26, Y+32	; 0x20
    18f8:	b9 a1       	ldd	r27, Y+33	; 0x21
    18fa:	8d 91       	ld	r24, X+
    18fc:	9c 91       	ld	r25, X
    18fe:	68 2b       	or	r22, r24
    1900:	79 2b       	or	r23, r25
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3323
				} else Data = round((PTerm + ITerm[i] ) / 4);	//Compute PID Output
    1902:	6b 8b       	std	Y+19, r22	; 0x13
    1904:	7c 8b       	std	Y+20, r23	; 0x14
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3324
				I2Cdev::writeWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data);
    1906:	ae 01       	movw	r20, r28
    1908:	4d 5e       	subi	r20, 0xED	; 237
    190a:	5f 4f       	sbci	r21, 0xFF	; 255
    190c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    190e:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1912:	0e 94 4e 08 	call	0x109c	; 0x109c <I2Cdev::writeWords(unsigned char, unsigned char, unsigned char, unsigned int*) [clone .constprop.120]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3312
	}
	for (int L = 0; L < Loops; L++) {
		eSample = 0;
		for (int c = 0; c < 100; c++) {// 100 PI Calculations
			eSum = 0;
			for (int i = 0; i < 3; i++) {
    1916:	e9 8d       	ldd	r30, Y+25	; 0x19
    1918:	fa 8d       	ldd	r31, Y+26	; 0x1a
    191a:	31 96       	adiw	r30, 0x01	; 1
    191c:	e9 8f       	std	Y+25, r30	; 0x19
    191e:	fa 8f       	std	Y+26, r31	; 0x1a
    1920:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1922:	fe 5f       	subi	r31, 0xFE	; 254
    1924:	ff 8f       	std	Y+31, r31	; 0x1f
    1926:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1928:	38 8d       	ldd	r19, Y+24	; 0x18
    192a:	23 0f       	add	r18, r19
    192c:	2e 8f       	std	Y+30, r18	; 0x1e
    192e:	48 a1       	ldd	r20, Y+32	; 0x20
    1930:	59 a1       	ldd	r21, Y+33	; 0x21
    1932:	4e 5f       	subi	r20, 0xFE	; 254
    1934:	5f 4f       	sbci	r21, 0xFF	; 255
    1936:	48 a3       	std	Y+32, r20	; 0x20
    1938:	59 a3       	std	Y+33, r21	; 0x21
    193a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    193c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    193e:	04 96       	adiw	r24, 0x04	; 4
    1940:	8b 8f       	std	Y+27, r24	; 0x1b
    1942:	9c 8f       	std	Y+28, r25	; 0x1c
    1944:	a9 8d       	ldd	r26, Y+25	; 0x19
    1946:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1948:	13 97       	sbiw	r26, 0x03	; 3
    194a:	09 f0       	breq	.+2      	; 0x194e <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x288>
    194c:	5f cf       	rjmp	.-322    	; 0x180c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x146>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3326
					Data = round((PTerm + ITerm[i] ) / 8);		//Compute PID Output
					Data = ((Data)&0xFFFE) |BitZero[i];			// Insert Bit0 Saved at beginning
				} else Data = round((PTerm + ITerm[i] ) / 4);	//Compute PID Output
				I2Cdev::writeWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data);
			}
			if((c == 99) && eSum > 1000){						// Error is still to great to continue 
    194e:	03 36       	cpi	r16, 0x63	; 99
    1950:	11 05       	cpc	r17, r1
    1952:	71 f4       	brne	.+28     	; 0x1970 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2aa>
    1954:	b9 ee       	ldi	r27, 0xE9	; 233
    1956:	8b 16       	cp	r8, r27
    1958:	b3 e0       	ldi	r27, 0x03	; 3
    195a:	9b 06       	cpc	r9, r27
    195c:	a1 04       	cpc	r10, r1
    195e:	b1 04       	cpc	r11, r1
    1960:	38 f0       	brcs	.+14     	; 0x1970 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2aa>
write():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.h:172
    1962:	6a e2       	ldi	r22, 0x2A	; 42
    1964:	80 ef       	ldi	r24, 0xF0	; 240
    1966:	98 e3       	ldi	r25, 0x38	; 56
    1968:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <UartClass::write(unsigned char)>
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3327
				c = 0;
    196c:	10 e0       	ldi	r17, 0x00	; 0
    196e:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3330
				Serial.write('*');
			}
			if((eSum * ((ReadAddress == 0x3B)?.05: 1)) < 5) eSample++;	// Successfully found offsets prepare to  advance
    1970:	c5 01       	movw	r24, r10
    1972:	b4 01       	movw	r22, r8
    1974:	0e 94 fd 19 	call	0x33fa	; 0x33fa <__floatunsisf>
    1978:	2a a5       	ldd	r18, Y+42	; 0x2a
    197a:	3b a5       	ldd	r19, Y+43	; 0x2b
    197c:	4c a5       	ldd	r20, Y+44	; 0x2c
    197e:	5d a5       	ldd	r21, Y+45	; 0x2d
    1980:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1984:	20 e0       	ldi	r18, 0x00	; 0
    1986:	30 e0       	ldi	r19, 0x00	; 0
    1988:	40 ea       	ldi	r20, 0xA0	; 160
    198a:	50 e4       	ldi	r21, 0x40	; 64
    198c:	0e 94 c2 19 	call	0x3384	; 0x3384 <__cmpsf2>
    1990:	87 ff       	sbrs	r24, 7
    1992:	05 c0       	rjmp	.+10     	; 0x199e <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2d8>
    1994:	ea a1       	ldd	r30, Y+34	; 0x22
    1996:	fb a1       	ldd	r31, Y+35	; 0x23
    1998:	31 96       	adiw	r30, 0x01	; 1
    199a:	ea a3       	std	Y+34, r30	; 0x22
    199c:	fb a3       	std	Y+35, r31	; 0x23
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3331
			if((eSum < 100) && (c > 10) && (eSample >= 10)) break;		// Advance to next Loop
    199e:	f4 e6       	ldi	r31, 0x64	; 100
    19a0:	8f 16       	cp	r8, r31
    19a2:	91 04       	cpc	r9, r1
    19a4:	a1 04       	cpc	r10, r1
    19a6:	b1 04       	cpc	r11, r1
    19a8:	08 f0       	brcs	.+2      	; 0x19ac <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2e6>
    19aa:	aa c0       	rjmp	.+340    	; 0x1b00 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x43a>
    19ac:	0b 30       	cpi	r16, 0x0B	; 11
    19ae:	11 05       	cpc	r17, r1
    19b0:	0c f4       	brge	.+2      	; 0x19b4 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2ee>
    19b2:	a6 c0       	rjmp	.+332    	; 0x1b00 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x43a>
    19b4:	2a a1       	ldd	r18, Y+34	; 0x22
    19b6:	3b a1       	ldd	r19, Y+35	; 0x23
    19b8:	2a 30       	cpi	r18, 0x0A	; 10
    19ba:	31 05       	cpc	r19, r1
    19bc:	0c f4       	brge	.+2      	; 0x19c0 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2fa>
    19be:	a0 c0       	rjmp	.+320    	; 0x1b00 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x43a>
write():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.h:172
    19c0:	6e e2       	ldi	r22, 0x2E	; 46
    19c2:	80 ef       	ldi	r24, 0xF0	; 240
    19c4:	98 e3       	ldi	r25, 0x38	; 56
    19c6:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <UartClass::write(unsigned char)>
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3335
			delay(1);
		}
		Serial.write('.');
		kP *= .75;
    19ca:	20 e0       	ldi	r18, 0x00	; 0
    19cc:	30 e0       	ldi	r19, 0x00	; 0
    19ce:	40 e4       	ldi	r20, 0x40	; 64
    19d0:	5f e3       	ldi	r21, 0x3F	; 63
    19d2:	c3 01       	movw	r24, r6
    19d4:	b2 01       	movw	r22, r4
    19d6:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    19da:	2b 01       	movw	r4, r22
    19dc:	3c 01       	movw	r6, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3336
		kI *= .75;
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	40 e4       	ldi	r20, 0x40	; 64
    19e4:	5f e3       	ldi	r21, 0x3F	; 63
    19e6:	c7 01       	movw	r24, r14
    19e8:	b6 01       	movw	r22, r12
    19ea:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    19ee:	6b 01       	movw	r12, r22
    19f0:	7c 01       	movw	r14, r24
    19f2:	ae 01       	movw	r20, r28
    19f4:	43 5f       	subi	r20, 0xF3	; 243
    19f6:	5f 4f       	sbci	r21, 0xFF	; 255
    19f8:	5a 01       	movw	r10, r20
    19fa:	9f 88       	ldd	r9, Y+23	; 0x17
    19fc:	8e 01       	movw	r16, r28
    19fe:	0f 5f       	subi	r16, 0xFF	; 255
    1a00:	1f 4f       	sbci	r17, 0xFF	; 255
    1a02:	d8 01       	movw	r26, r16
    1a04:	6d 91       	ld	r22, X+
    1a06:	7d 91       	ld	r23, X+
    1a08:	8d 91       	ld	r24, X+
    1a0a:	9d 91       	ld	r25, X+
    1a0c:	8d 01       	movw	r16, r26
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3338
		for (int i = 0; i < 3; i++){
			if(SaveAddress != 0x13) {
    1a0e:	bf 89       	ldd	r27, Y+23	; 0x17
    1a10:	b3 31       	cpi	r27, 0x13	; 19
    1a12:	09 f4       	brne	.+2      	; 0x1a16 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x350>
    1a14:	82 c0       	rjmp	.+260    	; 0x1b1a <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x454>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3339
				Data = round((ITerm[i] ) / 8);		//Compute PID Output
    1a16:	20 e0       	ldi	r18, 0x00	; 0
    1a18:	30 e0       	ldi	r19, 0x00	; 0
    1a1a:	40 e0       	ldi	r20, 0x00	; 0
    1a1c:	5e e3       	ldi	r21, 0x3E	; 62
    1a1e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1a22:	0e 94 21 1b 	call	0x3642	; 0x3642 <round>
    1a26:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3340
				Data = ((Data)&0xFFFE) |BitZero[i];	// Insert Bit0 Saved at beginning
    1a2a:	6e 7f       	andi	r22, 0xFE	; 254
    1a2c:	f5 01       	movw	r30, r10
    1a2e:	80 81       	ld	r24, Z
    1a30:	91 81       	ldd	r25, Z+1	; 0x01
    1a32:	68 2b       	or	r22, r24
    1a34:	79 2b       	or	r23, r25
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3341
			} else Data = round((ITerm[i]) / 4);
    1a36:	6b 8b       	std	Y+19, r22	; 0x13
    1a38:	7c 8b       	std	Y+20, r23	; 0x14
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3342
			I2Cdev::writeWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data);
    1a3a:	ae 01       	movw	r20, r28
    1a3c:	4d 5e       	subi	r20, 0xED	; 237
    1a3e:	5f 4f       	sbci	r21, 0xFF	; 255
    1a40:	69 2d       	mov	r22, r9
    1a42:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1a46:	0e 94 4e 08 	call	0x109c	; 0x109c <I2Cdev::writeWords(unsigned char, unsigned char, unsigned char, unsigned int*) [clone .constprop.120]>
    1a4a:	f8 8d       	ldd	r31, Y+24	; 0x18
    1a4c:	9f 0e       	add	r9, r31
    1a4e:	22 e0       	ldi	r18, 0x02	; 2
    1a50:	a2 0e       	add	r10, r18
    1a52:	b1 1c       	adc	r11, r1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3337
			delay(1);
		}
		Serial.write('.');
		kP *= .75;
		kI *= .75;
		for (int i = 0; i < 3; i++){
    1a54:	02 15       	cp	r16, r2
    1a56:	13 05       	cpc	r17, r3
    1a58:	a1 f6       	brne	.-88     	; 0x1a02 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x33c>
    1a5a:	4c a1       	ldd	r20, Y+36	; 0x24
    1a5c:	5d a1       	ldd	r21, Y+37	; 0x25
    1a5e:	41 50       	subi	r20, 0x01	; 1
    1a60:	51 09       	sbc	r21, r1
    1a62:	4c a3       	std	Y+36, r20	; 0x24
    1a64:	5d a3       	std	Y+37, r21	; 0x25
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3308
			ITerm[i] = ((float)Reading) * 8;
			} else {
			ITerm[i] = Reading * 4;
		}
	}
	for (int L = 0; L < Loops; L++) {
    1a66:	45 2b       	or	r20, r21
    1a68:	09 f0       	breq	.+2      	; 0x1a6c <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x3a6>
    1a6a:	bb ce       	rjmp	.-650    	; 0x17e2 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x11c>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3345
				Data = ((Data)&0xFFFE) |BitZero[i];	// Insert Bit0 Saved at beginning
			} else Data = round((ITerm[i]) / 4);
			I2Cdev::writeWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data);
		}
	}
	resetFIFO();
    1a6c:	0e 94 9b 0a 	call	0x1536	; 0x1536 <MPU6050::resetFIFO() [clone .constprop.96]>
resetDMP():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3018
}
void MPU6050::setDMPEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
}
void MPU6050::resetDMP() {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);
    1a70:	21 e0       	ldi	r18, 0x01	; 1
    1a72:	43 e0       	ldi	r20, 0x03	; 3
    1a74:	6a e6       	ldi	r22, 0x6A	; 106
    1a76:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    1a7a:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
_ZN7MPU60503PIDEhffh.constprop.76():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3347
			I2Cdev::writeWords(devAddr, SaveAddress + (i * shift), 1, (uint16_t *)&Data);
		}
	}
	resetFIFO();
	resetDMP();
}
    1a7e:	e1 96       	adiw	r28, 0x31	; 49
    1a80:	cd bf       	out	0x3d, r28	; 61
    1a82:	de bf       	out	0x3e, r29	; 62
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
    1a88:	1f 91       	pop	r17
    1a8a:	0f 91       	pop	r16
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	df 90       	pop	r13
    1a92:	cf 90       	pop	r12
    1a94:	bf 90       	pop	r11
    1a96:	af 90       	pop	r10
    1a98:	9f 90       	pop	r9
    1a9a:	8f 90       	pop	r8
    1a9c:	7f 90       	pop	r7
    1a9e:	6f 90       	pop	r6
    1aa0:	5f 90       	pop	r5
    1aa2:	4f 90       	pop	r4
    1aa4:	3f 90       	pop	r3
    1aa6:	2f 90       	pop	r2
    1aa8:	08 95       	ret
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3288
	kI *= x;
	PID( 0x3B, kP, kI,  Loops);
}

void MPU6050::PID(uint8_t ReadAddress, float kP,float kI, uint8_t Loops){
	uint8_t SaveAddress = (ReadAddress == 0x3B)?((getDeviceID() < 0x38 )? 0x06:0x77):0x13;
    1aaa:	43 e1       	ldi	r20, 0x13	; 19
    1aac:	4f 8b       	std	Y+23, r20	; 0x17
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3293

	int16_t  Data;
	float Reading;
	int16_t BitZero[3];
	uint8_t shift =(SaveAddress == 0x77)?3:2;
    1aae:	52 e0       	ldi	r21, 0x02	; 2
    1ab0:	58 8f       	std	Y+24, r21	; 0x18
    1ab2:	45 ce       	rjmp	.-886    	; 0x173e <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x78>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3288
	kI *= x;
	PID( 0x3B, kP, kI,  Loops);
}

void MPU6050::PID(uint8_t ReadAddress, float kP,float kI, uint8_t Loops){
	uint8_t SaveAddress = (ReadAddress == 0x3B)?((getDeviceID() < 0x38 )? 0x06:0x77):0x13;
    1ab4:	86 e0       	ldi	r24, 0x06	; 6
    1ab6:	8f 8b       	std	Y+23, r24	; 0x17
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3293

	int16_t  Data;
	float Reading;
	int16_t BitZero[3];
	uint8_t shift =(SaveAddress == 0x77)?3:2;
    1ab8:	92 e0       	ldi	r25, 0x02	; 2
    1aba:	98 8f       	std	Y+24, r25	; 0x18
    1abc:	40 ce       	rjmp	.-896    	; 0x173e <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x78>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3305
		Reading = Data;
		if(SaveAddress != 0x13){
			BitZero[i] = Data & 1;										 // Capture Bit Zero to properly handle Accelerometer calibration
			ITerm[i] = ((float)Reading) * 8;
			} else {
			ITerm[i] = Reading * 4;
    1abe:	20 e0       	ldi	r18, 0x00	; 0
    1ac0:	30 e0       	ldi	r19, 0x00	; 0
    1ac2:	40 e8       	ldi	r20, 0x80	; 128
    1ac4:	50 e4       	ldi	r21, 0x40	; 64
    1ac6:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1aca:	d1 01       	movw	r26, r2
    1acc:	6d 93       	st	X+, r22
    1ace:	7d 93       	st	X+, r23
    1ad0:	8d 93       	st	X+, r24
    1ad2:	9c 93       	st	X, r25
    1ad4:	13 97       	sbiw	r26, 0x03	; 3
    1ad6:	68 ce       	rjmp	.-816    	; 0x17a8 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0xe2>
    1ad8:	20 e0       	ldi	r18, 0x00	; 0
    1ada:	30 e0       	ldi	r19, 0x00	; 0
    1adc:	40 e8       	ldi	r20, 0x80	; 128
    1ade:	5f e3       	ldi	r21, 0x3F	; 63
    1ae0:	2a a7       	std	Y+42, r18	; 0x2a
    1ae2:	3b a7       	std	Y+43, r19	; 0x2b
    1ae4:	4c a7       	std	Y+44, r20	; 0x2c
    1ae6:	5d a7       	std	Y+45, r21	; 0x2d
    1ae8:	78 ce       	rjmp	.-784    	; 0x17da <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x114>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3323
				PTerm = kP * Error;
				ITerm[i] += (Error * 0.001) * kI;				// Integral term 1000 Calculations a second = 0.001
				if(SaveAddress != 0x13){
					Data = round((PTerm + ITerm[i] ) / 8);		//Compute PID Output
					Data = ((Data)&0xFFFE) |BitZero[i];			// Insert Bit0 Saved at beginning
				} else Data = round((PTerm + ITerm[i] ) / 4);	//Compute PID Output
    1aea:	20 e0       	ldi	r18, 0x00	; 0
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	40 e8       	ldi	r20, 0x80	; 128
    1af0:	5e e3       	ldi	r21, 0x3E	; 62
    1af2:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1af6:	0e 94 21 1b 	call	0x3642	; 0x3642 <round>
    1afa:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    1afe:	01 cf       	rjmp	.-510    	; 0x1902 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x23c>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3332
				c = 0;
				Serial.write('*');
			}
			if((eSum * ((ReadAddress == 0x3B)?.05: 1)) < 5) eSample++;	// Successfully found offsets prepare to  advance
			if((eSum < 100) && (c > 10) && (eSample >= 10)) break;		// Advance to next Loop
			delay(1);
    1b00:	61 e0       	ldi	r22, 0x01	; 1
    1b02:	70 e0       	ldi	r23, 0x00	; 0
    1b04:	80 e0       	ldi	r24, 0x00	; 0
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <delay>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3310
			ITerm[i] = Reading * 4;
		}
	}
	for (int L = 0; L < Loops; L++) {
		eSample = 0;
		for (int c = 0; c < 100; c++) {// 100 PI Calculations
    1b0c:	0f 5f       	subi	r16, 0xFF	; 255
    1b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b10:	04 36       	cpi	r16, 0x64	; 100
    1b12:	11 05       	cpc	r17, r1
    1b14:	09 f0       	breq	.+2      	; 0x1b18 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x452>
    1b16:	69 ce       	rjmp	.-814    	; 0x17ea <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x124>
    1b18:	53 cf       	rjmp	.-346    	; 0x19c0 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x2fa>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3341
		kI *= .75;
		for (int i = 0; i < 3; i++){
			if(SaveAddress != 0x13) {
				Data = round((ITerm[i] ) / 8);		//Compute PID Output
				Data = ((Data)&0xFFFE) |BitZero[i];	// Insert Bit0 Saved at beginning
			} else Data = round((ITerm[i]) / 4);
    1b1a:	20 e0       	ldi	r18, 0x00	; 0
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	40 e8       	ldi	r20, 0x80	; 128
    1b20:	5e e3       	ldi	r21, 0x3E	; 62
    1b22:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    1b26:	0e 94 21 1b 	call	0x3642	; 0x3642 <round>
    1b2a:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    1b2e:	83 cf       	rjmp	.-250    	; 0x1a36 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]+0x370>

00001b30 <RF24::csn(bool) [clone .constprop.69]>:
_ZN4RF243csnEb.constprop.69():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:24
}
#endif

/****************************************************************************/

void RF24::csn(bool mode)
    1b30:	68 2f       	mov	r22, r24
setBitOrder():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:322
void SPIClass::setBitOrder(uint8_t order)
{
  if (order == LSBFIRST)
    SPI0.CTRLA |=  (SPI_DORD_bm);
  else
    SPI0.CTRLA &= ~(SPI_DORD_bm);
    1b32:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1b36:	8f 7b       	andi	r24, 0xBF	; 191
    1b38:	80 93 20 08 	sts	0x0820, r24	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
setDataMode():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:327
}

void SPIClass::setDataMode(uint8_t mode)
{
  SPI0.CTRLB = ((SPI0.CTRLB & (~SPI_MODE_gm)) | mode );
    1b3c:	80 91 21 08 	lds	r24, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1b40:	8c 7f       	andi	r24, 0xFC	; 252
    1b42:	80 93 21 08 	sts	0x0821, r24	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
setClockDivider():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:332
}

void SPIClass::setClockDivider(uint8_t div)
{
  SPI0.CTRLA = ((SPI0.CTRLA &
    1b46:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:334
                  ((~SPI_PRESC_gm) | (~SPI_CLK2X_bm) ))  // mask out values
                  | div);                           // write value
    1b4a:	80 61       	ori	r24, 0x10	; 16
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:332
  SPI0.CTRLB = ((SPI0.CTRLB & (~SPI_MODE_gm)) | mode );
}

void SPIClass::setClockDivider(uint8_t div)
{
  SPI0.CTRLA = ((SPI0.CTRLA &
    1b4c:	80 93 20 08 	sts	0x0820, r24	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
_ZN4RF243csnEb.constprop.69():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:77
    if(!mode)
      _SPI.chipSelect(csn_pin);
    #endif // defined(RF24_RPi)

    #if !defined(RF24_LINUX)
    digitalWrite(csn_pin, mode);
    1b50:	80 91 fa 39 	lds	r24, 0x39FA	; 0x8039fa <radio+0x2>
digitalWrite():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:147
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	/* Get bit mask for pin */
	uint8_t bit_mask = digitalPinToBitMask(pin);
    1b54:	8c 30       	cpi	r24, 0x0C	; 12
    1b56:	10 f4       	brcc	.+4      	; 0x1b5c <RF24::csn(bool) [clone .constprop.69]+0x2c>
    1b58:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
_ZN4RF243csnEb.constprop.69():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:78
    delayMicroseconds(csDelay);
    1b5c:	20 91 0c 3a 	lds	r18, 0x3A0C	; 0x803a0c <radio+0x14>
    1b60:	30 91 0d 3a 	lds	r19, 0x3A0D	; 0x803a0d <radio+0x15>
delayMicroseconds():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:369
#elif F_CPU >= 10000000L
  // for 10MHz (20MHz/2)

  // for a 1 microsecond delay, simply return.  the overhead
  // of the function call takes 14 (16) cycles, which is 1.5us
  if (us <= 1) return; //  = 3 cycles, (4 when true)
    1b64:	22 30       	cpi	r18, 0x02	; 2
    1b66:	31 05       	cpc	r19, r1
    1b68:	50 f0       	brcs	.+20     	; 0x1b7e <RF24::csn(bool) [clone .constprop.69]+0x4e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:374

  // the following loop takes 2/5 of a microsecond (4 cycles)
  // per iteration, so execute it 2.5 times for each microsecond of
  // delay requested.
  us = (us << 1) + (us>>1); // x2.5 us, = 5 cycles
    1b6a:	c9 01       	movw	r24, r18
    1b6c:	88 0f       	add	r24, r24
    1b6e:	99 1f       	adc	r25, r25
    1b70:	36 95       	lsr	r19
    1b72:	27 95       	ror	r18
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:379

  // account for the time taken in the preceding commands.
  // we just burned 20 (22) cycles above, remove 5, (5*4=20)
  // us is at least 6 so we can subtract 5
  us -= 5; //2 cycles
    1b78:	05 97       	sbiw	r24, 0x05	; 5
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:441
#endif



  // busy wait
  __asm__ __volatile__ (
    1b7a:	01 97       	sbiw	r24, 0x01	; 1
    1b7c:	f1 f7       	brne	.-4      	; 0x1b7a <RF24::csn(bool) [clone .constprop.69]+0x4a>
_ZN4RF243csnEb.constprop.69():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:80
    #endif // !defined(RF24_LINUX)
}
    1b7e:	08 95       	ret

00001b80 <RF24::beginTransaction() [clone .constprop.67]>:
_ZN4RF2416beginTransactionEv.constprop.67():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:99
inline void RF24::beginTransaction()
{
    #if defined(RF24_SPI_TRANSACTIONS)
    _SPI.beginTransaction(SPISettings(RF24_SPI_SPEED, MSBFIRST, SPI_MODE0));
    #endif // defined(RF24_SPI_TRANSACTIONS)
    csn(LOW);
    1b80:	80 e0       	ldi	r24, 0x00	; 0
    1b82:	0c 94 98 0d 	jmp	0x1b30	; 0x1b30 <RF24::csn(bool) [clone .constprop.69]>

00001b86 <RF24::endTransaction() [clone .constprop.66]>:
_ZN4RF2414endTransactionEv.constprop.66():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:106

/****************************************************************************/

inline void RF24::endTransaction()
{
    csn(HIGH);
    1b86:	81 e0       	ldi	r24, 0x01	; 1
    1b88:	0c 94 98 0d 	jmp	0x1b30	; 0x1b30 <RF24::csn(bool) [clone .constprop.69]>

00001b8c <RF24::read_register(unsigned char) [clone .constprop.64]>:
_ZN4RF2413read_registerEh.constprop.64():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:150
    return status;
}

/****************************************************************************/

uint8_t RF24::read_register(uint8_t reg)
    1b8c:	cf 93       	push	r28
    1b8e:	c8 2f       	mov	r28, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:168
    result = *++prx;   // result is 2nd byte of receive buffer

    endTransaction();
    #else // !defined(RF24_LINUX)

    beginTransaction();
    1b90:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:169
    _SPI.transfer(R_REGISTER | (REGISTER_MASK & reg));
    1b94:	8c 2f       	mov	r24, r28
    1b96:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:170
    result = _SPI.transfer(0xff);
    1b9a:	8f ef       	ldi	r24, 0xFF	; 255
    1b9c:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1ba0:	c8 2f       	mov	r28, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:171
    endTransaction();
    1ba2:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:176

    #endif // !defined(RF24_LINUX)

    return result;
}
    1ba6:	8c 2f       	mov	r24, r28
    1ba8:	cf 91       	pop	r28
    1baa:	08 95       	ret

00001bac <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.63]>:
_ZN4RF2414write_registerEhPKhh.constprop.63():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:180

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, const uint8_t* buf, uint8_t len)
    1bac:	ef 92       	push	r14
    1bae:	ff 92       	push	r15
    1bb0:	0f 93       	push	r16
    1bb2:	1f 93       	push	r17
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	c8 2f       	mov	r28, r24
    1bba:	7b 01       	movw	r14, r22
    1bbc:	14 2f       	mov	r17, r20
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:199
    _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, size);
    status = *prx; // status is 1st byte of receive buffer
    endTransaction();
    #else // !defined(RF24_LINUX)

    beginTransaction();
    1bbe:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:200
    status = _SPI.transfer(W_REGISTER | (REGISTER_MASK & reg));
    1bc2:	8c 2f       	mov	r24, r28
    1bc4:	8f 71       	andi	r24, 0x1F	; 31
    1bc6:	80 62       	ori	r24, 0x20	; 32
    1bc8:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1bcc:	08 2f       	mov	r16, r24
    1bce:	e7 01       	movw	r28, r14
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:201
    while (len--) {
    1bd0:	11 50       	subi	r17, 0x01	; 1
    1bd2:	20 f0       	brcs	.+8      	; 0x1bdc <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.63]+0x30>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:202
        _SPI.transfer(*buf++);
    1bd4:	89 91       	ld	r24, Y+
    1bd6:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1bda:	fa cf       	rjmp	.-12     	; 0x1bd0 <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.63]+0x24>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:204
    }
    endTransaction();
    1bdc:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:208
    #endif // !defined(RF24_LINUX)

    return status;
}
    1be0:	80 2f       	mov	r24, r16
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	1f 91       	pop	r17
    1be8:	0f 91       	pop	r16
    1bea:	ff 90       	pop	r15
    1bec:	ef 90       	pop	r14
    1bee:	08 95       	ret

00001bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>:
_ZN4RF2414write_registerEhh.constprop.62():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:212

/****************************************************************************/

uint8_t RF24::write_register(uint8_t reg, uint8_t value)
    1bf0:	cf 93       	push	r28
    1bf2:	df 93       	push	r29
    1bf4:	c8 2f       	mov	r28, r24
    1bf6:	d6 2f       	mov	r29, r22
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:230
    _SPI.transfernb( (char *) spi_txbuff, (char *) spi_rxbuff, 2);
    status = *prx++; // status is 1st byte of receive buffer
    endTransaction();
    #else // !defined(RF24_LINUX)

    beginTransaction();
    1bf8:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:231
    status = _SPI.transfer(W_REGISTER | (REGISTER_MASK & reg));
    1bfc:	8c 2f       	mov	r24, r28
    1bfe:	8f 71       	andi	r24, 0x1F	; 31
    1c00:	80 62       	ori	r24, 0x20	; 32
    1c02:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1c06:	c8 2f       	mov	r28, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:232
    _SPI.transfer(value);
    1c08:	8d 2f       	mov	r24, r29
    1c0a:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:233
    endTransaction();
    1c0e:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:238

    #endif // !defined(RF24_LINUX)

    return status;
}
    1c12:	8c 2f       	mov	r24, r28
    1c14:	df 91       	pop	r29
    1c16:	cf 91       	pop	r28
    1c18:	08 95       	ret

00001c1a <RF24::powerUp() [clone .constprop.50]>:
_ZN4RF247powerUpEv.constprop.50():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:821
/****************************************************************************/

//Power up now. Radio will not power down unless instructed by MCU for config changes etc.
void RF24::powerUp(void)
{
    uint8_t cfg = read_register(NRF_CONFIG);
    1c1a:	80 e0       	ldi	r24, 0x00	; 0
    1c1c:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:824

    // if not powered up then power up and wait for the radio to initialize
    if (!(cfg & _BV(PWR_UP))) {
    1c20:	81 fd       	sbrc	r24, 1
    1c22:	0b c0       	rjmp	.+22     	; 0x1c3a <RF24::powerUp() [clone .constprop.50]+0x20>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:825
        write_register(NRF_CONFIG, cfg | _BV(PWR_UP));
    1c24:	68 2f       	mov	r22, r24
    1c26:	62 60       	ori	r22, 0x02	; 2
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:830

        // For nRF24L01+ to go from power down mode to TX or RX mode it must first pass through stand-by mode.
        // There must be a delay of Tpd2stby (see Table 16.) after the nRF24L01+ leaves power down mode before
        // the CEis set high. - Tpd2stby can be up to 5ms per the 1.0 datasheet
        delay(5);
    1c2e:	65 e0       	ldi	r22, 0x05	; 5
    1c30:	70 e0       	ldi	r23, 0x00	; 0
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	90 e0       	ldi	r25, 0x00	; 0
    1c36:	0c 94 eb 06 	jmp	0xdd6	; 0xdd6 <delay>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:832
    }
}
    1c3a:	08 95       	ret

00001c3c <RF24::setDataRate(rf24_datarate_e) [clone .constprop.38]>:
_ZN4RF2411setDataRateE15rf24_datarate_e.constprop.38():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1498
    return read_register(OBSERVE_TX) & 0x0F;
}

/****************************************************************************/

bool RF24::setDataRate(rf24_datarate_e speed)
    1c3c:	0f 93       	push	r16
    1c3e:	1f 93       	push	r17
    1c40:	cf 93       	push	r28
    1c42:	8c 01       	movw	r16, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1501
{
    bool result = false;
    uint8_t setup = read_register(RF_SETUP);
    1c44:	86 e0       	ldi	r24, 0x06	; 6
    1c46:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1504

    // HIGH and LOW '00' is 1Mbs - our default
    setup &= ~(_BV(RF_DR_LOW) | _BV(RF_DR_HIGH));
    1c4a:	c8 2f       	mov	r28, r24
    1c4c:	c7 7d       	andi	r28, 0xD7	; 215
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1509

    #if !defined(F_CPU) || F_CPU > 20000000
    txDelay = 250;
    #else //16Mhz Arduino
    txDelay=85;
    1c4e:	85 e5       	ldi	r24, 0x55	; 85
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	a0 e0       	ldi	r26, 0x00	; 0
    1c54:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1511
    #endif
    if (speed == RF24_250KBPS) {
    1c56:	02 30       	cpi	r16, 0x02	; 2
    1c58:	11 05       	cpc	r17, r1
    1c5a:	29 f4       	brne	.+10     	; 0x1c66 <RF24::setDataRate(rf24_datarate_e) [clone .constprop.38]+0x2a>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1514
        // Must set the RF_DR_LOW to 1; RF_DR_HIGH (used to be RF_DR) is already 0
        // Making it '10'.
        setup |= _BV(RF_DR_LOW);
    1c5c:	c0 62       	ori	r28, 0x20	; 32
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1518
        #if !defined(F_CPU) || F_CPU > 20000000
        txDelay = 450;
        #else //16Mhz Arduino
        txDelay = 155;
    1c5e:	8b e9       	ldi	r24, 0x9B	; 155
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	a0 e0       	ldi	r26, 0x00	; 0
    1c64:	b0 e0       	ldi	r27, 0x00	; 0
    1c66:	80 93 08 3a 	sts	0x3A08, r24	; 0x803a08 <radio+0x10>
    1c6a:	90 93 09 3a 	sts	0x3A09, r25	; 0x803a09 <radio+0x11>
    1c6e:	a0 93 0a 3a 	sts	0x3A0A, r26	; 0x803a0a <radio+0x12>
    1c72:	b0 93 0b 3a 	sts	0x3A0B, r27	; 0x803a0b <radio+0x13>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1532
            #else // 16Mhz Arduino
            txDelay = 65;
            #endif
        }
    }
    write_register(RF_SETUP, setup);
    1c76:	6c 2f       	mov	r22, r28
    1c78:	86 e0       	ldi	r24, 0x06	; 6
    1c7a:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1535

    // Verify our result
    if (read_register(RF_SETUP) == setup) {
    1c7e:	86 e0       	ldi	r24, 0x06	; 6
    1c80:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    1c84:	91 e0       	ldi	r25, 0x01	; 1
    1c86:	c8 13       	cpse	r28, r24
    1c88:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1539
        result = true;
    }
    return result;
}
    1c8a:	89 2f       	mov	r24, r25
    1c8c:	cf 91       	pop	r28
    1c8e:	1f 91       	pop	r17
    1c90:	0f 91       	pop	r16
    1c92:	08 95       	ret

00001c94 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]>:
_ZN4RF2412read_payloadEPvh.constprop.59():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:289
    return status;
}

/****************************************************************************/

uint8_t RF24::read_payload(void* buf, uint8_t data_len)
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:294
{
    uint8_t status;
    uint8_t* current = reinterpret_cast<uint8_t*>(buf);

    if (data_len > payload_size) {
    1c9e:	c0 91 ff 39 	lds	r28, 0x39FF	; 0x8039ff <radio+0x7>
    1ca2:	dc 2f       	mov	r29, r28
    1ca4:	c0 32       	cpi	r28, 0x20	; 32
    1ca6:	08 f0       	brcs	.+2      	; 0x1caa <RF24::read_payload(void*, unsigned char) [clone .constprop.59]+0x16>
    1ca8:	d0 e2       	ldi	r29, 0x20	; 32
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:297
        data_len = payload_size;
    }
    uint8_t blank_len = dynamic_payloads_enabled ? 0 : payload_size - data_len;
    1caa:	80 91 00 3a 	lds	r24, 0x3A00	; 0x803a00 <radio+0x8>
    1cae:	cd 1b       	sub	r28, r29
    1cb0:	81 11       	cpse	r24, r1
    1cb2:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:329
      *current = *prx;
    }
    endTransaction();
    #else // !defined(RF24_LINUX)

    beginTransaction();
    1cb4:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:330
    status = _SPI.transfer(R_RX_PAYLOAD);
    1cb8:	81 e6       	ldi	r24, 0x61	; 97
    1cba:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1cbe:	f8 2e       	mov	r15, r24
    1cc0:	09 e8       	ldi	r16, 0x89	; 137
    1cc2:	18 e3       	ldi	r17, 0x38	; 56
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:331
    while (data_len--) {
    1cc4:	d1 50       	subi	r29, 0x01	; 1
    1cc6:	38 f0       	brcs	.+14     	; 0x1cd6 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]+0x42>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:332
        *current++ = _SPI.transfer(0xFF);
    1cc8:	8f ef       	ldi	r24, 0xFF	; 255
    1cca:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1cce:	f8 01       	movw	r30, r16
    1cd0:	81 93       	st	Z+, r24
    1cd2:	8f 01       	movw	r16, r30
    1cd4:	f7 cf       	rjmp	.-18     	; 0x1cc4 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]+0x30>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:334
    }
    while (blank_len--) {
    1cd6:	c1 50       	subi	r28, 0x01	; 1
    1cd8:	20 f0       	brcs	.+8      	; 0x1ce2 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]+0x4e>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:335
        _SPI.transfer(0xff);
    1cda:	8f ef       	ldi	r24, 0xFF	; 255
    1cdc:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1ce0:	fa cf       	rjmp	.-12     	; 0x1cd6 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]+0x42>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:337
    }
    endTransaction();
    1ce2:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:342

    #endif // !defined(RF24_LINUX)

    return status;
}
    1ce6:	8f 2d       	mov	r24, r15
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	ff 90       	pop	r15
    1cf2:	08 95       	ret

00001cf4 <RF24::flush_tx() [clone .constprop.56]>:
_ZN4RF248flush_txEv.constprop.56():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:353
    return spiTrans(FLUSH_RX);
}

/****************************************************************************/

uint8_t RF24::flush_tx(void)
    1cf4:	cf 93       	push	r28
spiTrans():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:365
uint8_t RF24::spiTrans(uint8_t cmd)
{

    uint8_t status;

    beginTransaction();
    1cf6:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:366
    status = _SPI.transfer(cmd);
    1cfa:	81 ee       	ldi	r24, 0xE1	; 225
    1cfc:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    1d00:	c8 2f       	mov	r28, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:367
    endTransaction();
    1d02:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
_ZN4RF248flush_txEv.constprop.56():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:356
/****************************************************************************/

uint8_t RF24::flush_tx(void)
{
    return spiTrans(FLUSH_TX);
}
    1d06:	8c 2f       	mov	r24, r28
    1d08:	cf 91       	pop	r28
    1d0a:	08 95       	ret

00001d0c <respond()>:
_Z7respondv():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1143

/****************************************************************************/

bool RF24::available(uint8_t* pipe_num)
{
    if (!(read_register(FIFO_STATUS) & _BV(RX_EMPTY))) {
    1d0c:	87 e1       	ldi	r24, 0x17	; 23
    1d0e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    1d12:	80 fd       	sbrc	r24, 0
    1d14:	06 c0       	rjmp	.+12     	; 0x1d22 <respond()+0x16>
read():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1164

void RF24::read(void* buf, uint8_t len)
{

    // Fetch the payload
    read_payload(buf, len);
    1d16:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1167

    //Clear the two possible interrupt flags with one command
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(MAX_RT) | _BV(TX_DS));
    1d1a:	60 e7       	ldi	r22, 0x70	; 112
    1d1c:	87 e0       	ldi	r24, 0x07	; 7
    1d1e:	0c 94 f8 0d 	jmp	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
_Z7respondv():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:79
//Funkcja do obsugi przerwania radia
void respond() {
  if (radio.available()) {
    radio.read(readBuf, 32); //Oczyszczanie bufora poprzez read() (chod nic w praktyce nie czytamy, trzeba czyci bufor)
  }
}
    1d22:	08 95       	ret

00001d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>:
_ZN5Print5writeEPKc.part.2.constprop.33():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.h:49
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    1d24:	fc 01       	movw	r30, r24
    1d26:	01 90       	ld	r0, Z+
    1d28:	00 20       	and	r0, r0
    1d2a:	e9 f7       	brne	.-6      	; 0x1d26 <Print::write(char const*) [clone .part.2] [clone .constprop.33]+0x2>
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	af 01       	movw	r20, r30
    1d30:	48 1b       	sub	r20, r24
    1d32:	59 0b       	sbc	r21, r25
    1d34:	bc 01       	movw	r22, r24
    1d36:	80 ef       	ldi	r24, 0xF0	; 240
    1d38:	98 e3       	ldi	r25, 0x38	; 56
    1d3a:	0c 94 6a 05 	jmp	0xad4	; 0xad4 <Print::write(unsigned char const*, unsigned int)>

00001d3e <Print::println(char const*) [clone .constprop.30]>:
_ZN5Print7printlnEPKc.constprop.30():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:137
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
    1d3e:	cf 93       	push	r28
    1d40:	df 93       	push	r29
write():
    1d42:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>
    1d46:	ec 01       	movw	r28, r24
    1d48:	88 e3       	ldi	r24, 0x38	; 56
    1d4a:	9a eb       	ldi	r25, 0xBA	; 186
    1d4c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>
_ZN5Print7printlnEPKc.constprop.30():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:142
{
  size_t n = print(c);
  n += println();
  return n;
}
    1d50:	8c 0f       	add	r24, r28
    1d52:	9d 1f       	adc	r25, r29
    1d54:	df 91       	pop	r29
    1d56:	cf 91       	pop	r28
    1d58:	08 95       	ret

00001d5a <__vector_28>:
__vector_28():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:50
#error "Don't know what the Data Received interrupt vector is called for Serial"
#endif

#if defined(HWSERIAL0_DRE_VECTOR)
ISR(HWSERIAL0_DRE_VECTOR)
{
    1d5a:	1f 92       	push	r1
    1d5c:	0f 92       	push	r0
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	0f 92       	push	r0
    1d62:	11 24       	eor	r1, r1
    1d64:	2f 93       	push	r18
    1d66:	3f 93       	push	r19
    1d68:	4f 93       	push	r20
    1d6a:	5f 93       	push	r21
    1d6c:	6f 93       	push	r22
    1d6e:	7f 93       	push	r23
    1d70:	8f 93       	push	r24
    1d72:	9f 93       	push	r25
    1d74:	af 93       	push	r26
    1d76:	bf 93       	push	r27
    1d78:	ef 93       	push	r30
    1d7a:	ff 93       	push	r31
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:51
  Serial._tx_data_empty_irq();
    1d7c:	80 ef       	ldi	r24, 0xF0	; 240
    1d7e:	98 e3       	ldi	r25, 0x38	; 56
    1d80:	0e 94 9e 04 	call	0x93c	; 0x93c <UartClass::_tx_data_empty_irq()>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:52
}
    1d84:	ff 91       	pop	r31
    1d86:	ef 91       	pop	r30
    1d88:	bf 91       	pop	r27
    1d8a:	af 91       	pop	r26
    1d8c:	9f 91       	pop	r25
    1d8e:	8f 91       	pop	r24
    1d90:	7f 91       	pop	r23
    1d92:	6f 91       	pop	r22
    1d94:	5f 91       	pop	r21
    1d96:	4f 91       	pop	r20
    1d98:	3f 91       	pop	r19
    1d9a:	2f 91       	pop	r18
    1d9c:	0f 90       	pop	r0
    1d9e:	0f be       	out	0x3f, r0	; 63
    1da0:	0f 90       	pop	r0
    1da2:	1f 90       	pop	r1
    1da4:	18 95       	reti

00001da6 <__vector_27>:
__vector_27():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:41

#if defined(HAVE_HWSERIAL0)

#if defined(HWSERIAL0_RXC_VECTOR)
ISR(HWSERIAL0_RXC_VECTOR)
{
    1da6:	1f 92       	push	r1
    1da8:	0f 92       	push	r0
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	0f 92       	push	r0
    1dae:	11 24       	eor	r1, r1
    1db0:	2f 93       	push	r18
    1db2:	8f 93       	push	r24
    1db4:	9f 93       	push	r25
    1db6:	ef 93       	push	r30
    1db8:	ff 93       	push	r31
_rx_complete_irq():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:59
// Actual interrupt handlers //////////////////////////////////////////////////////////////

void UartClass::_rx_complete_irq(void)
{
  //if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  if (!(((*_hwserial_module).RXDATAH) & USART_PERR_bm)) {
    1dba:	e0 91 fc 38 	lds	r30, 0x38FC	; 0x8038fc <Serial+0xc>
    1dbe:	f0 91 fd 38 	lds	r31, 0x38FD	; 0x8038fd <Serial+0xd>
    1dc2:	81 81       	ldd	r24, Z+1	; 0x01
    1dc4:	81 fd       	sbrc	r24, 1
    1dc6:	1b c0       	rjmp	.+54     	; 0x1dfe <__vector_27+0x58>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:62
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = (*_hwserial_module).RXDATAL;
    1dc8:	90 81       	ld	r25, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:63
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1dca:	80 91 06 39 	lds	r24, 0x3906	; 0x803906 <Serial+0x16>
    1dce:	8f 5f       	subi	r24, 0xFF	; 255
    1dd0:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:69

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1dd2:	20 91 07 39 	lds	r18, 0x3907	; 0x803907 <Serial+0x17>
    1dd6:	82 17       	cp	r24, r18
    1dd8:	41 f0       	breq	.+16     	; 0x1dea <__vector_27+0x44>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:70
      _rx_buffer[_rx_buffer_head] = c;
    1dda:	e0 91 06 39 	lds	r30, 0x3906	; 0x803906 <Serial+0x16>
    1dde:	f0 e0       	ldi	r31, 0x00	; 0
    1de0:	e0 51       	subi	r30, 0x10	; 16
    1de2:	f7 4c       	sbci	r31, 0xC7	; 199
    1de4:	95 8f       	std	Z+29, r25	; 0x1d
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:71
      _rx_buffer_head = i;
    1de6:	80 93 06 39 	sts	0x3906, r24	; 0x803906 <Serial+0x16>
__vector_27():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART0.cpp:43
  Serial._rx_complete_irq();
}
    1dea:	ff 91       	pop	r31
    1dec:	ef 91       	pop	r30
    1dee:	9f 91       	pop	r25
    1df0:	8f 91       	pop	r24
    1df2:	2f 91       	pop	r18
    1df4:	0f 90       	pop	r0
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	0f 90       	pop	r0
    1dfa:	1f 90       	pop	r1
    1dfc:	18 95       	reti
_rx_complete_irq():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART_private.h:75
    }
  } else {
    // Parity error, read byte but discard it
    (*_hwserial_module).RXDATAL;
    1dfe:	80 81       	ld	r24, Z
    1e00:	f4 cf       	rjmp	.-24     	; 0x1dea <__vector_27+0x44>

00001e02 <__vector_15>:
__vector_15():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:114
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "no millis timer selected"
#endif
{
    1e02:	1f 92       	push	r1
    1e04:	0f 92       	push	r0
    1e06:	0f b6       	in	r0, 0x3f	; 63
    1e08:	0f 92       	push	r0
    1e0a:	11 24       	eor	r1, r1
    1e0c:	2f 93       	push	r18
    1e0e:	3f 93       	push	r19
    1e10:	4f 93       	push	r20
    1e12:	5f 93       	push	r21
    1e14:	6f 93       	push	r22
    1e16:	8f 93       	push	r24
    1e18:	9f 93       	push	r25
    1e1a:	af 93       	push	r26
    1e1c:	bf 93       	push	r27
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:126
    #else
      timer_millis+=2;
    #endif
  #else
    #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
      uint32_t m = timer_millis;
    1e1e:	80 91 16 38 	lds	r24, 0x3816	; 0x803816 <timer_millis>
    1e22:	90 91 17 38 	lds	r25, 0x3817	; 0x803817 <timer_millis+0x1>
    1e26:	a0 91 18 38 	lds	r26, 0x3818	; 0x803818 <timer_millis+0x2>
    1e2a:	b0 91 19 38 	lds	r27, 0x3819	; 0x803819 <timer_millis+0x3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:127
      uint16_t f = timer_fract;
    1e2e:	40 91 14 38 	lds	r20, 0x3814	; 0x803814 <timer_fract>
    1e32:	50 91 15 38 	lds	r21, 0x3815	; 0x803815 <timer_fract+0x1>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:129
      m += MILLIS_INC;
      f += FRACT_INC;
    1e36:	9a 01       	movw	r18, r20
    1e38:	20 5d       	subi	r18, 0xD0	; 208
    1e3a:	3c 4f       	sbci	r19, 0xFC	; 252
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:130
      if (f >= FRACT_MAX) {
    1e3c:	28 3e       	cpi	r18, 0xE8	; 232
    1e3e:	63 e0       	ldi	r22, 0x03	; 3
    1e40:	36 07       	cpc	r19, r22
    1e42:	28 f0       	brcs	.+10     	; 0x1e4e <__vector_15+0x4c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:132

        f -= FRACT_MAX;
    1e44:	28 5e       	subi	r18, 0xE8	; 232
    1e46:	33 40       	sbci	r19, 0x03	; 3
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:133
        m += 1;
    1e48:	01 96       	adiw	r24, 0x01	; 1
    1e4a:	a1 1d       	adc	r26, r1
    1e4c:	b1 1d       	adc	r27, r1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:135
      }
      timer_fract = f;
    1e4e:	20 93 14 38 	sts	0x3814, r18	; 0x803814 <timer_fract>
    1e52:	30 93 15 38 	sts	0x3815, r19	; 0x803815 <timer_fract+0x1>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:136
      timer_millis = m;
    1e56:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <timer_millis>
    1e5a:	90 93 17 38 	sts	0x3817, r25	; 0x803817 <timer_millis+0x1>
    1e5e:	a0 93 18 38 	sts	0x3818, r26	; 0x803818 <timer_millis+0x2>
    1e62:	b0 93 19 38 	sts	0x3819, r27	; 0x803819 <timer_millis+0x3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:139
    #endif
    //if RTC is used as timer, we only increment the overflow count
    timer_overflow_count++;
    1e66:	80 91 1a 38 	lds	r24, 0x381A	; 0x80381a <timer_overflow_count>
    1e6a:	90 91 1b 38 	lds	r25, 0x381B	; 0x80381b <timer_overflow_count+0x1>
    1e6e:	a0 91 1c 38 	lds	r26, 0x381C	; 0x80381c <timer_overflow_count+0x2>
    1e72:	b0 91 1d 38 	lds	r27, 0x381D	; 0x80381d <timer_overflow_count+0x3>
    1e76:	01 96       	adiw	r24, 0x01	; 1
    1e78:	a1 1d       	adc	r26, r1
    1e7a:	b1 1d       	adc	r27, r1
    1e7c:	80 93 1a 38 	sts	0x381A, r24	; 0x80381a <timer_overflow_count>
    1e80:	90 93 1b 38 	sts	0x381B, r25	; 0x80381b <timer_overflow_count+0x1>
    1e84:	a0 93 1c 38 	sts	0x381C, r26	; 0x80381c <timer_overflow_count+0x2>
    1e88:	b0 93 1d 38 	sts	0x381D, r27	; 0x80381d <timer_overflow_count+0x3>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:145
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
    TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
    TCD0.INTFLAGS=TCD_OVF_bm;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <__TEXT_REGION_LENGTH__+0x700a8d>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:151
  #elif defined(MILLIS_USE_TIMERRTC)
    RTC.INTFLAGS=RTC_OVF_bm;
  #else //timerb
    _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
    1e92:	bf 91       	pop	r27
    1e94:	af 91       	pop	r26
    1e96:	9f 91       	pop	r25
    1e98:	8f 91       	pop	r24
    1e9a:	6f 91       	pop	r22
    1e9c:	5f 91       	pop	r21
    1e9e:	4f 91       	pop	r20
    1ea0:	3f 91       	pop	r19
    1ea2:	2f 91       	pop	r18
    1ea4:	0f 90       	pop	r0
    1ea6:	0f be       	out	0x3f, r0	; 63
    1ea8:	0f 90       	pop	r0
    1eaa:	1f 90       	pop	r1
    1eac:	18 95       	reti

00001eae <__vector_4>:
__vector_4():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:146
} \


IMPLEMENT_ISR(PORTA_PORT_vect, PA)
#if defined(PORTB_PORT_vect)
IMPLEMENT_ISR(PORTB_PORT_vect, PB)
    1eae:	1f 92       	push	r1
    1eb0:	0f 92       	push	r0
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	0f 92       	push	r0
    1eb6:	11 24       	eor	r1, r1
    1eb8:	2f 93       	push	r18
    1eba:	3f 93       	push	r19
    1ebc:	4f 93       	push	r20
    1ebe:	5f 93       	push	r21
    1ec0:	6f 93       	push	r22
    1ec2:	7f 93       	push	r23
    1ec4:	8f 93       	push	r24
    1ec6:	9f 93       	push	r25
    1ec8:	af 93       	push	r26
    1eca:	bf 93       	push	r27
    1ecc:	ef 93       	push	r30
    1ece:	ff 93       	push	r31
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	0e 94 27 07 	call	0xe4e	; 0xe4e <port_interrupt_handler>
    1ed6:	ff 91       	pop	r31
    1ed8:	ef 91       	pop	r30
    1eda:	bf 91       	pop	r27
    1edc:	af 91       	pop	r26
    1ede:	9f 91       	pop	r25
    1ee0:	8f 91       	pop	r24
    1ee2:	7f 91       	pop	r23
    1ee4:	6f 91       	pop	r22
    1ee6:	5f 91       	pop	r21
    1ee8:	4f 91       	pop	r20
    1eea:	3f 91       	pop	r19
    1eec:	2f 91       	pop	r18
    1eee:	0f 90       	pop	r0
    1ef0:	0f be       	out	0x3f, r0	; 63
    1ef2:	0f 90       	pop	r0
    1ef4:	1f 90       	pop	r1
    1ef6:	18 95       	reti

00001ef8 <__vector_3>:
__vector_3():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:144
ISR(vect) { \
  port_interrupt_handler(port);\
} \


IMPLEMENT_ISR(PORTA_PORT_vect, PA)
    1ef8:	1f 92       	push	r1
    1efa:	0f 92       	push	r0
    1efc:	0f b6       	in	r0, 0x3f	; 63
    1efe:	0f 92       	push	r0
    1f00:	11 24       	eor	r1, r1
    1f02:	2f 93       	push	r18
    1f04:	3f 93       	push	r19
    1f06:	4f 93       	push	r20
    1f08:	5f 93       	push	r21
    1f0a:	6f 93       	push	r22
    1f0c:	7f 93       	push	r23
    1f0e:	8f 93       	push	r24
    1f10:	9f 93       	push	r25
    1f12:	af 93       	push	r26
    1f14:	bf 93       	push	r27
    1f16:	ef 93       	push	r30
    1f18:	ff 93       	push	r31
    1f1a:	80 e0       	ldi	r24, 0x00	; 0
    1f1c:	0e 94 27 07 	call	0xe4e	; 0xe4e <port_interrupt_handler>
    1f20:	ff 91       	pop	r31
    1f22:	ef 91       	pop	r30
    1f24:	bf 91       	pop	r27
    1f26:	af 91       	pop	r26
    1f28:	9f 91       	pop	r25
    1f2a:	8f 91       	pop	r24
    1f2c:	7f 91       	pop	r23
    1f2e:	6f 91       	pop	r22
    1f30:	5f 91       	pop	r21
    1f32:	4f 91       	pop	r20
    1f34:	3f 91       	pop	r19
    1f36:	2f 91       	pop	r18
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63
    1f3c:	0f 90       	pop	r0
    1f3e:	1f 90       	pop	r1
    1f40:	18 95       	reti

00001f42 <__vector_24>:
__vector_24():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:772

ISR(TWI0_TWIM_vect){
	TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect){
    1f42:	1f 92       	push	r1
    1f44:	0f 92       	push	r0
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	0f 92       	push	r0
    1f4a:	11 24       	eor	r1, r1
    1f4c:	2f 93       	push	r18
    1f4e:	3f 93       	push	r19
    1f50:	4f 93       	push	r20
    1f52:	5f 93       	push	r21
    1f54:	6f 93       	push	r22
    1f56:	7f 93       	push	r23
    1f58:	8f 93       	push	r24
    1f5a:	9f 93       	push	r25
    1f5c:	af 93       	push	r26
    1f5e:	bf 93       	push	r27
    1f60:	cf 93       	push	r28
    1f62:	ef 93       	push	r30
    1f64:	ff 93       	push	r31
TWI_SlaveInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:534
 *
 *  Check current status and calls the appropriate handler.
 *
 */
void TWI_SlaveInterruptHandler(){
	uint8_t currentStatus = TWI0.SSTATUS;
    1f66:	c0 91 1b 08 	lds	r28, 0x081B	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:537

	/* If bus error */
	if(currentStatus & TWI_BUSERR_bm){
    1f6a:	c2 ff       	sbrs	r28, 2
    1f6c:	0a c0       	rjmp	.+20     	; 0x1f82 <__vector_24+0x40>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:538
		slave_bytesRead = 0;
    1f6e:	10 92 13 38 	sts	0x3813, r1	; 0x803813 <slave_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:539
		slave_bytesWritten = 0;
    1f72:	10 92 12 38 	sts	0x3812, r1	; 0x803812 <slave_bytesWritten>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:540
		slave_bytesToWrite = 0;
    1f76:	10 92 11 38 	sts	0x3811, r1	; 0x803811 <slave_bytesToWrite>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:541
		TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
    1f7a:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:595
		}
	}

	/* If unexpected state */
	else {
		TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
    1f7c:	0e 94 58 07 	call	0xeb0	; 0xeb0 <TWI_SlaveTransactionFinished>
    1f80:	12 c0       	rjmp	.+36     	; 0x1fa6 <__vector_24+0x64>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:545
		slave_bytesToWrite = 0;
		TWI_SlaveTransactionFinished(TWIS_RESULT_BUS_ERROR);
	}

	/* If Address or Stop */
	else if(currentStatus & TWI_APIF_bm){
    1f82:	c6 ff       	sbrs	r28, 6
    1f84:	2d c0       	rjmp	.+90     	; 0x1fe0 <__vector_24+0x9e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:550

		/* Call user onReceive function if end of Master Write/Slave Read.
		 * This should be hit when there is a STOP or REPSTART
		 */
		if(slave_callUserReceive == 1){
    1f86:	80 91 10 38 	lds	r24, 0x3810	; 0x803810 <slave_callUserReceive>
    1f8a:	81 30       	cpi	r24, 0x01	; 1
    1f8c:	41 f4       	brne	.+16     	; 0x1f9e <__vector_24+0x5c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:551
			TWI_onSlaveReceive(slave_bytesRead);
    1f8e:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <slave_bytesRead>
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	f0 e0       	ldi	r31, 0x00	; 0
    1f96:	e0 e0       	ldi	r30, 0x00	; 0
    1f98:	09 95       	icall
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:552
			slave_callUserReceive = 0;
    1f9a:	10 92 10 38 	sts	0x3810, r1	; 0x803810 <slave_callUserReceive>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:556
		}

		/* If address match */
		if(currentStatus & TWI_AP_bm){
    1f9e:	c0 ff       	sbrs	r28, 0
    1fa0:	14 c0       	rjmp	.+40     	; 0x1fca <__vector_24+0x88>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:557
			TWI_SlaveAddressMatchHandler();
    1fa2:	0e 94 65 07 	call	0xeca	; 0xeca <TWI_SlaveAddressMatchHandler>
__vector_24():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:774
	TWI_MasterInterruptHandler();
}

ISR(TWI0_TWIS_vect){
	TWI_SlaveInterruptHandler();
}
    1fa6:	ff 91       	pop	r31
    1fa8:	ef 91       	pop	r30
    1faa:	cf 91       	pop	r28
    1fac:	bf 91       	pop	r27
    1fae:	af 91       	pop	r26
    1fb0:	9f 91       	pop	r25
    1fb2:	8f 91       	pop	r24
    1fb4:	7f 91       	pop	r23
    1fb6:	6f 91       	pop	r22
    1fb8:	5f 91       	pop	r21
    1fba:	4f 91       	pop	r20
    1fbc:	3f 91       	pop	r19
    1fbe:	2f 91       	pop	r18
    1fc0:	0f 90       	pop	r0
    1fc2:	0f be       	out	0x3f, r0	; 63
    1fc4:	0f 90       	pop	r0
    1fc6:	1f 90       	pop	r1
    1fc8:	18 95       	reti
TWI_SlaveStopHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:635
 *
 */
void TWI_SlaveStopHandler(){

	/* Clear APIF, don't ACK or NACK */
	TWI0.SSTATUS = TWI_APIF_bm;
    1fca:	80 e4       	ldi	r24, 0x40	; 64
    1fcc:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:637

	TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	0e 94 58 07 	call	0xeb0	; 0xeb0 <TWI_SlaveTransactionFinished>
TWI_SlaveInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:568

			/* If CLKHOLD is high, we have missed an address match
			  from a fast start after stop.
			  Because the flag is shared we need to handle this here.
			*/
			if(TWI0.SSTATUS & TWI_CLKHOLD_bm){
    1fd6:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
    1fda:	85 ff       	sbrs	r24, 5
    1fdc:	e4 cf       	rjmp	.-56     	; 0x1fa6 <__vector_24+0x64>
    1fde:	e1 cf       	rjmp	.-62     	; 0x1fa2 <__vector_24+0x60>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:577
			}
		}
	}

	/* If Data Interrupt */
	else if (currentStatus & TWI_DIF_bm){
    1fe0:	c7 ff       	sbrs	r28, 7
    1fe2:	50 c0       	rjmp	.+160    	; 0x2084 <__vector_24+0x142>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:580

		/* If collision flag is raised, slave transmit unsuccessful */
		if (currentStatus & TWI_COLL_bm){
    1fe4:	c3 ff       	sbrs	r28, 3
    1fe6:	08 c0       	rjmp	.+16     	; 0x1ff8 <__vector_24+0xb6>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:581
			slave_bytesRead = 0;
    1fe8:	10 92 13 38 	sts	0x3813, r1	; 0x803813 <slave_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:582
			slave_bytesWritten = 0;
    1fec:	10 92 12 38 	sts	0x3812, r1	; 0x803812 <slave_bytesWritten>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:583
			slave_bytesToWrite = 0;
    1ff0:	10 92 11 38 	sts	0x3811, r1	; 0x803811 <slave_bytesToWrite>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:584
			TWI_SlaveTransactionFinished(TWIS_RESULT_TRANSMIT_COLLISION);
    1ff4:	83 e0       	ldi	r24, 0x03	; 3
    1ff6:	c2 cf       	rjmp	.-124    	; 0x1f7c <__vector_24+0x3a>
TWI_SlaveDataHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:650
 *
 */
void TWI_SlaveDataHandler(){

	/* Enable stop interrupt */
	TWI0.SCTRLA |= (TWI_APIEN_bm | TWI_PIEN_bm);
    1ff8:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <__TEXT_REGION_LENGTH__+0x700819>
    1ffc:	80 66       	ori	r24, 0x60	; 96
    1ffe:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <__TEXT_REGION_LENGTH__+0x700819>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:653

	/* If Master Read/Slave Write */
	if(TWI0.SSTATUS & TWI_DIR_bm){
    2002:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
    2006:	81 ff       	sbrs	r24, 1
    2008:	26 c0       	rjmp	.+76     	; 0x2056 <__vector_24+0x114>
TWI_SlaveWriteHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:674
 *
 */
void TWI_SlaveWriteHandler(){

	/* If NACK, slave write transaction finished */
	if((slave_bytesWritten > 0) && (TWI0.SSTATUS & TWI_RXACK_bm)){
    200a:	80 91 12 38 	lds	r24, 0x3812	; 0x803812 <slave_bytesWritten>
    200e:	88 23       	and	r24, r24
    2010:	49 f0       	breq	.+18     	; 0x2024 <__vector_24+0xe2>
    2012:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <__TEXT_REGION_LENGTH__+0x70081b>
    2016:	84 ff       	sbrs	r24, 4
    2018:	05 c0       	rjmp	.+10     	; 0x2024 <__vector_24+0xe2>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:676

		TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
    201a:	82 e0       	ldi	r24, 0x02	; 2
    201c:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <__TEXT_REGION_LENGTH__+0x70081a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:677
		TWI_SlaveTransactionFinished(TWIS_RESULT_OK);
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	ac cf       	rjmp	.-168    	; 0x1f7c <__vector_24+0x3a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:683
	}

	/* If ACK, master expects more data */
	else {

		if(slave_bytesWritten < slave_bytesToWrite){
    2024:	90 91 12 38 	lds	r25, 0x3812	; 0x803812 <slave_bytesWritten>
    2028:	80 91 11 38 	lds	r24, 0x3811	; 0x803811 <slave_bytesToWrite>
    202c:	98 17       	cp	r25, r24
    202e:	78 f4       	brcc	.+30     	; 0x204e <__vector_24+0x10c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:684
			uint8_t data = slave_writeData[slave_bytesWritten];
    2030:	e0 91 12 38 	lds	r30, 0x3812	; 0x803812 <slave_bytesWritten>
    2034:	f0 e0       	ldi	r31, 0x00	; 0
    2036:	80 81       	ld	r24, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:685
			TWI0.SDATA = data;
    2038:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <__TEXT_REGION_LENGTH__+0x70081d>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:686
			slave_bytesWritten++;
    203c:	80 91 12 38 	lds	r24, 0x3812	; 0x803812 <slave_bytesWritten>
    2040:	8f 5f       	subi	r24, 0xFF	; 255
    2042:	80 93 12 38 	sts	0x3812, r24	; 0x803812 <slave_bytesWritten>
TWI_SlaveReadHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:720
		uint8_t data = TWI0.SDATA;
		slave_readData[slave_bytesRead] = data;
		slave_bytesRead++;

		/* Send ACK and wait for data interrupt */
		TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
    2046:	83 e0       	ldi	r24, 0x03	; 3
    2048:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <__TEXT_REGION_LENGTH__+0x70081a>
    204c:	ac cf       	rjmp	.-168    	; 0x1fa6 <__vector_24+0x64>
TWI_SlaveWriteHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:695

		}

		/* If buffer overflow */
		else {
			TWI0.SCTRLB = TWI_SCMD_COMPTRANS_gc;
    204e:	82 e0       	ldi	r24, 0x02	; 2
    2050:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <__TEXT_REGION_LENGTH__+0x70081a>
    2054:	93 cf       	rjmp	.-218    	; 0x1f7c <__vector_24+0x3a>
TWI_SlaveReadHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:712
 *
 */
void TWI_SlaveReadHandler(){

	/* If free space in buffer */
	if(slave_bytesRead < slave_bytesToRead){
    2056:	90 91 13 38 	lds	r25, 0x3813	; 0x803813 <slave_bytesRead>
    205a:	80 91 0f 38 	lds	r24, 0x380F	; 0x80380f <slave_bytesToRead>
    205e:	98 17       	cp	r25, r24
    2060:	60 f4       	brcc	.+24     	; 0x207a <__vector_24+0x138>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:715

		/* Fetch data */
		uint8_t data = TWI0.SDATA;
    2062:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <__TEXT_REGION_LENGTH__+0x70081d>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:716
		slave_readData[slave_bytesRead] = data;
    2066:	e0 91 13 38 	lds	r30, 0x3813	; 0x803813 <slave_bytesRead>
    206a:	f0 e0       	ldi	r31, 0x00	; 0
    206c:	80 83       	st	Z, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:717
		slave_bytesRead++;
    206e:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <slave_bytesRead>
    2072:	8f 5f       	subi	r24, 0xFF	; 255
    2074:	80 93 13 38 	sts	0x3813, r24	; 0x803813 <slave_bytesRead>
    2078:	e6 cf       	rjmp	.-52     	; 0x2046 <__vector_24+0x104>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:725
		TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
	}
	/* If buffer overflow, send NACK and wait for next START.
		Set result buffer overflow */
	else {
		TWI0.SCTRLB = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;
    207a:	86 e0       	ldi	r24, 0x06	; 6
    207c:	80 93 1a 08 	sts	0x081A, r24	; 0x80081a <__TEXT_REGION_LENGTH__+0x70081a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:726
		TWI_SlaveTransactionFinished(TWIS_RESULT_BUFFER_OVERFLOW);
    2080:	82 e0       	ldi	r24, 0x02	; 2
    2082:	7c cf       	rjmp	.-264    	; 0x1f7c <__vector_24+0x3a>
TWI_SlaveInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:595
		}
	}

	/* If unexpected state */
	else {
		TWI_SlaveTransactionFinished(TWIS_RESULT_FAIL);
    2084:	85 e0       	ldi	r24, 0x05	; 5
    2086:	7a cf       	rjmp	.-268    	; 0x1f7c <__vector_24+0x3a>

00002088 <__vector_25>:
__vector_25():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:768
	twi_mode = TWI_MODE_SLAVE;
	slave_result = result;
	slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect){
    2088:	1f 92       	push	r1
    208a:	0f 92       	push	r0
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	0f 92       	push	r0
    2090:	11 24       	eor	r1, r1
    2092:	2f 93       	push	r18
    2094:	3f 93       	push	r19
    2096:	8f 93       	push	r24
    2098:	9f 93       	push	r25
    209a:	ef 93       	push	r30
    209c:	ff 93       	push	r31
TWI_MasterInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:362
 *  Check current status and calls the appropriate handler.
 *
 */
void TWI_MasterInterruptHandler()
{
	uint8_t currentStatus = TWI0.MSTATUS;
    209e:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:365

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_ARBLOST_bm) ||
    20a2:	98 2f       	mov	r25, r24
    20a4:	9c 70       	andi	r25, 0x0C	; 12
    20a6:	c9 f0       	breq	.+50     	; 0x20da <__vector_25+0x52>
TWI_MasterArbitrationLostBusErrorHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:394
 *  Handles TWI responses to lost arbitration and bus error.
 *
 */
void TWI_MasterArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWI0.MSTATUS;
    20a8:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:398

	/* If bus error. */
	if (currentStatus & TWI_BUSERR_bm) {
		master_result = TWIM_RESULT_BUS_ERROR;
    20ac:	94 e0       	ldi	r25, 0x04	; 4
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:397
void TWI_MasterArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWI0.MSTATUS;

	/* If bus error. */
	if (currentStatus & TWI_BUSERR_bm) {
    20ae:	82 ff       	sbrs	r24, 2
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:402
		master_result = TWIM_RESULT_BUS_ERROR;
	}
	/* If arbitration lost. */
	else {
		master_result = TWIM_RESULT_ARBITRATION_LOST;
    20b0:	93 e0       	ldi	r25, 0x03	; 3
    20b2:	90 93 1e 38 	sts	0x381E, r25	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:406
	}

	/* Clear all flags, abort operation */
	TWI0.MSTATUS = currentStatus;
    20b6:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:409

	/* Wait for a new operation */
	twi_mode = TWI_MODE_MASTER;
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	80 93 22 38 	sts	0x3822, r24	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:410
	master_trans_status = TWIM_STATUS_READY;
    20c0:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <master_trans_status>
__vector_25():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:770
	slave_trans_status = TWIM_STATUS_READY;
}

ISR(TWI0_TWIM_vect){
	TWI_MasterInterruptHandler();
}
    20c4:	ff 91       	pop	r31
    20c6:	ef 91       	pop	r30
    20c8:	9f 91       	pop	r25
    20ca:	8f 91       	pop	r24
    20cc:	3f 91       	pop	r19
    20ce:	2f 91       	pop	r18
    20d0:	0f 90       	pop	r0
    20d2:	0f be       	out	0x3f, r0	; 63
    20d4:	0f 90       	pop	r0
    20d6:	1f 90       	pop	r1
    20d8:	18 95       	reti
TWI_MasterInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:372

		TWI_MasterArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_WIF_bm) {
    20da:	86 ff       	sbrs	r24, 6
    20dc:	4c c0       	rjmp	.+152    	; 0x2176 <__vector_25+0xee>
TWI_MasterWriteHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:422
 *
 */
void TWI_MasterWriteHandler()
{
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = master_bytesToWrite;
    20de:	20 91 0c 38 	lds	r18, 0x380C	; 0x80380c <master_bytesToWrite>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:423
	uint8_t bytesToRead   = master_bytesToRead;
    20e2:	90 91 0e 38 	lds	r25, 0x380E	; 0x80380e <master_bytesToRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:426

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (TWI0.MSTATUS & TWI_RXACK_bm) {
    20e6:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
    20ea:	84 ff       	sbrs	r24, 4
    20ec:	10 c0       	rjmp	.+32     	; 0x210e <__vector_25+0x86>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:427
		if(master_sendStop){
    20ee:	80 91 0d 38 	lds	r24, 0x380D	; 0x80380d <master_sendStop>
    20f2:	88 23       	and	r24, r24
    20f4:	51 f0       	breq	.+20     	; 0x210a <__vector_25+0x82>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:428
			TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    20f6:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:430
		} else {
			TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    20f8:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <__TEXT_REGION_LENGTH__+0x700814>
TWI_MasterTransactionFinished():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:522
 *
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(uint8_t result)
{
	master_result = result;
    20fc:	85 e0       	ldi	r24, 0x05	; 5
    20fe:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:523
	master_trans_status = TWIM_STATUS_READY;
    2102:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <master_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:524
	twi_mode = TWI_MODE_MASTER;
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	31 c0       	rjmp	.+98     	; 0x216c <__vector_25+0xe4>
TWI_MasterWriteHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:430
	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (TWI0.MSTATUS & TWI_RXACK_bm) {
		if(master_sendStop){
			TWI0.MCTRLB = TWI_MCMD_STOP_gc;
		} else {
			TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    210a:	81 e0       	ldi	r24, 0x01	; 1
    210c:	f5 cf       	rjmp	.-22     	; 0x20f8 <__vector_25+0x70>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:437
		}
		TWI_MasterTransactionFinished(TWIM_RESULT_NACK_RECEIVED);
	}

	/* If more bytes to write, send data. */
	else if (master_bytesWritten < bytesToWrite) {
    210e:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <master_bytesWritten>
    2112:	82 17       	cp	r24, r18
    2114:	90 f4       	brcc	.+36     	; 0x213a <__vector_25+0xb2>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:438
		uint8_t data = master_writeData[master_bytesWritten];
    2116:	e0 91 20 38 	lds	r30, 0x3820	; 0x803820 <master_bytesWritten>
    211a:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <master_writeData>
    211e:	90 91 0b 38 	lds	r25, 0x380B	; 0x80380b <master_writeData+0x1>
    2122:	e8 0f       	add	r30, r24
    2124:	f9 2f       	mov	r31, r25
    2126:	f1 1d       	adc	r31, r1
    2128:	80 81       	ld	r24, Z
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:439
		TWI0.MDATA = data;
    212a:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <__TEXT_REGION_LENGTH__+0x700818>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:440
		master_bytesWritten++;
    212e:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <master_bytesWritten>
    2132:	8f 5f       	subi	r24, 0xFF	; 255
    2134:	80 93 20 38 	sts	0x3820, r24	; 0x803820 <master_bytesWritten>
    2138:	c5 cf       	rjmp	.-118    	; 0x20c4 <__vector_25+0x3c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:446
	}

	/* If bytes to read, send START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (master_bytesRead < bytesToRead) {
    213a:	80 91 21 38 	lds	r24, 0x3821	; 0x803821 <master_bytesRead>
    213e:	89 17       	cp	r24, r25
    2140:	48 f4       	brcc	.+18     	; 0x2154 <__vector_25+0xcc>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:447
		twi_mode = TWI_MODE_MASTER_RECEIVE;
    2142:	84 e0       	ldi	r24, 0x04	; 4
    2144:	80 93 22 38 	sts	0x3822, r24	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:448
		uint8_t readAddress = ADD_READ_BIT(master_slaveAddress);
    2148:	80 91 09 38 	lds	r24, 0x3809	; 0x803809 <master_slaveAddress>
    214c:	81 60       	ori	r24, 0x01	; 1
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:449
		TWI0.MADDR = readAddress;
    214e:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
    2152:	b8 cf       	rjmp	.-144    	; 0x20c4 <__vector_25+0x3c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:454
	}

	/* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
	else {
		if(master_sendStop){
    2154:	80 91 0d 38 	lds	r24, 0x380D	; 0x80380d <master_sendStop>
    2158:	88 23       	and	r24, r24
    215a:	59 f0       	breq	.+22     	; 0x2172 <__vector_25+0xea>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:455
			TWI0.MCTRLB = TWI_MCMD_STOP_gc;
    215c:	83 e0       	ldi	r24, 0x03	; 3
TWI_MasterReadHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:506
	/* If transaction finished, issue NACK and STOP condition if instructed. */
	else {
		if(master_sendStop){
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
		} else {
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    215e:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <__TEXT_REGION_LENGTH__+0x700814>
TWI_MasterTransactionFinished():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:522
 *
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(uint8_t result)
{
	master_result = result;
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:523
	master_trans_status = TWIM_STATUS_READY;
    2168:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <master_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:524
	twi_mode = TWI_MODE_MASTER;
    216c:	80 93 22 38 	sts	0x3822, r24	; 0x803822 <twi_mode>
    2170:	a9 cf       	rjmp	.-174    	; 0x20c4 <__vector_25+0x3c>
TWI_MasterWriteHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:457
	/* If transaction finished, send ACK/STOP condition if instructed and set RESULT OK. */
	else {
		if(master_sendStop){
			TWI0.MCTRLB = TWI_MCMD_STOP_gc;
		} else {
			TWI0.MCTRLB = TWI_MCMD_REPSTART_gc;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	f4 cf       	rjmp	.-24     	; 0x215e <__vector_25+0xd6>
TWI_MasterInterruptHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:377
	else if (currentStatus & TWI_WIF_bm) {
		TWI_MasterWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_RIF_bm) {
    2176:	87 ff       	sbrs	r24, 7
    2178:	3d c0       	rjmp	.+122    	; 0x21f4 <__vector_25+0x16c>
TWI_MasterReadHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:474
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler()
{
	/* Fetch data if bytes to be read. */
	if (master_bytesRead < master_bytesToRead) {
    217a:	90 91 21 38 	lds	r25, 0x3821	; 0x803821 <master_bytesRead>
    217e:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <master_bytesToRead>
    2182:	98 17       	cp	r25, r24
    2184:	d8 f4       	brcc	.+54     	; 0x21bc <__vector_25+0x134>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:475
		uint8_t data = TWI0.MDATA;
    2186:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <__TEXT_REGION_LENGTH__+0x700818>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:476
		master_readData[master_bytesRead] = data;
    218a:	e0 91 21 38 	lds	r30, 0x3821	; 0x803821 <master_bytesRead>
    218e:	20 91 a9 38 	lds	r18, 0x38A9	; 0x8038a9 <master_readData>
    2192:	30 91 aa 38 	lds	r19, 0x38AA	; 0x8038aa <master_readData+0x1>
    2196:	e2 0f       	add	r30, r18
    2198:	f3 2f       	mov	r31, r19
    219a:	f1 1d       	adc	r31, r1
    219c:	80 83       	st	Z, r24
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:477
		master_bytesRead++;
    219e:	80 91 21 38 	lds	r24, 0x3821	; 0x803821 <master_bytesRead>
    21a2:	8f 5f       	subi	r24, 0xFF	; 255
    21a4:	80 93 21 38 	sts	0x3821, r24	; 0x803821 <master_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:494
		master_bytesToRead = 0;
		return;
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = master_bytesToRead;
    21a8:	90 91 0e 38 	lds	r25, 0x380E	; 0x80380e <master_bytesToRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:497

	/* If more bytes to read, issue ACK and start a byte read. */
	if (master_bytesRead < bytesToRead) {
    21ac:	80 91 21 38 	lds	r24, 0x3821	; 0x803821 <master_bytesRead>
    21b0:	89 17       	cp	r24, r25
    21b2:	c0 f4       	brcc	.+48     	; 0x21e4 <__vector_25+0x15c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:498
		TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
    21b4:	82 e0       	ldi	r24, 0x02	; 2
    21b6:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <__TEXT_REGION_LENGTH__+0x700814>
    21ba:	84 cf       	rjmp	.-248    	; 0x20c4 <__vector_25+0x3c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:482
		master_bytesRead++;
	}

	/* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
	else {
		if(master_sendStop){
    21bc:	80 91 0d 38 	lds	r24, 0x380D	; 0x80380d <master_sendStop>
    21c0:	88 23       	and	r24, r24
    21c2:	71 f0       	breq	.+28     	; 0x21e0 <__vector_25+0x158>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:483
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    21c4:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:485
		} else {
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    21c6:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <__TEXT_REGION_LENGTH__+0x700814>
TWI_MasterTransactionFinished():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:522
 *
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(uint8_t result)
{
	master_result = result;
    21ca:	82 e0       	ldi	r24, 0x02	; 2
    21cc:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:523
	master_trans_status = TWIM_STATUS_READY;
    21d0:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <master_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:524
	twi_mode = TWI_MODE_MASTER;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	80 93 22 38 	sts	0x3822, r24	; 0x803822 <twi_mode>
TWI_MasterReadHandler():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:489
		} else {
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
		}

		TWI_MasterTransactionFinished(TWIM_RESULT_BUFFER_OVERFLOW);
		master_bytesToRead = 0;
    21da:	10 92 0e 38 	sts	0x380E, r1	; 0x80380e <master_bytesToRead>
    21de:	72 cf       	rjmp	.-284    	; 0x20c4 <__vector_25+0x3c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:485
	/* If buffer overflow, issue NACK/STOP and BUFFER_OVERFLOW condition. */
	else {
		if(master_sendStop){
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
		} else {
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    21e0:	85 e0       	ldi	r24, 0x05	; 5
    21e2:	f1 cf       	rjmp	.-30     	; 0x21c6 <__vector_25+0x13e>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:503
		TWI0.MCTRLB = TWI_MCMD_RECVTRANS_gc;
	}

	/* If transaction finished, issue NACK and STOP condition if instructed. */
	else {
		if(master_sendStop){
    21e4:	80 91 0d 38 	lds	r24, 0x380D	; 0x80380d <master_sendStop>
    21e8:	88 23       	and	r24, r24
    21ea:	11 f0       	breq	.+4      	; 0x21f0 <__vector_25+0x168>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:504
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;
    21ec:	87 e0       	ldi	r24, 0x07	; 7
    21ee:	b7 cf       	rjmp	.-146    	; 0x215e <__vector_25+0xd6>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:506
		} else {
			TWI0.MCTRLB = TWI_ACKACT_bm | TWI_MCMD_REPSTART_gc;
    21f0:	85 e0       	ldi	r24, 0x05	; 5
    21f2:	b5 cf       	rjmp	.-150    	; 0x215e <__vector_25+0xd6>
TWI_MasterTransactionFinished():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:522
 *
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(uint8_t result)
{
	master_result = result;
    21f4:	86 e0       	ldi	r24, 0x06	; 6
    21f6:	83 cf       	rjmp	.-250    	; 0x20fe <__vector_25+0x76>

000021f8 <global constructors keyed to 65535_0_I2Cdev.cpp.o.4086>:
_GLOBAL__I_65535_0_I2Cdev.cpp.o.4086():
    21f8:	e0 ef       	ldi	r30, 0xF0	; 240
    21fa:	f8 e3       	ldi	r31, 0x38	; 56
    21fc:	12 82       	std	Z+2, r1	; 0x02
    21fe:	13 82       	std	Z+3, r1	; 0x03
    2200:	48 ee       	ldi	r20, 0xE8	; 232
    2202:	53 e0       	ldi	r21, 0x03	; 3
    2204:	60 e0       	ldi	r22, 0x00	; 0
    2206:	70 e0       	ldi	r23, 0x00	; 0
    2208:	44 83       	std	Z+4, r20	; 0x04
    220a:	55 83       	std	Z+5, r21	; 0x05
    220c:	66 83       	std	Z+6, r22	; 0x06
    220e:	77 83       	std	Z+7, r23	; 0x07
    2210:	82 e1       	ldi	r24, 0x12	; 18
    2212:	9a eb       	ldi	r25, 0xBA	; 186
    2214:	80 83       	st	Z, r24
    2216:	91 83       	std	Z+1, r25	; 0x01
    2218:	80 e0       	ldi	r24, 0x00	; 0
    221a:	98 e0       	ldi	r25, 0x08	; 8
    221c:	84 87       	std	Z+12, r24	; 0x0c
    221e:	95 87       	std	Z+13, r25	; 0x0d
    2220:	94 e0       	ldi	r25, 0x04	; 4
    2222:	96 87       	std	Z+14, r25	; 0x0e
    2224:	85 e0       	ldi	r24, 0x05	; 5
    2226:	87 87       	std	Z+15, r24	; 0x0f
    2228:	10 8a       	std	Z+16, r1	; 0x10
    222a:	29 e0       	ldi	r18, 0x09	; 9
    222c:	21 8b       	std	Z+17, r18	; 0x11
    222e:	28 e0       	ldi	r18, 0x08	; 8
    2230:	22 8b       	std	Z+18, r18	; 0x12
    2232:	21 e0       	ldi	r18, 0x01	; 1
    2234:	23 8b       	std	Z+19, r18	; 0x13
    2236:	14 8a       	std	Z+20, r1	; 0x14
    2238:	15 8a       	std	Z+21, r1	; 0x15
    223a:	16 8a       	std	Z+22, r1	; 0x16
    223c:	17 8a       	std	Z+23, r1	; 0x17
    223e:	10 8e       	std	Z+24, r1	; 0x18
    2240:	11 8e       	std	Z+25, r1	; 0x19
    2242:	2c e1       	ldi	r18, 0x1C	; 28
    2244:	22 8f       	std	Z+26, r18	; 0x1a
    2246:	13 8e       	std	Z+27, r1	; 0x1b
    2248:	14 8e       	std	Z+28, r1	; 0x1c
    224a:	e9 ea       	ldi	r30, 0xA9	; 169
    224c:	f9 e3       	ldi	r31, 0x39	; 57
    224e:	91 83       	std	Z+1, r25	; 0x01
    2250:	91 e2       	ldi	r25, 0x21	; 33
    2252:	90 83       	st	Z, r25
    2254:	10 92 92 39 	sts	0x3992, r1	; 0x803992 <SPI+0x5>
    2258:	eb ea       	ldi	r30, 0xAB	; 171
    225a:	f9 e3       	ldi	r31, 0x39	; 57
    225c:	12 82       	std	Z+2, r1	; 0x02
    225e:	13 82       	std	Z+3, r1	; 0x03
    2260:	44 83       	std	Z+4, r20	; 0x04
    2262:	55 83       	std	Z+5, r21	; 0x05
    2264:	66 83       	std	Z+6, r22	; 0x06
    2266:	77 83       	std	Z+7, r23	; 0x07
    2268:	2c e2       	ldi	r18, 0x2C	; 44
    226a:	3a eb       	ldi	r19, 0xBA	; 186
    226c:	20 83       	st	Z, r18
    226e:	31 83       	std	Z+1, r19	; 0x01
    2270:	e8 ef       	ldi	r30, 0xF8	; 248
    2272:	f9 e3       	ldi	r31, 0x39	; 57
    2274:	10 82       	st	Z, r1
    2276:	11 82       	std	Z+1, r1	; 0x01
    2278:	21 e0       	ldi	r18, 0x01	; 1
    227a:	30 e0       	ldi	r19, 0x00	; 0
    227c:	22 83       	std	Z+2, r18	; 0x02
    227e:	33 83       	std	Z+3, r19	; 0x03
    2280:	16 82       	std	Z+6, r1	; 0x06
    2282:	90 e2       	ldi	r25, 0x20	; 32
    2284:	97 83       	std	Z+7, r25	; 0x07
    2286:	10 86       	std	Z+8, r1	; 0x08
    2288:	86 87       	std	Z+14, r24	; 0x0e
    228a:	85 e0       	ldi	r24, 0x05	; 5
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	a0 e0       	ldi	r26, 0x00	; 0
    2290:	b0 e0       	ldi	r27, 0x00	; 0
    2292:	84 8b       	std	Z+20, r24	; 0x14
    2294:	95 8b       	std	Z+21, r25	; 0x15
    2296:	a6 8b       	std	Z+22, r26	; 0x16
    2298:	b7 8b       	std	Z+23, r27	; 0x17
    229a:	11 86       	std	Z+9, r1	; 0x09
    229c:	88 e6       	ldi	r24, 0x68	; 104
    229e:	80 93 e5 39 	sts	0x39E5, r24	; 0x8039e5 <mpu>
    22a2:	e5 ed       	ldi	r30, 0xD5	; 213
    22a4:	f9 e3       	ldi	r31, 0x39	; 57
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	a0 e8       	ldi	r26, 0x80	; 128
    22ac:	bf e3       	ldi	r27, 0x3F	; 63
    22ae:	80 83       	st	Z, r24
    22b0:	91 83       	std	Z+1, r25	; 0x01
    22b2:	a2 83       	std	Z+2, r26	; 0x02
    22b4:	b3 83       	std	Z+3, r27	; 0x03
    22b6:	14 82       	std	Z+4, r1	; 0x04
    22b8:	15 82       	std	Z+5, r1	; 0x05
    22ba:	16 82       	std	Z+6, r1	; 0x06
    22bc:	17 82       	std	Z+7, r1	; 0x07
    22be:	10 86       	std	Z+8, r1	; 0x08
    22c0:	11 86       	std	Z+9, r1	; 0x09
    22c2:	12 86       	std	Z+10, r1	; 0x0a
    22c4:	13 86       	std	Z+11, r1	; 0x0b
    22c6:	14 86       	std	Z+12, r1	; 0x0c
    22c8:	15 86       	std	Z+13, r1	; 0x0d
    22ca:	16 86       	std	Z+14, r1	; 0x0e
    22cc:	17 86       	std	Z+15, r1	; 0x0f
    22ce:	ef ec       	ldi	r30, 0xCF	; 207
    22d0:	f9 e3       	ldi	r31, 0x39	; 57
    22d2:	10 82       	st	Z, r1
    22d4:	11 82       	std	Z+1, r1	; 0x01
    22d6:	12 82       	std	Z+2, r1	; 0x02
    22d8:	13 82       	std	Z+3, r1	; 0x03
    22da:	14 82       	std	Z+4, r1	; 0x04
    22dc:	15 82       	std	Z+5, r1	; 0x05
    22de:	e9 ec       	ldi	r30, 0xC9	; 201
    22e0:	f9 e3       	ldi	r31, 0x39	; 57
    22e2:	10 82       	st	Z, r1
    22e4:	11 82       	std	Z+1, r1	; 0x01
    22e6:	12 82       	std	Z+2, r1	; 0x02
    22e8:	13 82       	std	Z+3, r1	; 0x03
    22ea:	14 82       	std	Z+4, r1	; 0x04
    22ec:	15 82       	std	Z+5, r1	; 0x05
    22ee:	e3 ec       	ldi	r30, 0xC3	; 195
    22f0:	f9 e3       	ldi	r31, 0x39	; 57
    22f2:	10 82       	st	Z, r1
    22f4:	11 82       	std	Z+1, r1	; 0x01
    22f6:	12 82       	std	Z+2, r1	; 0x02
    22f8:	13 82       	std	Z+3, r1	; 0x03
    22fa:	14 82       	std	Z+4, r1	; 0x04
    22fc:	15 82       	std	Z+5, r1	; 0x05
    22fe:	e7 eb       	ldi	r30, 0xB7	; 183
    2300:	f9 e3       	ldi	r31, 0x39	; 57
    2302:	10 82       	st	Z, r1
    2304:	11 82       	std	Z+1, r1	; 0x01
    2306:	12 82       	std	Z+2, r1	; 0x02
    2308:	13 82       	std	Z+3, r1	; 0x03
    230a:	14 82       	std	Z+4, r1	; 0x04
    230c:	15 82       	std	Z+5, r1	; 0x05
    230e:	16 82       	std	Z+6, r1	; 0x06
    2310:	17 82       	std	Z+7, r1	; 0x07
    2312:	10 86       	std	Z+8, r1	; 0x08
    2314:	11 86       	std	Z+9, r1	; 0x09
    2316:	12 86       	std	Z+10, r1	; 0x0a
    2318:	13 86       	std	Z+11, r1	; 0x0b
    231a:	08 95       	ret

0000231c <main>:
main():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/main.cpp:34

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
    2320:	cd b7       	in	r28, 0x3d	; 61
    2322:	de b7       	in	r29, 0x3e	; 62
    2324:	c1 54       	subi	r28, 0x41	; 65
    2326:	d1 09       	sbc	r29, r1
    2328:	cd bf       	out	0x3d, r28	; 61
    232a:	de bf       	out	0x3e, r29	; 62
init():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:552
    /* No division on clock */
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);

  #elif (F_CPU == 10000000) //20MHz prescaled by 2
    /* Clock DIV2 */
    _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, (CLKCTRL_PEN_bm | CLKCTRL_PDIV_2X_gc));
    232c:	11 e0       	ldi	r17, 0x01	; 1
    232e:	88 ed       	ldi	r24, 0xD8	; 216
    2330:	84 bf       	out	0x34, r24	; 52
    2332:	10 93 61 00 	sts	0x0061, r17	; 0x800061 <__TEXT_REGION_LENGTH__+0x700061>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:594
      compensate for this! */

      #if F_CPU >= 12000000 // 16 MHz / 16 = 1 MHz,  20 MHz / 16 = 1.25 MHz
        ADC0.CTRLC |= ADC_PRESC_DIV16_gc;
      #elif F_CPU >= 6000000 // 8 MHz / 8 = 1 MHz, 10 MHz / 64 = 1.25 MHz
        ADC0.CTRLC |= ADC_PRESC_DIV8_gc;
    2336:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <__TEXT_REGION_LENGTH__+0x700602>
    233a:	82 60       	ori	r24, 0x02	; 2
    233c:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x700602>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:600
      #elif F_CPU >= 3000000 // 4 MHz / 32 = 1 MHz, 5 MHz / 32 = 1.25 MHz
        ADC0.CTRLC |= ADC_PRESC_DIV4_gc;
      #else  // 1 MHz / 2 = 500 kHz - the lowest setting
        ADC0.CTRLC |= ADC_PRESC_DIV2_gc;
      #endif
      ADC0.SAMPCTRL=14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
    2340:	8e e0       	ldi	r24, 0x0E	; 14
    2342:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:619
        ADC0.CTRLC |= ADC_PRESC_DIV2_gc;
      #endif
    #endif

    /* Enable ADC */
    ADC0.CTRLA |= ADC_ENABLE_bm;
    2346:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
    234a:	81 60       	ori	r24, 0x01	; 1
    234c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
analogReference():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_analog.c:39
		case EXTERNAL:
	#elif defined(EXTERNAL_EXPERIMENTAL)
		case EXTERNAL_EXPERIMENTAL:
	#endif
		case VDD:
			ADC0.CTRLC = (ADC0.CTRLC & ~(ADC_REFSEL_gm)) | mode | ADC_SAMPCAP_bm; //per datasheet, recommended SAMPCAP=1 at ref > 1v - we don't *KNOW* the external reference will be >1v, but it's probably more likely...
    2350:	80 91 02 06 	lds	r24, 0x0602	; 0x800602 <__TEXT_REGION_LENGTH__+0x700602>
    2354:	8f 7c       	andi	r24, 0xCF	; 207
    2356:	80 65       	ori	r24, 0x50	; 80
    2358:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x700602>
setup_timers():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:645

    /* PORTMUX setting for TCA - don't need to set because using default */
    //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

    /* Enable Split Mode */
    TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    235c:	10 93 03 0a 	sts	0x0A03, r17	; 0x800a03 <__TEXT_REGION_LENGTH__+0x700a03>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:650

    //Only 1 WGM so no need to specifically set up.

    /* Period setting, 8-bit register in SPLIT mode */
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    2360:	8e ef       	ldi	r24, 0xFE	; 254
    2362:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x700a26>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:651
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    2366:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x700a27>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:655

    /* Default duty 50%, will re-assign in analogWrite() */
    //TODO: replace with for loop to make this smaller;
    TCA0.SPLIT.LCMP0 = PWM_TIMER_COMPARE;
    236a:	80 e8       	ldi	r24, 0x80	; 128
    236c:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:656
    TCA0.SPLIT.LCMP1 = PWM_TIMER_COMPARE;
    2370:	80 93 2a 0a 	sts	0x0A2A, r24	; 0x800a2a <__TEXT_REGION_LENGTH__+0x700a2a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:657
    TCA0.SPLIT.LCMP2 = PWM_TIMER_COMPARE;
    2374:	80 93 2c 0a 	sts	0x0A2C, r24	; 0x800a2c <__TEXT_REGION_LENGTH__+0x700a2c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:658
    TCA0.SPLIT.HCMP0 = PWM_TIMER_COMPARE;
    2378:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:659
    TCA0.SPLIT.HCMP1 = PWM_TIMER_COMPARE;
    237c:	80 93 2b 0a 	sts	0x0A2B, r24	; 0x800a2b <__TEXT_REGION_LENGTH__+0x700a2b>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:660
    TCA0.SPLIT.HCMP2 = PWM_TIMER_COMPARE;
    2380:	80 93 2d 0a 	sts	0x0A2D, r24	; 0x800a2d <__TEXT_REGION_LENGTH__+0x700a2d>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:664

    /* Use DIV64 prescaler (giving 250kHz clock), enable TCA timer */
  #if (F_CPU > 5000000) //use 64 divider
    TCA0.SPLIT.CTRLA = (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SINGLE_ENABLE_bm);
    2384:	9b e0       	ldi	r25, 0x0B	; 11
    2386:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
init_millis():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:487
  void init_millis()
  {
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR=TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
    238a:	2d ef       	ldi	r18, 0xFD	; 253
    238c:	31 e0       	ldi	r19, 0x01	; 1
    238e:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <__TEXT_REGION_LENGTH__+0x700aae>
    2392:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <__TEXT_REGION_LENGTH__+0x700aaf>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:488
      TCD0.INTCTRL=0x01;//enable interrupt
    2396:	10 93 8c 0a 	sts	0x0A8C, r17	; 0x800a8c <__TEXT_REGION_LENGTH__+0x700a8c>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:489
      TCD0.CTRLB=0x00; //oneramp mode
    239a:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <__TEXT_REGION_LENGTH__+0x700a81>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:490
      TCD0.CTRLC=0x80;
    239e:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <__TEXT_REGION_LENGTH__+0x700a82>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:491
      TCD0.CTRLA=TIMERD0_PRESCALER|0x01; //set clock source and enable!
    23a2:	81 e1       	ldi	r24, 0x11	; 17
    23a4:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <__TEXT_REGION_LENGTH__+0x700a80>
init():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring.c:634
  #ifndef DISABLEMILLIS
  init_millis();
  #endif //end #ifndef DISABLEMILLIS
/*************************** ENABLE GLOBAL INTERRUPTS *************************/

  sei();
    23a8:	78 94       	sei
begin():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:160
  return false;
}

void TwoWire::begin(void)
{
  rxBufferIndex = 0;
    23aa:	10 92 ac 38 	sts	0x38AC, r1	; 0x8038ac <TwoWire::rxBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:161
  rxBufferLength = 0;
    23ae:	10 92 ab 38 	sts	0x38AB, r1	; 0x8038ab <TwoWire::rxBufferLength>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:163

  txBufferIndex = 0;
    23b2:	10 92 cd 38 	sts	0x38CD, r1	; 0x8038cd <TwoWire::txBufferIndex>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src/Wire.cpp:164
  txBufferLength = 0;
    23b6:	10 92 ef 38 	sts	0x38EF, r1	; 0x8038ef <TwoWire::txBufferLength>
TWI_MasterInit():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:65
 *
 *  \param frequency				    The required baud.
 */
void TWI_MasterInit(uint32_t frequency)
{
	if(twi_mode != TWI_MODE_UNKNOWN) return;
    23ba:	80 91 22 38 	lds	r24, 0x3822	; 0x803822 <twi_mode>
    23be:	81 11       	cpse	r24, r1
    23c0:	1a c0       	rjmp	.+52     	; 0x23f6 <main+0xda>
pinMode():
    23c2:	62 e0       	ldi	r22, 0x02	; 2
    23c4:	86 e0       	ldi	r24, 0x06	; 6
    23c6:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
    23ca:	62 e0       	ldi	r22, 0x02	; 2
    23cc:	87 e0       	ldi	r24, 0x07	; 7
    23ce:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
TWI_MasterInit():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:77
/* This is done in wiring.c if this is needed for the part.
#if defined(TWISPIROUTEA)
	PORTMUX.TWISPIROUTEA |= TWI_MUX;
#endif
*/
	twi_mode = TWI_MODE_MASTER;
    23d2:	10 93 22 38 	sts	0x3822, r17	; 0x803822 <twi_mode>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:79

	master_bytesRead = 0;
    23d6:	10 92 21 38 	sts	0x3821, r1	; 0x803821 <master_bytesRead>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:80
	master_bytesWritten = 0;
    23da:	10 92 20 38 	sts	0x3820, r1	; 0x803820 <master_bytesWritten>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:81
	master_trans_status = TWIM_STATUS_READY;
    23de:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <master_trans_status>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:82
	master_result = TWIM_RESULT_UNKNOWN;
    23e2:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <master_result>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:84

	TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
    23e6:	81 ec       	ldi	r24, 0xC1	; 193
    23e8:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <__TEXT_REGION_LENGTH__+0x700813>
TWI_MasterSetBaud():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:211
		freq_khz = 100;
		t_rise = 1000;
	}

	uint32_t baud = ((F_CPU/1000/freq_khz) - (((F_CPU*t_rise)/1000)/1000)/1000 - 10)/2;
	TWI0.MBAUD = (uint8_t)baud;
    23ec:	88 e2       	ldi	r24, 0x28	; 40
    23ee:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <__TEXT_REGION_LENGTH__+0x700816>
TWI_MasterInit():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\Wire\src\utility/twi.c:86
	master_trans_status = TWIM_STATUS_READY;
	master_result = TWIM_RESULT_UNKNOWN;

	TWI0.MCTRLA = TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm;
	TWI_MasterSetBaud(frequency);
	TWI0.MSTATUS = TWI_BUSSTATE_IDLE_gc;
    23f2:	10 93 15 08 	sts	0x0815, r17	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
setup():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:83

void setup() {
  Wire.begin();
  Serial.begin(9600);
    23f6:	40 e8       	ldi	r20, 0x80	; 128
    23f8:	55 e2       	ldi	r21, 0x25	; 37
    23fa:	60 e0       	ldi	r22, 0x00	; 0
    23fc:	70 e0       	ldi	r23, 0x00	; 0
    23fe:	80 ef       	ldi	r24, 0xF0	; 240
    2400:	98 e3       	ldi	r25, 0x38	; 56
    2402:	0e 94 03 09 	call	0x1206	; 0x1206 <UartClass::begin(unsigned long)>
pinMode():
    2406:	62 e0       	ldi	r22, 0x02	; 2
    2408:	83 e0       	ldi	r24, 0x03	; 3
    240a:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
    240e:	61 e0       	ldi	r22, 0x01	; 1
    2410:	84 e0       	ldi	r24, 0x04	; 4
    2412:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
digitalWrite():
    2416:	60 e0       	ldi	r22, 0x00	; 0
    2418:	84 e0       	ldi	r24, 0x04	; 4
    241a:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
setClockSource():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2536
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */
void MPU6050::setClockSource(uint8_t source) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
    241e:	01 e0       	ldi	r16, 0x01	; 1
    2420:	23 e0       	ldi	r18, 0x03	; 3
    2422:	42 e0       	ldi	r20, 0x02	; 2
    2424:	6b e6       	ldi	r22, 0x6B	; 107
    2426:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    242a:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setFullScaleGyroRange():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:246
 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */
void MPU6050::setFullScaleGyroRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
    242e:	00 e0       	ldi	r16, 0x00	; 0
    2430:	22 e0       	ldi	r18, 0x02	; 2
    2432:	44 e0       	ldi	r20, 0x04	; 4
    2434:	6b e1       	ldi	r22, 0x1B	; 27
    2436:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    243a:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setFullScaleAccelRange():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:380
/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
void MPU6050::setFullScaleAccelRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);
    243e:	22 e0       	ldi	r18, 0x02	; 2
    2440:	44 e0       	ldi	r20, 0x04	; 4
    2442:	6c e1       	ldi	r22, 0x1C	; 28
    2444:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2448:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setSleepEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2443
 * @see getSleepEnabled()
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_SLEEP_BIT
 */
void MPU6050::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	46 e0       	ldi	r20, 0x06	; 6
    2450:	6b e6       	ldi	r22, 0x6B	; 107
    2452:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2456:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return readBytes(devAddr, regAddr, 1, data, timeout);
    245a:	08 ee       	ldi	r16, 0xE8	; 232
    245c:	13 e0       	ldi	r17, 0x03	; 3
    245e:	9e 01       	movw	r18, r28
    2460:	2f 5f       	subi	r18, 0xFF	; 255
    2462:	3f 4f       	sbci	r19, 0xFF	; 255
    2464:	41 e0       	ldi	r20, 0x01	; 1
    2466:	65 e7       	ldi	r22, 0x75	; 117
    2468:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    246c:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
readBits():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:146
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    uint8_t count, b;
    if ((count = readByte(devAddr, regAddr, &b, timeout)) != 0) {
    2470:	88 23       	and	r24, r24
    2472:	39 f0       	breq	.+14     	; 0x2482 <main+0x166>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:148
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        b &= mask;
    2474:	89 81       	ldd	r24, Y+1	; 0x01
    2476:	8e 77       	andi	r24, 0x7E	; 126
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:149
        b >>= (bitStart - length + 1);
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	95 95       	asr	r25
    247c:	87 95       	ror	r24
    247e:	80 93 e6 39 	sts	0x39E6, r24	; 0x8039e6 <mpu+0x1>
mpuInit():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:55
}

//Inicjalizacja MPU
void mpuInit() {
  mpu.initialize();
  if (mpu.testConnection() != true) Serial.println("Blad polaczenia z MPU"); 
    2482:	80 91 e6 39 	lds	r24, 0x39E6	; 0x8039e6 <mpu+0x1>
    2486:	84 33       	cpi	r24, 0x34	; 52
    2488:	21 f0       	breq	.+8      	; 0x2492 <main+0x176>
    248a:	8b e3       	ldi	r24, 0x3B	; 59
    248c:	9a eb       	ldi	r25, 0xBA	; 186
    248e:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <Print::println(char const*) [clone .constprop.30]>
reset():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2419
 * A small delay of ~50ms may be desirable after triggering a reset.
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_DEVICE_RESET_BIT
 */
void MPU6050::reset() {
    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, true);
    2492:	21 e0       	ldi	r18, 0x01	; 1
    2494:	47 e0       	ldi	r20, 0x07	; 7
    2496:	6b e6       	ldi	r22, 0x6B	; 107
    2498:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    249c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:280
// I Simplified this:
uint8_t MPU6050::dmpInitialize() {
	// reset device
	DEBUG_PRINTLN(F("\n\nResetting MPU6050..."));
	reset();
	delay(30); // wait after reset
    24a0:	6e e1       	ldi	r22, 0x1E	; 30
    24a2:	70 e0       	ldi	r23, 0x00	; 0
    24a4:	80 e0       	ldi	r24, 0x00	; 0
    24a6:	90 e0       	ldi	r25, 0x00	; 0
    24a8:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <delay>
setSleepEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2443
 * @see getSleepEnabled()
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_SLEEP_BIT
 */
void MPU6050::setSleepEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);
    24ac:	20 e0       	ldi	r18, 0x00	; 0
    24ae:	46 e0       	ldi	r20, 0x06	; 6
    24b0:	6b e6       	ldi	r22, 0x6B	; 107
    24b2:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    24b6:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
setMemoryBank():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3027

void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
    24ba:	40 e7       	ldi	r20, 0x70	; 112
    24bc:	6d e6       	ldi	r22, 0x6D	; 109
    24be:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    24c2:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setMemoryStartAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3033
}

// MEM_START_ADDR register

void MPU6050::setMemoryStartAddress(uint8_t address) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);
    24c6:	46 e0       	ldi	r20, 0x06	; 6
    24c8:	6e e6       	ldi	r22, 0x6E	; 110
    24ca:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    24ce:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:294
	setSleepEnabled(false);

	// get MPU hardware revision
	setMemoryBank(0x10, true, true);
	setMemoryStartAddress(0x06);
	Serial.println(F("Checking hardware revision..."));
    24d2:	81 e5       	ldi	r24, 0x51	; 81
    24d4:	9a eb       	ldi	r25, 0xBA	; 186
    24d6:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <Print::println(char const*) [clone .constprop.30]>
write():
    24da:	8f e6       	ldi	r24, 0x6F	; 111
    24dc:	9a eb       	ldi	r25, 0xBA	; 186
    24de:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return readBytes(devAddr, regAddr, 1, data, timeout);
    24e2:	08 ee       	ldi	r16, 0xE8	; 232
    24e4:	13 e0       	ldi	r17, 0x03	; 3
    24e6:	26 ee       	ldi	r18, 0xE6	; 230
    24e8:	39 e3       	ldi	r19, 0x39	; 57
    24ea:	41 e0       	ldi	r20, 0x01	; 1
    24ec:	6f e6       	ldi	r22, 0x6F	; 111
    24ee:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    24f2:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
print():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:73
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    24f6:	40 91 e6 39 	lds	r20, 0x39E6	; 0x8039e6 <mpu+0x1>
    24fa:	50 e0       	ldi	r21, 0x00	; 0
    24fc:	70 e0       	ldi	r23, 0x00	; 0
    24fe:	60 e0       	ldi	r22, 0x00	; 0
printNumber():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:236
size_t Print::printNumber(unsigned long n, uint8_t base)
{
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    2500:	19 a2       	std	Y+33, r1	; 0x21
    2502:	ce 01       	movw	r24, r28
    2504:	81 96       	adiw	r24, 0x21	; 33
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:242

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    2506:	8a 01       	movw	r16, r20
    2508:	9b 01       	movw	r18, r22
    250a:	0f 70       	andi	r16, 0x0F	; 15
    250c:	11 27       	eor	r17, r17
    250e:	22 27       	eor	r18, r18
    2510:	33 27       	eor	r19, r19
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:243
    n /= base;
    2512:	24 e0       	ldi	r18, 0x04	; 4
    2514:	76 95       	lsr	r23
    2516:	67 95       	ror	r22
    2518:	57 95       	ror	r21
    251a:	47 95       	ror	r20
    251c:	2a 95       	dec	r18
    251e:	d1 f7       	brne	.-12     	; 0x2514 <main+0x1f8>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:245

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    2520:	0a 30       	cpi	r16, 0x0A	; 10
    2522:	0c f0       	brlt	.+2      	; 0x2526 <main+0x20a>
    2524:	85 c6       	rjmp	.+3338   	; 0x3230 <main+0xf14>
    2526:	00 5d       	subi	r16, 0xD0	; 208
    2528:	dc 01       	movw	r26, r24
    252a:	0e 93       	st	-X, r16
    252c:	cd 01       	movw	r24, r26
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:246
  } while(n);
    252e:	41 15       	cp	r20, r1
    2530:	51 05       	cpc	r21, r1
    2532:	61 05       	cpc	r22, r1
    2534:	71 05       	cpc	r23, r1
    2536:	39 f7       	brne	.-50     	; 0x2506 <main+0x1ea>
write():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.h:48
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    2538:	ab 2b       	or	r26, r27
    253a:	11 f0       	breq	.+4      	; 0x2540 <main+0x224>
    253c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>
    2540:	88 e3       	ldi	r24, 0x38	; 56
    2542:	9a eb       	ldi	r25, 0xBA	; 186
    2544:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <Print::write(char const*) [clone .part.2] [clone .constprop.33]>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:297
	Serial.print(F("Revision @ user[16][6] = "));
	Serial.println(readMemoryByte(), HEX);
	Serial.println(F("Resetting memory bank selection to 0..."));
    2548:	89 e8       	ldi	r24, 0x89	; 137
    254a:	9a eb       	ldi	r25, 0xBA	; 186
    254c:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <Print::println(char const*) [clone .constprop.30]>
setMemoryBank():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3027

void MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);
    2550:	40 e0       	ldi	r20, 0x00	; 0
    2552:	6d e6       	ldi	r22, 0x6D	; 109
    2554:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2558:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setSlaveAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:965
 * @see getSlaveAddress()
 * @see MPU6050_RA_I2C_SLV0_ADDR
 */
void MPU6050::setSlaveAddress(uint8_t num, uint8_t address) {
    if (num > 3) return;
    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);
    255c:	4f e7       	ldi	r20, 0x7F	; 127
    255e:	65 e2       	ldi	r22, 0x25	; 37
    2560:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2564:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setI2CMasterModeEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2368
 * @see getI2CMasterModeEnabled()
 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_I2C_MST_EN_BIT
 */
void MPU6050::setI2CMasterModeEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);
    2568:	20 e0       	ldi	r18, 0x00	; 0
    256a:	45 e0       	ldi	r20, 0x05	; 5
    256c:	6a e6       	ldi	r22, 0x6A	; 106
    256e:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2572:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
setSlaveAddress():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:965
 * @see getSlaveAddress()
 * @see MPU6050_RA_I2C_SLV0_ADDR
 */
void MPU6050::setSlaveAddress(uint8_t num, uint8_t address) {
    if (num > 3) return;
    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);
    2576:	48 e6       	ldi	r20, 0x68	; 104
    2578:	65 e2       	ldi	r22, 0x25	; 37
    257a:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    257e:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
resetI2CMaster():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2393
 * This bit automatically clears to 0 after the reset has been triggered.
 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT
 */
void MPU6050::resetI2CMaster() {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, true);
    2582:	21 e0       	ldi	r18, 0x01	; 1
    2584:	41 e0       	ldi	r20, 0x01	; 1
    2586:	6a e6       	ldi	r22, 0x6A	; 106
    2588:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    258c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:314
	setI2CMasterModeEnabled(false);
	DEBUG_PRINTLN(F("Setting slave 0 address to 0x68 (self)..."));
	setSlaveAddress(0, 0x68);
	DEBUG_PRINTLN(F("Resetting I2C Master control..."));
	resetI2CMaster();
	delay(20);
    2590:	64 e1       	ldi	r22, 0x14	; 20
    2592:	70 e0       	ldi	r23, 0x00	; 0
    2594:	80 e0       	ldi	r24, 0x00	; 0
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <delay>
setClockSource():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2536
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */
void MPU6050::setClockSource(uint8_t source) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
    259c:	03 e0       	ldi	r16, 0x03	; 3
    259e:	23 e0       	ldi	r18, 0x03	; 3
    25a0:	42 e0       	ldi	r20, 0x02	; 2
    25a2:	6b e6       	ldi	r22, 0x6B	; 107
    25a4:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25a8:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setIntEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:1551
 * @see getIntFreefallEnabled()
 * @see MPU6050_RA_INT_ENABLE
 * @see MPU6050_INTERRUPT_FF_BIT
 **/
void MPU6050::setIntEnabled(uint8_t enabled) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, enabled);
    25ac:	42 e1       	ldi	r20, 0x12	; 18
    25ae:	68 e3       	ldi	r22, 0x38	; 56
    25b0:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25b4:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setRate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:126
 * @param rate New sample rate divider
 * @see getRate()
 * @see MPU6050_RA_SMPLRT_DIV
 */
void MPU6050::setRate(uint8_t rate) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_SMPLRT_DIV, rate);
    25b8:	44 e0       	ldi	r20, 0x04	; 4
    25ba:	69 e1       	ldi	r22, 0x19	; 25
    25bc:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25c0:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setExternalFrameSync():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:168
 * @see getExternalFrameSync()
 * @see MPU6050_RA_CONFIG
 * @param sync New FSYNC configuration value
 */
void MPU6050::setExternalFrameSync(uint8_t sync) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync);
    25c4:	01 e0       	ldi	r16, 0x01	; 1
    25c6:	23 e0       	ldi	r18, 0x03	; 3
    25c8:	45 e0       	ldi	r20, 0x05	; 5
    25ca:	6a e1       	ldi	r22, 0x1A	; 26
    25cc:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25d0:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setDLPFMode():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:211
 * @see MPU6050_RA_CONFIG
 * @see MPU6050_CFG_DLPF_CFG_BIT
 * @see MPU6050_CFG_DLPF_CFG_LENGTH
 */
void MPU6050::setDLPFMode(uint8_t mode) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
    25d4:	03 e0       	ldi	r16, 0x03	; 3
    25d6:	23 e0       	ldi	r18, 0x03	; 3
    25d8:	42 e0       	ldi	r20, 0x02	; 2
    25da:	6a e1       	ldi	r22, 0x1A	; 26
    25dc:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25e0:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
setFullScaleGyroRange():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:246
 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */
void MPU6050::setFullScaleGyroRange(uint8_t range) {
    I2Cdev::writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
    25e4:	22 e0       	ldi	r18, 0x02	; 2
    25e6:	44 e0       	ldi	r20, 0x04	; 4
    25e8:	6b e1       	ldi	r22, 0x1B	; 27
    25ea:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    25ee:	0e 94 1d 0a 	call	0x143a	; 0x143a <I2Cdev::writeBits(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
writeProgMemoryBlock():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3153
    if (verify) free(verifyBuffer);
    if (useProgMem) free(progBuffer);
    return true;
}
bool MPU6050::writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {
    return writeMemoryBlock(data, dataSize, bank, address, verify, true);
    25f2:	01 e0       	ldi	r16, 0x01	; 1
    25f4:	20 e0       	ldi	r18, 0x00	; 0
    25f6:	40 e0       	ldi	r20, 0x00	; 0
    25f8:	69 e8       	ldi	r22, 0x89	; 137
    25fa:	77 e0       	ldi	r23, 0x07	; 7
    25fc:	8c e7       	ldi	r24, 0x7C	; 124
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	0e 94 a2 0a 	call	0x1544	; 0x1544 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:337

	// load DMP code into memory banks
	DEBUG_PRINT(F("Writing DMP code to MPU memory banks ("));
	DEBUG_PRINT(MPU6050_DMP_CODE_SIZE);
	DEBUG_PRINTLN(F(" bytes)"));
	if (!writeProgMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE)) return 1; // Failed
    2604:	88 23       	and	r24, r24
    2606:	09 f4       	brne	.+2      	; 0x260a <main+0x2ee>
    2608:	8b c0       	rjmp	.+278    	; 0x2720 <main+0x404>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:341
	DEBUG_PRINTLN(F("Success! DMP code written and verified."));

	// Set the FIFO Rate Divisor int the DMP Firmware Memory
	unsigned char dmpUpdate[] = {0x00, MPU6050_DMP_FIFO_RATE_DIVISOR};
    260a:	19 82       	std	Y+1, r1	; 0x01
    260c:	81 e0       	ldi	r24, 0x01	; 1
    260e:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:342
	writeMemoryBlock(dmpUpdate, 0x02, 0x02, 0x16); // Lets write the dmpUpdate data to the Firmware image, we have 2 bytes to write in bank 0x02 with the Offset 0x16
    2610:	00 e0       	ldi	r16, 0x00	; 0
    2612:	26 e1       	ldi	r18, 0x16	; 22
    2614:	42 e0       	ldi	r20, 0x02	; 2
    2616:	62 e0       	ldi	r22, 0x02	; 2
    2618:	70 e0       	ldi	r23, 0x00	; 0
    261a:	ce 01       	movw	r24, r28
    261c:	01 96       	adiw	r24, 0x01	; 1
    261e:	0e 94 a2 0a 	call	0x1544	; 0x1544 <MPU6050::writeMemoryBlock(unsigned char const*, unsigned int, unsigned char, unsigned char, bool, bool) [clone .constprop.80]>
setDMPConfig1():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3242
uint8_t MPU6050::getDMPConfig1() {
    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_1, buffer);
    return buffer[0];
}
void MPU6050::setDMPConfig1(uint8_t config) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_1, config);
    2622:	43 e0       	ldi	r20, 0x03	; 3
    2624:	60 e7       	ldi	r22, 0x70	; 112
    2626:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    262a:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setDMPConfig2():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3252
uint8_t MPU6050::getDMPConfig2() {
    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_2, buffer);
    return buffer[0];
}
void MPU6050::setDMPConfig2(uint8_t config) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_2, config);
    262e:	40 e0       	ldi	r20, 0x00	; 0
    2630:	61 e7       	ldi	r22, 0x71	; 113
    2632:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2636:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setOTPBankValid():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2827
uint8_t MPU6050::getOTPBankValid() {
    I2Cdev::readBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, buffer);
    return buffer[0];
}
void MPU6050::setOTPBankValid(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled);
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	40 e0       	ldi	r20, 0x00	; 0
    263e:	60 e0       	ldi	r22, 0x00	; 0
    2640:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2644:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
setMotionDetectionThreshold():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:524
 * @param threshold New motion detection acceleration threshold value (LSB = 2mg)
 * @see getMotionDetectionThreshold()
 * @see MPU6050_RA_MOT_THR
 */
void MPU6050::setMotionDetectionThreshold(uint8_t threshold) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_THR, threshold);
    2648:	42 e0       	ldi	r20, 0x02	; 2
    264a:	6f e1       	ldi	r22, 0x1F	; 31
    264c:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2650:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setZeroMotionDetectionThreshold():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:594
 * @param threshold New zero motion detection acceleration threshold value (LSB = 2mg)
 * @see getZeroMotionDetectionThreshold()
 * @see MPU6050_RA_ZRMOT_THR
 */
void MPU6050::setZeroMotionDetectionThreshold(uint8_t threshold) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_THR, threshold);
    2654:	4c e9       	ldi	r20, 0x9C	; 156
    2656:	61 e2       	ldi	r22, 0x21	; 33
    2658:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    265c:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setMotionDetectionDuration():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:554
 * @param duration New motion detection duration threshold value (LSB = 1ms)
 * @see getMotionDetectionDuration()
 * @see MPU6050_RA_MOT_DUR
 */
void MPU6050::setMotionDetectionDuration(uint8_t duration) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_DUR, duration);
    2660:	40 e5       	ldi	r20, 0x50	; 80
    2662:	60 e2       	ldi	r22, 0x20	; 32
    2664:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2668:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setZeroMotionDetectionDuration():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:625
 * @param duration New zero motion detection duration threshold value (LSB = 1ms)
 * @see getZeroMotionDetectionDuration()
 * @see MPU6050_RA_ZRMOT_DUR
 */
void MPU6050::setZeroMotionDetectionDuration(uint8_t duration) {
    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_DUR, duration);
    266c:	40 e0       	ldi	r20, 0x00	; 0
    266e:	62 e2       	ldi	r22, 0x22	; 34
    2670:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2674:	0e 94 38 09 	call	0x1270	; 0x1270 <I2Cdev::writeByte(unsigned char, unsigned char, unsigned char)>
setFIFOEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2344
 * @see getFIFOEnabled()
 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_FIFO_EN_BIT
 */
void MPU6050::setFIFOEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled);
    2678:	21 e0       	ldi	r18, 0x01	; 1
    267a:	46 e0       	ldi	r20, 0x06	; 6
    267c:	6a e6       	ldi	r22, 0x6A	; 106
    267e:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2682:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
resetDMP():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3018
}
void MPU6050::setDMPEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
}
void MPU6050::resetDMP() {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);
    2686:	21 e0       	ldi	r18, 0x01	; 1
    2688:	43 e0       	ldi	r20, 0x03	; 3
    268a:	6a e6       	ldi	r22, 0x6A	; 106
    268c:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2690:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
setDMPEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3015
bool MPU6050::getDMPEnabled() {
    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, buffer);
    return buffer[0];
}
void MPU6050::setDMPEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
    2694:	20 e0       	ldi	r18, 0x00	; 0
    2696:	47 e0       	ldi	r20, 0x07	; 7
    2698:	6a e6       	ldi	r22, 0x6A	; 106
    269a:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    269e:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
dmpInitialize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:375

	DEBUG_PRINTLN(F("Disabling DMP (you turn it on later)..."));
	setDMPEnabled(false);

	DEBUG_PRINTLN(F("Setting up internal 42-byte (default) DMP packet buffer..."));
	dmpPacketSize = 42;
    26a2:	8a e2       	ldi	r24, 0x2A	; 42
    26a4:	90 e0       	ldi	r25, 0x00	; 0
    26a6:	80 93 f6 39 	sts	0x39F6, r24	; 0x8039f6 <mpu+0x11>
    26aa:	90 93 f7 39 	sts	0x39F7, r25	; 0x8039f7 <mpu+0x12>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:378

	DEBUG_PRINTLN(F("Resetting FIFO and clearing INT status one last time..."));
	resetFIFO();
    26ae:	0e 94 9b 0a 	call	0x1536	; 0x1536 <MPU6050::resetFIFO() [clone .constprop.96]>
readByte():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/I2Cdev.cpp:189
    26b2:	08 ee       	ldi	r16, 0xE8	; 232
    26b4:	13 e0       	ldi	r17, 0x03	; 3
    26b6:	26 ee       	ldi	r18, 0xE6	; 230
    26b8:	39 e3       	ldi	r19, 0x39	; 57
    26ba:	41 e0       	ldi	r20, 0x01	; 1
    26bc:	6a e3       	ldi	r22, 0x3A	; 58
    26be:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    26c2:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
mpuInit():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:57
  if (mpu.dmpInitialize() == 0) {
    Serial.println("Kalibracja");
    26c6:	81 eb       	ldi	r24, 0xB1	; 177
    26c8:	9a eb       	ldi	r25, 0xBA	; 186
    26ca:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <Print::println(char const*) [clone .constprop.30]>
CalibrateAccel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3284
	float kI = 20;
	float x;
	x = (100 - map(Loops, 1, 5, 20, 0)) * .01;
	kP *= x;
	kI *= x;
	PID( 0x3B, kP, kI,  Loops);
    26ce:	00 e0       	ldi	r16, 0x00	; 0
    26d0:	10 e0       	ldi	r17, 0x00	; 0
    26d2:	28 ea       	ldi	r18, 0xA8	; 168
    26d4:	31 e4       	ldi	r19, 0x41	; 65
    26d6:	4e ea       	ldi	r20, 0xAE	; 174
    26d8:	57 e4       	ldi	r21, 0x47	; 71
    26da:	61 ea       	ldi	r22, 0xA1	; 161
    26dc:	7e e3       	ldi	r23, 0x3E	; 62
    26de:	8b e3       	ldi	r24, 0x3B	; 59
    26e0:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]>
CalibrateGyro():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3270
  float x;
  x = (100 - map(Loops, 1, 5, 20, 0)) * .01;
  kP *= x;
  kI *= x;
  
  PID( 0x43,  kP, kI,  Loops);
    26e4:	0f ef       	ldi	r16, 0xFF	; 255
    26e6:	1f ef       	ldi	r17, 0xFF	; 255
    26e8:	2c eb       	ldi	r18, 0xBC	; 188
    26ea:	32 e4       	ldi	r19, 0x42	; 66
    26ec:	4e ea       	ldi	r20, 0xAE	; 174
    26ee:	57 e4       	ldi	r21, 0x47	; 71
    26f0:	61 ea       	ldi	r22, 0xA1	; 161
    26f2:	7e e3       	ldi	r23, 0x3E	; 62
    26f4:	83 e4       	ldi	r24, 0x43	; 67
    26f6:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <MPU6050::PID(unsigned char, float, float, unsigned char) [clone .constprop.76]>
setDMPEnabled():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:3015
bool MPU6050::getDMPEnabled() {
    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, buffer);
    return buffer[0];
}
void MPU6050::setDMPEnabled(bool enabled) {
    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
    26fa:	21 e0       	ldi	r18, 0x01	; 1
    26fc:	47 e0       	ldi	r20, 0x07	; 7
    26fe:	6a e6       	ldi	r22, 0x6A	; 106
    2700:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    2704:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <I2Cdev::writeBit(unsigned char, unsigned char, unsigned char, unsigned char)>
mpuInit():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:61
    mpu.CalibrateAccel(6);
    mpu.CalibrateGyro(6);
    mpu.setDMPEnabled(true);
    packetSize = mpu.dmpGetFIFOPacketSize();
    2708:	80 91 f6 39 	lds	r24, 0x39F6	; 0x8039f6 <mpu+0x11>
    270c:	90 91 f7 39 	lds	r25, 0x39F7	; 0x8039f7 <mpu+0x12>
    2710:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <packetSize>
    2714:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <packetSize+0x1>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:62
    Serial.println("Kalibracja zakonczona");
    2718:	8c eb       	ldi	r24, 0xBC	; 188
    271a:	9a eb       	ldi	r25, 0xBA	; 186
    271c:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <Print::println(char const*) [clone .constprop.30]>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:654
    ce(LOW);
    csn(HIGH);
    delay(200);
    #else
    // Initialize pins
    if (ce_pin != csn_pin) {
    2720:	80 91 f8 39 	lds	r24, 0x39F8	; 0x8039f8 <radio>
    2724:	90 91 f9 39 	lds	r25, 0x39F9	; 0x8039f9 <radio+0x1>
    2728:	20 91 fa 39 	lds	r18, 0x39FA	; 0x8039fa <radio+0x2>
    272c:	30 91 fb 39 	lds	r19, 0x39FB	; 0x8039fb <radio+0x3>
    2730:	82 17       	cp	r24, r18
    2732:	93 07       	cpc	r25, r19
    2734:	29 f0       	breq	.+10     	; 0x2740 <main+0x424>
pinMode():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:32
#include "pins_arduino.h"


void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit_mask = digitalPinToBitMask(pin);
    2736:	8c 30       	cpi	r24, 0x0C	; 12
    2738:	18 f4       	brcc	.+6      	; 0x2740 <main+0x424>
    273a:	61 e0       	ldi	r22, 0x01	; 1
    273c:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:659
        pinMode(ce_pin, OUTPUT);
    }

        #if !defined(LITTLEWIRE)
    if (ce_pin != csn_pin)
    2740:	80 91 fa 39 	lds	r24, 0x39FA	; 0x8039fa <radio+0x2>
    2744:	90 91 fb 39 	lds	r25, 0x39FB	; 0x8039fb <radio+0x3>
    2748:	20 91 f8 39 	lds	r18, 0x39F8	; 0x8039f8 <radio>
    274c:	30 91 f9 39 	lds	r19, 0x39F9	; 0x8039f9 <radio+0x1>
    2750:	28 17       	cp	r18, r24
    2752:	39 07       	cpc	r19, r25
    2754:	29 f0       	breq	.+10     	; 0x2760 <main+0x444>
pinMode():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:32
    2756:	8c 30       	cpi	r24, 0x0C	; 12
    2758:	18 f4       	brcc	.+6      	; 0x2760 <main+0x444>
    275a:	61 e0       	ldi	r22, 0x01	; 1
    275c:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
init():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:172
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init()
{
  if (initialized)
    2760:	80 91 92 39 	lds	r24, 0x3992	; 0x803992 <SPI+0x5>
    2764:	81 11       	cpse	r24, r1
    2766:	17 c0       	rjmp	.+46     	; 0x2796 <main+0x47a>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:174
    return;
  interruptMode = SPI_IMODE_NONE;
    2768:	10 92 93 39 	sts	0x3993, r1	; 0x803993 <SPI+0x6>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:175
  interruptSave = 0;
    276c:	10 92 94 39 	sts	0x3994, r1	; 0x803994 <SPI+0x7>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:176
  interruptMask_lo = 0;
    2770:	10 92 95 39 	sts	0x3995, r1	; 0x803995 <SPI+0x8>
    2774:	10 92 96 39 	sts	0x3996, r1	; 0x803996 <SPI+0x9>
    2778:	10 92 97 39 	sts	0x3997, r1	; 0x803997 <SPI+0xa>
    277c:	10 92 98 39 	sts	0x3998, r1	; 0x803998 <SPI+0xb>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:177
  interruptMask_hi = 0;
    2780:	10 92 99 39 	sts	0x3999, r1	; 0x803999 <SPI+0xc>
    2784:	10 92 9a 39 	sts	0x399A, r1	; 0x80399a <SPI+0xd>
    2788:	10 92 9b 39 	sts	0x399B, r1	; 0x80399b <SPI+0xe>
    278c:	10 92 9c 39 	sts	0x399C, r1	; 0x80399c <SPI+0xf>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:178
  initialized = true;
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	80 93 92 39 	sts	0x3992, r24	; 0x803992 <SPI+0x5>
begin():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:129

void SPIClass::begin()
{
  init();
  #if defined(PORTMUX_CTRLB)
    PORTMUX.CTRLB=_uc_mux | (PORTMUX.CTRLB & ~PORTMUX_SPI0_bm);
    2796:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
    279a:	8b 7f       	andi	r24, 0xFB	; 251
    279c:	90 91 91 39 	lds	r25, 0x3991	; 0x803991 <SPI+0x4>
    27a0:	89 2b       	or	r24, r25
    27a2:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
pinMode():
    27a6:	61 e0       	ldi	r22, 0x01	; 1
    27a8:	88 e0       	ldi	r24, 0x08	; 8
    27aa:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
    27ae:	61 e0       	ldi	r22, 0x01	; 1
    27b0:	8a e0       	ldi	r24, 0x0A	; 10
    27b2:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <pinMode.part.0>
begin():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:164
    // MISO is set to input by the controller
    pinMode(PIN_SPI_MOSI, OUTPUT);
    pinMode(PIN_SPI_SCK, OUTPUT);
  #endif

  SPI0.CTRLB |= (SPI_SSD_bm);
    27b6:	80 91 21 08 	lds	r24, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    27ba:	84 60       	ori	r24, 0x04	; 4
    27bc:	80 93 21 08 	sts	0x0821, r24	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:165
  SPI0.CTRLA |= (SPI_ENABLE_bm | SPI_MASTER_bm);
    27c0:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    27c4:	81 62       	ori	r24, 0x21	; 33
    27c6:	80 93 20 08 	sts	0x0820, r24	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    27ca:	90 91 a9 39 	lds	r25, 0x39A9	; 0x8039a9 <DEFAULT_SPI_SETTINGS>
    27ce:	80 91 aa 39 	lds	r24, 0x39AA	; 0x8039aa <DEFAULT_SPI_SETTINGS+0x1>
config():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:183
  initialized = true;
}

void SPIClass::config(SPISettings settings)
{
  SPI0.CTRLA = settings.ctrla;
    27d2:	90 93 20 08 	sts	0x0820, r25	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\libraries\SPI\src/SPI.cpp:184
  SPI0.CTRLB = settings.ctrlb;
    27d6:	80 93 21 08 	sts	0x0821, r24	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
ce():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:87
/****************************************************************************/

void RF24::ce(bool level)
{
    //Allow for 3-pin use on ATTiny
    if (ce_pin != csn_pin) {
    27da:	80 91 f8 39 	lds	r24, 0x39F8	; 0x8039f8 <radio>
    27de:	90 91 f9 39 	lds	r25, 0x39F9	; 0x8039f9 <radio+0x1>
    27e2:	20 91 fa 39 	lds	r18, 0x39FA	; 0x8039fa <radio+0x2>
    27e6:	30 91 fb 39 	lds	r19, 0x39FB	; 0x8039fb <radio+0x3>
    27ea:	82 17       	cp	r24, r18
    27ec:	93 07       	cpc	r25, r19
    27ee:	29 f0       	breq	.+10     	; 0x27fa <main+0x4de>
digitalWrite():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:147
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	/* Get bit mask for pin */
	uint8_t bit_mask = digitalPinToBitMask(pin);
    27f0:	8c 30       	cpi	r24, 0x0C	; 12
    27f2:	18 f4       	brcc	.+6      	; 0x27fa <main+0x4de>
    27f4:	60 e0       	ldi	r22, 0x00	; 0
    27f6:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:667
        pinMode(csn_pin, OUTPUT);
    }

    _SPI.begin();
    ce(LOW);
    csn(HIGH);
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <RF24::csn(bool) [clone .constprop.69]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:679
    // This is actually only required following power up but some settling time also appears to
    // be required after resets too. For full coverage, we'll always assume the worst.
    // Enabling 16b CRC is by far the most obvious case if the wrong timing is used - or skipped.
    // Technically we require 4.5ms + 14us as a worst case. We'll just call it 5ms for good measure.
    // WARNING: Delay is based on P-variant whereby non-P *may* require different timing.
    delay(5);
    2800:	65 e0       	ldi	r22, 0x05	; 5
    2802:	70 e0       	ldi	r23, 0x00	; 0
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	90 e0       	ldi	r25, 0x00	; 0
    2808:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <delay>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:682

    // Reset NRF_CONFIG and enable 16-bit CRC.
    write_register(NRF_CONFIG, 0x0C);
    280c:	6c e0       	ldi	r22, 0x0C	; 12
    280e:	80 e0       	ldi	r24, 0x00	; 0
    2810:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
setRetries():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1612
}

/****************************************************************************/
void RF24::setRetries(uint8_t delay, uint8_t count)
{
    write_register(SETUP_RETR, (delay & 0xf) << ARD | (count & 0xf) << ARC);
    2814:	6f e5       	ldi	r22, 0x5F	; 95
    2816:	84 e0       	ldi	r24, 0x04	; 4
    2818:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:694
    // Reset value is MAX
    //setPALevel( RF24_PA_MAX ) ;

    // check for connected module and if this is a p nRF24l01 variant
    //
    if (setDataRate(RF24_250KBPS)) {
    281c:	82 e0       	ldi	r24, 0x02	; 2
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <RF24::setDataRate(rf24_datarate_e) [clone .constprop.38]>
    2824:	88 23       	and	r24, r24
    2826:	19 f0       	breq	.+6      	; 0x282e <main+0x512>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:695
        p_variant = true;
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	80 93 fe 39 	sts	0x39FE, r24	; 0x8039fe <radio+0x6>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:697
    }
    setup = read_register(RF_SETUP);
    282e:	86 e0       	ldi	r24, 0x06	; 6
    2830:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:705
      p_variant = true ;
    }*/

    // Then set the data rate to the slowest (and most reliable) speed supported by all
    // hardware.
    setDataRate(RF24_1MBPS);
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	80 e0       	ldi	r24, 0x00	; 0
    2838:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <RF24::setDataRate(rf24_datarate_e) [clone .constprop.38]>
toggle_features():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1298

/****************************************************************************/

void RF24::toggle_features(void)
{
    beginTransaction();
    283c:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1299
    _SPI.transfer(ACTIVATE);
    2840:	80 e5       	ldi	r24, 0x50	; 80
    2842:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1300
    _SPI.transfer(0x73);
    2846:	83 e7       	ldi	r24, 0x73	; 115
    2848:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1301
    endTransaction();
    284c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:712
    // Initialize CRC and request 2-byte (16bit) CRC
    //setCRCLength( RF24_CRC_16 ) ;

    // Disable dynamic payloads, to match dynamic_payloads_enabled setting - Reset value is 0
    toggle_features();
    write_register(FEATURE, 0);
    2850:	60 e0       	ldi	r22, 0x00	; 0
    2852:	8d e1       	ldi	r24, 0x1D	; 29
    2854:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:713
    write_register(DYNPD, 0);
    2858:	60 e0       	ldi	r22, 0x00	; 0
    285a:	8c e1       	ldi	r24, 0x1C	; 28
    285c:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:714
    dynamic_payloads_enabled = false;
    2860:	10 92 00 3a 	sts	0x3A00, r1	; 0x803a00 <radio+0x8>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:718

    // Reset current status
    // Notice reset and flush is the last thing we do
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
    2864:	60 e7       	ldi	r22, 0x70	; 112
    2866:	87 e0       	ldi	r24, 0x07	; 7
    2868:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
setChannel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:464
/****************************************************************************/

void RF24::setChannel(uint8_t channel)
{
    const uint8_t max_channel = 125;
    write_register(RF_CH, rf24_min(channel, max_channel));
    286c:	6c e4       	ldi	r22, 0x4C	; 76
    286e:	85 e0       	ldi	r24, 0x05	; 5
    2870:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
spiTrans():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:365
uint8_t RF24::spiTrans(uint8_t cmd)
{

    uint8_t status;

    beginTransaction();
    2874:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:366
    status = _SPI.transfer(cmd);
    2878:	82 ee       	ldi	r24, 0xE2	; 226
    287a:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:367
    endTransaction();
    287e:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
begin():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:727
    // spectrum.
    setChannel(76);

    // Flush buffers
    flush_rx();
    flush_tx();
    2882:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <RF24::flush_tx() [clone .constprop.56]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:729

    powerUp(); //Power up by default when begin() is called
    2886:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <RF24::powerUp() [clone .constprop.50]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:733

    // Enable PTX, do not write CE high so radio will remain in standby I mode ( 130us max to transition to RX or TX instead of 1500us from powerUp )
    // PTX should use only 22uA of power
    write_register(NRF_CONFIG, (read_register(NRF_CONFIG)) & ~_BV(PRIM_RX));
    288a:	80 e0       	ldi	r24, 0x00	; 0
    288c:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    2890:	68 2f       	mov	r22, r24
    2892:	6e 7f       	andi	r22, 0xFE	; 254
    2894:	80 e0       	ldi	r24, 0x00	; 0
    2896:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
setAutoAck():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1429
/****************************************************************************/

void RF24::setAutoAck(bool enable)
{
    if (enable) {
        write_register(EN_AA, 0x3F);
    289a:	6f e3       	ldi	r22, 0x3F	; 63
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
setChannel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:464
/****************************************************************************/

void RF24::setChannel(uint8_t channel)
{
    const uint8_t max_channel = 125;
    write_register(RF_CH, rf24_min(channel, max_channel));
    28a2:	64 e3       	ldi	r22, 0x34	; 52
    28a4:	85 e0       	ldi	r24, 0x05	; 5
    28a6:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
setPayloadSize():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:477

/****************************************************************************/

void RF24::setPayloadSize(uint8_t size)
{
    payload_size = rf24_min(size, 32);
    28aa:	80 e2       	ldi	r24, 0x20	; 32
    28ac:	80 93 ff 39 	sts	0x39FF, r24	; 0x8039ff <radio+0x7>
radioInit():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:45
void radioInit() {
  radio.begin();
  radio.setAutoAck(true);
  radio.setChannel(52);
  radio.setPayloadSize(32);
  radio.setDataRate(RF24_1MBPS);
    28b0:	90 e0       	ldi	r25, 0x00	; 0
    28b2:	80 e0       	ldi	r24, 0x00	; 0
    28b4:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <RF24::setDataRate(rf24_datarate_e) [clone .constprop.38]>
setPALevel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1469
/****************************************************************************/

void RF24::setPALevel(uint8_t level)
{

    uint8_t setup = read_register(RF_SETUP) & 0xF8;
    28b8:	86 e0       	ldi	r24, 0x06	; 6
    28ba:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    28be:	88 7f       	andi	r24, 0xF8	; 248
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1477
        level = (RF24_PA_MAX << 1) + 1;        // +1 to support the SI24R1 chip extra bit
    } else {
        level = (level << 1) + 1;            // Else set level as requested
    }

    write_register(RF_SETUP, setup |= level);    // Write it to the chip
    28c0:	68 2f       	mov	r22, r24
    28c2:	61 60       	ori	r22, 0x01	; 1
    28c4:	86 e0       	ldi	r24, 0x06	; 6
    28c6:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
enableAckPayload():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1352
    //
    // enable ack payload and dynamic payload features
    //

    //toggle_features();
    write_register(FEATURE, read_register(FEATURE) | _BV(EN_ACK_PAY) | _BV(EN_DPL));
    28ca:	8d e1       	ldi	r24, 0x1D	; 29
    28cc:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    28d0:	68 2f       	mov	r22, r24
    28d2:	66 60       	ori	r22, 0x06	; 6
    28d4:	8d e1       	ldi	r24, 0x1D	; 29
    28d6:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1359
    IF_SERIAL_DEBUG(printf("FEATURE=%i\r\n", read_register(FEATURE)));

    //
    // Enable dynamic payload on pipes 0 & 1
    //
    write_register(DYNPD, read_register(DYNPD) | _BV(DPL_P1) | _BV(DPL_P0));
    28da:	8c e1       	ldi	r24, 0x1C	; 28
    28dc:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    28e0:	68 2f       	mov	r22, r24
    28e2:	63 60       	ori	r22, 0x03	; 3
    28e4:	8c e1       	ldi	r24, 0x1C	; 28
    28e6:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1360
    dynamic_payloads_enabled = true;
    28ea:	81 e0       	ldi	r24, 0x01	; 1
    28ec:	80 93 00 3a 	sts	0x3A00, r24	; 0x803a00 <radio+0x8>
openReadingPipe():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1273
        memcpy(pipe0_reading_address, address, addr_width);
    }
    if (child <= 6) {
        // For pipes 2-5, only write the LSB
        if (child < 2) {
            write_register(pgm_read_byte(&child_pipe[child]), address, addr_width);
    28f0:	ec e0       	ldi	r30, 0x0C	; 12
    28f2:	f8 e0       	ldi	r31, 0x08	; 8
    28f4:	84 91       	lpm	r24, Z
    28f6:	40 91 06 3a 	lds	r20, 0x3A06	; 0x803a06 <radio+0xe>
    28fa:	64 ee       	ldi	r22, 0xE4	; 228
    28fc:	79 eb       	ldi	r23, 0xB9	; 185
    28fe:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.63]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1277
        } else {
            write_register(pgm_read_byte(&child_pipe[child]), address, 1);
        }
        write_register(pgm_read_byte(&child_payload_size[child]), payload_size);
    2902:	e6 e0       	ldi	r30, 0x06	; 6
    2904:	f8 e0       	ldi	r31, 0x08	; 8
    2906:	84 91       	lpm	r24, Z
    2908:	60 91 ff 39 	lds	r22, 0x39FF	; 0x8039ff <radio+0x7>
    290c:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1282

        // Note it would be more efficient to set all of the bits for all open
        // pipes at once.  However, I thought it would make the calling code
        // more simple to do it this way.
        write_register(EN_RXADDR, read_register(EN_RXADDR) | _BV(pgm_read_byte(&child_pipe_enable[child])));
    2910:	82 e0       	ldi	r24, 0x02	; 2
    2912:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    2916:	e2 e1       	ldi	r30, 0x12	; 18
    2918:	f8 e0       	ldi	r31, 0x08	; 8
    291a:	e4 91       	lpm	r30, Z
    291c:	61 e0       	ldi	r22, 0x01	; 1
    291e:	70 e0       	ldi	r23, 0x00	; 0
    2920:	01 c0       	rjmp	.+2      	; 0x2924 <main+0x608>
    2922:	66 0f       	add	r22, r22
    2924:	ea 95       	dec	r30
    2926:	ea f7       	brpl	.-6      	; 0x2922 <main+0x606>
    2928:	68 2b       	or	r22, r24
    292a:	82 e0       	ldi	r24, 0x02	; 2
    292c:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
startListening():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:756
/****************************************************************************/

void RF24::startListening(void)
{
    #if !defined(RF24_TINY) && !defined(LITTLEWIRE)
    powerUp();
    2930:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <RF24::powerUp() [clone .constprop.50]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:758
    #endif
    write_register(NRF_CONFIG, read_register(NRF_CONFIG) | _BV(PRIM_RX));
    2934:	80 e0       	ldi	r24, 0x00	; 0
    2936:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    293a:	68 2f       	mov	r22, r24
    293c:	61 60       	ori	r22, 0x01	; 1
    293e:	80 e0       	ldi	r24, 0x00	; 0
    2940:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:759
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
    2944:	60 e7       	ldi	r22, 0x70	; 112
    2946:	87 e0       	ldi	r24, 0x07	; 7
    2948:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
ce():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:87
/****************************************************************************/

void RF24::ce(bool level)
{
    //Allow for 3-pin use on ATTiny
    if (ce_pin != csn_pin) {
    294c:	80 91 f8 39 	lds	r24, 0x39F8	; 0x8039f8 <radio>
    2950:	90 91 f9 39 	lds	r25, 0x39F9	; 0x8039f9 <radio+0x1>
    2954:	20 91 fa 39 	lds	r18, 0x39FA	; 0x8039fa <radio+0x2>
    2958:	30 91 fb 39 	lds	r19, 0x39FB	; 0x8039fb <radio+0x3>
    295c:	82 17       	cp	r24, r18
    295e:	93 07       	cpc	r25, r19
    2960:	29 f0       	breq	.+10     	; 0x296c <main+0x650>
digitalWrite():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:147
    2962:	8c 30       	cpi	r24, 0x0C	; 12
    2964:	18 f4       	brcc	.+6      	; 0x296c <main+0x650>
    2966:	61 e0       	ldi	r22, 0x01	; 1
    2968:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
startListening():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:762
    #endif
    write_register(NRF_CONFIG, read_register(NRF_CONFIG) | _BV(PRIM_RX));
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(TX_DS) | _BV(MAX_RT));
    ce(HIGH);
    // Restore the pipe0 adddress, if exists
    if (pipe0_reading_address[0] > 0) {
    296c:	80 91 01 3a 	lds	r24, 0x3A01	; 0x803a01 <radio+0x9>
    2970:	88 23       	and	r24, r24
    2972:	09 f4       	brne	.+2      	; 0x2976 <main+0x65a>
    2974:	5f c4       	rjmp	.+2238   	; 0x3234 <main+0xf18>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:763
        write_register(RX_ADDR_P0, pipe0_reading_address, addr_width);
    2976:	40 91 06 3a 	lds	r20, 0x3A06	; 0x803a06 <radio+0xe>
    297a:	61 e0       	ldi	r22, 0x01	; 1
    297c:	7a e3       	ldi	r23, 0x3A	; 58
    297e:	8a e0       	ldi	r24, 0x0A	; 10
    2980:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <RF24::write_register(unsigned char, unsigned char const*, unsigned char) [clone .constprop.63]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:770
        closeReadingPipe(0);
    }

    // Flush buffers
    //flush_rx();
    if (read_register(FEATURE) & _BV(EN_ACK_PAY)) {
    2984:	8d e1       	ldi	r24, 0x1D	; 29
    2986:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    298a:	81 fd       	sbrc	r24, 1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:771
        flush_tx();
    298c:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <RF24::flush_tx() [clone .constprop.56]>
read():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1164

void RF24::read(void* buf, uint8_t len)
{

    // Fetch the payload
    read_payload(buf, len);
    2990:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <RF24::read_payload(void*, unsigned char) [clone .constprop.59]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1167

    //Clear the two possible interrupt flags with one command
    write_register(NRF_STATUS, _BV(RX_DR) | _BV(MAX_RT) | _BV(TX_DS));
    2994:	60 e7       	ldi	r22, 0x70	; 112
    2996:	87 e0       	ldi	r24, 0x07	; 7
    2998:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
attachInterrupt():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:48
  /* Get interrupt number from pin */
  uint8_t interruptNum = (digitalPinToPort(pin) * 8) + bit_pos;

  /* Check interrupt number and apply function pointer to correct array index */
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    intFunc[interruptNum] = userFunc;
    299c:	86 e8       	ldi	r24, 0x86	; 134
    299e:	9e e0       	ldi	r25, 0x0E	; 14
    29a0:	80 93 2f 38 	sts	0x382F, r24	; 0x80382f <intFunc+0xc>
    29a4:	90 93 30 38 	sts	0x3830, r25	; 0x803830 <intFunc+0xd>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:77
    /* Get pointer to correct pin control register */
    PORT_t *port = digitalPinToPortStruct(pin);
    volatile uint8_t* pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Clear any previous setting */
    *pin_ctrl_reg &= ~(PORT_ISC_gm);
    29a8:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <__TEXT_REGION_LENGTH__+0x700416>
    29ac:	88 7f       	andi	r24, 0xF8	; 248
    29ae:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <__TEXT_REGION_LENGTH__+0x700416>
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/WInterrupts.c:80

    /* Apply ISC setting */
    *pin_ctrl_reg |= mode;
    29b2:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <__TEXT_REGION_LENGTH__+0x700416>
    29b6:	83 60       	ori	r24, 0x03	; 3
    29b8:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <__TEXT_REGION_LENGTH__+0x700416>
digitalWrite():
    29bc:	61 e0       	ldi	r22, 0x01	; 1
    29be:	84 e0       	ldi	r24, 0x04	; 4
    29c0:	0e 94 99 05 	call	0xb32	; 0xb32 <digitalWrite.part.1>
mpuRead():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:68
  } 
}

//Odczytanie wartoci z MPU
void mpuRead() {
  mpu.resetFIFO();
    29c4:	0e 94 9b 0a 	call	0x1536	; 0x1536 <MPU6050::resetFIFO() [clone .constprop.96]>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:69
  fifoCount = mpu.getFIFOCount();
    29c8:	0e 94 04 0a 	call	0x1408	; 0x1408 <MPU6050::getFIFOCount() [clone .constprop.90]>
    29cc:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <fifoCount>
    29d0:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <fifoCount+0x1>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:70
  while (fifoCount < packetSize) fifoCount = mpu.getFIFOCount(); //Czytaj dopki nie przeczytasz wszystkiego
    29d4:	40 91 3b 38 	lds	r20, 0x383B	; 0x80383b <packetSize>
    29d8:	50 91 3c 38 	lds	r21, 0x383C	; 0x80383c <packetSize+0x1>
    29dc:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <fifoCount>
    29e0:	90 91 3e 38 	lds	r25, 0x383E	; 0x80383e <fifoCount+0x1>
    29e4:	84 17       	cp	r24, r20
    29e6:	95 07       	cpc	r25, r21
    29e8:	78 f3       	brcs	.-34     	; 0x29c8 <main+0x6ac>
getFIFOBytes():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2737
uint8_t MPU6050::getFIFOByte() {
    I2Cdev::readByte(devAddr, MPU6050_RA_FIFO_R_W, buffer);
    return buffer[0];
}
void MPU6050::getFIFOBytes(uint8_t *data, uint8_t length) {
    if(length > 0){
    29ea:	44 23       	and	r20, r20
    29ec:	09 f4       	brne	.+2      	; 0x29f0 <main+0x6d4>
    29ee:	35 c4       	rjmp	.+2154   	; 0x325a <main+0xf3e>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2738
        I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_R_W, length, data);
    29f0:	08 ee       	ldi	r16, 0xE8	; 232
    29f2:	13 e0       	ldi	r17, 0x03	; 3
    29f4:	29 e4       	ldi	r18, 0x49	; 73
    29f6:	38 e3       	ldi	r19, 0x38	; 56
    29f8:	64 e7       	ldi	r22, 0x74	; 116
    29fa:	80 91 e5 39 	lds	r24, 0x39E5	; 0x8039e5 <mpu>
    29fe:	0e 94 48 09 	call	0x1290	; 0x1290 <I2Cdev::readBytes(unsigned char, unsigned char, unsigned char, unsigned char*, unsigned int)>
    2a02:	00 91 4d 38 	lds	r16, 0x384D	; 0x80384d <fifoBuffer+0x4>
    2a06:	10 91 4e 38 	lds	r17, 0x384E	; 0x80384e <fifoBuffer+0x5>
    2a0a:	10 27       	eor	r17, r16
    2a0c:	01 27       	eor	r16, r17
    2a0e:	10 27       	eor	r17, r16
    2a10:	c0 90 51 38 	lds	r12, 0x3851	; 0x803851 <fifoBuffer+0x8>
    2a14:	d0 90 52 38 	lds	r13, 0x3852	; 0x803852 <fifoBuffer+0x9>
    2a18:	dc 24       	eor	r13, r12
    2a1a:	cd 24       	eor	r12, r13
    2a1c:	dc 24       	eor	r13, r12
    2a1e:	e0 90 55 38 	lds	r14, 0x3855	; 0x803855 <fifoBuffer+0xc>
    2a22:	f0 90 56 38 	lds	r15, 0x3856	; 0x803856 <fifoBuffer+0xd>
    2a26:	fe 24       	eor	r15, r14
    2a28:	ef 24       	eor	r14, r15
    2a2a:	fe 24       	eor	r15, r14
dmpGetQuaternion():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:459
uint8_t MPU6050::dmpGetQuaternion(Quaternion *q, const uint8_t* packet) {
    // TODO: accommodate different arrangements of sent data (ONLY default supported now)
    int16_t qI[4];
    uint8_t status = dmpGetQuaternion(qI, packet);
    if (status == 0) {
        q -> w = (float)qI[0] / 16384.0f;
    2a2c:	60 91 49 38 	lds	r22, 0x3849	; 0x803849 <fifoBuffer>
    2a30:	70 91 4a 38 	lds	r23, 0x384A	; 0x80384a <fifoBuffer+0x1>
    2a34:	76 27       	eor	r23, r22
    2a36:	67 27       	eor	r22, r23
    2a38:	76 27       	eor	r23, r22
    2a3a:	07 2e       	mov	r0, r23
    2a3c:	00 0c       	add	r0, r0
    2a3e:	88 0b       	sbc	r24, r24
    2a40:	99 0b       	sbc	r25, r25
    2a42:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2a46:	20 e0       	ldi	r18, 0x00	; 0
    2a48:	30 e0       	ldi	r19, 0x00	; 0
    2a4a:	40 e8       	ldi	r20, 0x80	; 128
    2a4c:	58 e3       	ldi	r21, 0x38	; 56
    2a4e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2a52:	6a a7       	std	Y+42, r22	; 0x2a
    2a54:	7b a7       	std	Y+43, r23	; 0x2b
    2a56:	8c a7       	std	Y+44, r24	; 0x2c
    2a58:	9d a7       	std	Y+45, r25	; 0x2d
    2a5a:	60 93 d5 39 	sts	0x39D5, r22	; 0x8039d5 <q>
    2a5e:	70 93 d6 39 	sts	0x39D6, r23	; 0x8039d6 <q+0x1>
    2a62:	80 93 d7 39 	sts	0x39D7, r24	; 0x8039d7 <q+0x2>
    2a66:	90 93 d8 39 	sts	0x39D8, r25	; 0x8039d8 <q+0x3>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:460
        q -> x = (float)qI[1] / 16384.0f;
    2a6a:	b8 01       	movw	r22, r16
    2a6c:	11 0f       	add	r17, r17
    2a6e:	88 0b       	sbc	r24, r24
    2a70:	99 0b       	sbc	r25, r25
    2a72:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2a76:	20 e0       	ldi	r18, 0x00	; 0
    2a78:	30 e0       	ldi	r19, 0x00	; 0
    2a7a:	40 e8       	ldi	r20, 0x80	; 128
    2a7c:	58 e3       	ldi	r21, 0x38	; 56
    2a7e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2a82:	6e a3       	std	Y+38, r22	; 0x26
    2a84:	7f a3       	std	Y+39, r23	; 0x27
    2a86:	88 a7       	std	Y+40, r24	; 0x28
    2a88:	99 a7       	std	Y+41, r25	; 0x29
    2a8a:	60 93 d9 39 	sts	0x39D9, r22	; 0x8039d9 <q+0x4>
    2a8e:	70 93 da 39 	sts	0x39DA, r23	; 0x8039da <q+0x5>
    2a92:	80 93 db 39 	sts	0x39DB, r24	; 0x8039db <q+0x6>
    2a96:	90 93 dc 39 	sts	0x39DC, r25	; 0x8039dc <q+0x7>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:461
        q -> y = (float)qI[2] / 16384.0f;
    2a9a:	b6 01       	movw	r22, r12
    2a9c:	dd 0c       	add	r13, r13
    2a9e:	88 0b       	sbc	r24, r24
    2aa0:	99 0b       	sbc	r25, r25
    2aa2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2aa6:	20 e0       	ldi	r18, 0x00	; 0
    2aa8:	30 e0       	ldi	r19, 0x00	; 0
    2aaa:	40 e8       	ldi	r20, 0x80	; 128
    2aac:	58 e3       	ldi	r21, 0x38	; 56
    2aae:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ab2:	6a a3       	std	Y+34, r22	; 0x22
    2ab4:	7b a3       	std	Y+35, r23	; 0x23
    2ab6:	8c a3       	std	Y+36, r24	; 0x24
    2ab8:	9d a3       	std	Y+37, r25	; 0x25
    2aba:	60 93 dd 39 	sts	0x39DD, r22	; 0x8039dd <q+0x8>
    2abe:	70 93 de 39 	sts	0x39DE, r23	; 0x8039de <q+0x9>
    2ac2:	80 93 df 39 	sts	0x39DF, r24	; 0x8039df <q+0xa>
    2ac6:	90 93 e0 39 	sts	0x39E0, r25	; 0x8039e0 <q+0xb>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:462
        q -> z = (float)qI[3] / 16384.0f;
    2aca:	b7 01       	movw	r22, r14
    2acc:	ff 0c       	add	r15, r15
    2ace:	88 0b       	sbc	r24, r24
    2ad0:	99 0b       	sbc	r25, r25
    2ad2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2ad6:	20 e0       	ldi	r18, 0x00	; 0
    2ad8:	30 e0       	ldi	r19, 0x00	; 0
    2ada:	40 e8       	ldi	r20, 0x80	; 128
    2adc:	58 e3       	ldi	r21, 0x38	; 56
    2ade:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ae2:	6e a7       	std	Y+46, r22	; 0x2e
    2ae4:	7f a7       	std	Y+47, r23	; 0x2f
    2ae6:	88 ab       	std	Y+48, r24	; 0x30
    2ae8:	99 ab       	std	Y+49, r25	; 0x31
    2aea:	60 93 e1 39 	sts	0x39E1, r22	; 0x8039e1 <q+0xc>
    2aee:	70 93 e2 39 	sts	0x39E2, r23	; 0x8039e2 <q+0xd>
    2af2:	80 93 e3 39 	sts	0x39E3, r24	; 0x8039e3 <q+0xe>
    2af6:	90 93 e4 39 	sts	0x39E4, r25	; 0x8039e4 <q+0xf>
    2afa:	60 90 65 38 	lds	r6, 0x3865	; 0x803865 <fifoBuffer+0x1c>
    2afe:	70 90 66 38 	lds	r7, 0x3866	; 0x803866 <fifoBuffer+0x1d>
    2b02:	76 24       	eor	r7, r6
    2b04:	67 24       	eor	r6, r7
    2b06:	76 24       	eor	r7, r6
dmpGetAccel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:431
    return 0;
}
uint8_t MPU6050::dmpGetAccel(VectorInt16 *v, const uint8_t* packet) {
    // TODO: accommodate different arrangements of sent data (ONLY default supported now)
    if (packet == 0) packet = dmpPacketBuffer;
    v -> x = (packet[28] << 8) | packet[29];
    2b08:	60 92 cf 39 	sts	0x39CF, r6	; 0x8039cf <aa>
    2b0c:	70 92 d0 39 	sts	0x39D0, r7	; 0x8039d0 <aa+0x1>
    2b10:	00 91 69 38 	lds	r16, 0x3869	; 0x803869 <fifoBuffer+0x20>
    2b14:	10 91 6a 38 	lds	r17, 0x386A	; 0x80386a <fifoBuffer+0x21>
    2b18:	10 27       	eor	r17, r16
    2b1a:	01 27       	eor	r16, r17
    2b1c:	10 27       	eor	r17, r16
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:432
    v -> y = (packet[32] << 8) | packet[33];
    2b1e:	00 93 d1 39 	sts	0x39D1, r16	; 0x8039d1 <aa+0x2>
    2b22:	10 93 d2 39 	sts	0x39D2, r17	; 0x8039d2 <aa+0x3>
    2b26:	20 90 6d 38 	lds	r2, 0x386D	; 0x80386d <fifoBuffer+0x24>
    2b2a:	30 90 6e 38 	lds	r3, 0x386E	; 0x80386e <fifoBuffer+0x25>
    2b2e:	32 24       	eor	r3, r2
    2b30:	23 24       	eor	r2, r3
    2b32:	32 24       	eor	r3, r2
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:433
    v -> z = (packet[36] << 8) | packet[37];
    2b34:	20 92 d3 39 	sts	0x39D3, r2	; 0x8039d3 <aa+0x4>
    2b38:	30 92 d4 39 	sts	0x39D4, r3	; 0x8039d4 <aa+0x5>
dmpGetGravity():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:527
	       - (int32_t)qI[2] * qI[2] + (int32_t)qI[3] * qI[3]) / (2 * 16384);
    return status;
}

uint8_t MPU6050::dmpGetGravity(VectorFloat *v, Quaternion *q) {
    v -> x = 2 * (q -> x*q -> z - q -> w*q -> y);
    2b3c:	9b 01       	movw	r18, r22
    2b3e:	ac 01       	movw	r20, r24
    2b40:	6e a1       	ldd	r22, Y+38	; 0x26
    2b42:	7f a1       	ldd	r23, Y+39	; 0x27
    2b44:	88 a5       	ldd	r24, Y+40	; 0x28
    2b46:	99 a5       	ldd	r25, Y+41	; 0x29
    2b48:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2b4c:	6b 01       	movw	r12, r22
    2b4e:	7c 01       	movw	r14, r24
    2b50:	2a a1       	ldd	r18, Y+34	; 0x22
    2b52:	3b a1       	ldd	r19, Y+35	; 0x23
    2b54:	4c a1       	ldd	r20, Y+36	; 0x24
    2b56:	5d a1       	ldd	r21, Y+37	; 0x25
    2b58:	6a a5       	ldd	r22, Y+42	; 0x2a
    2b5a:	7b a5       	ldd	r23, Y+43	; 0x2b
    2b5c:	8c a5       	ldd	r24, Y+44	; 0x2c
    2b5e:	9d a5       	ldd	r25, Y+45	; 0x2d
    2b60:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2b64:	9b 01       	movw	r18, r22
    2b66:	ac 01       	movw	r20, r24
    2b68:	c7 01       	movw	r24, r14
    2b6a:	b6 01       	movw	r22, r12
    2b6c:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2b70:	9b 01       	movw	r18, r22
    2b72:	ac 01       	movw	r20, r24
    2b74:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2b78:	4b 01       	movw	r8, r22
    2b7a:	5c 01       	movw	r10, r24
    2b7c:	80 92 b7 39 	sts	0x39B7, r8	; 0x8039b7 <gravity>
    2b80:	90 92 b8 39 	sts	0x39B8, r9	; 0x8039b8 <gravity+0x1>
    2b84:	a0 92 b9 39 	sts	0x39B9, r10	; 0x8039b9 <gravity+0x2>
    2b88:	b0 92 ba 39 	sts	0x39BA, r11	; 0x8039ba <gravity+0x3>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:528
    v -> y = 2 * (q -> w*q -> x + q -> y*q -> z);
    2b8c:	2e a1       	ldd	r18, Y+38	; 0x26
    2b8e:	3f a1       	ldd	r19, Y+39	; 0x27
    2b90:	48 a5       	ldd	r20, Y+40	; 0x28
    2b92:	59 a5       	ldd	r21, Y+41	; 0x29
    2b94:	6a a5       	ldd	r22, Y+42	; 0x2a
    2b96:	7b a5       	ldd	r23, Y+43	; 0x2b
    2b98:	8c a5       	ldd	r24, Y+44	; 0x2c
    2b9a:	9d a5       	ldd	r25, Y+45	; 0x2d
    2b9c:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ba0:	6b 01       	movw	r12, r22
    2ba2:	7c 01       	movw	r14, r24
    2ba4:	2e a5       	ldd	r18, Y+46	; 0x2e
    2ba6:	3f a5       	ldd	r19, Y+47	; 0x2f
    2ba8:	48 a9       	ldd	r20, Y+48	; 0x30
    2baa:	59 a9       	ldd	r21, Y+49	; 0x31
    2bac:	6a a1       	ldd	r22, Y+34	; 0x22
    2bae:	7b a1       	ldd	r23, Y+35	; 0x23
    2bb0:	8c a1       	ldd	r24, Y+36	; 0x24
    2bb2:	9d a1       	ldd	r25, Y+37	; 0x25
    2bb4:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2bb8:	9b 01       	movw	r18, r22
    2bba:	ac 01       	movw	r20, r24
    2bbc:	c7 01       	movw	r24, r14
    2bbe:	b6 01       	movw	r22, r12
    2bc0:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2bc4:	9b 01       	movw	r18, r22
    2bc6:	ac 01       	movw	r20, r24
    2bc8:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2bcc:	6a ab       	std	Y+50, r22	; 0x32
    2bce:	7b ab       	std	Y+51, r23	; 0x33
    2bd0:	8c ab       	std	Y+52, r24	; 0x34
    2bd2:	9d ab       	std	Y+53, r25	; 0x35
    2bd4:	60 93 bb 39 	sts	0x39BB, r22	; 0x8039bb <gravity+0x4>
    2bd8:	70 93 bc 39 	sts	0x39BC, r23	; 0x8039bc <gravity+0x5>
    2bdc:	80 93 bd 39 	sts	0x39BD, r24	; 0x8039bd <gravity+0x6>
    2be0:	90 93 be 39 	sts	0x39BE, r25	; 0x8039be <gravity+0x7>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:529
    v -> z = q -> w*q -> w - q -> x*q -> x - q -> y*q -> y + q -> z*q -> z;
    2be4:	2a a5       	ldd	r18, Y+42	; 0x2a
    2be6:	3b a5       	ldd	r19, Y+43	; 0x2b
    2be8:	4c a5       	ldd	r20, Y+44	; 0x2c
    2bea:	5d a5       	ldd	r21, Y+45	; 0x2d
    2bec:	ca 01       	movw	r24, r20
    2bee:	b9 01       	movw	r22, r18
    2bf0:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2bf4:	6b 01       	movw	r12, r22
    2bf6:	7c 01       	movw	r14, r24
    2bf8:	2e a1       	ldd	r18, Y+38	; 0x26
    2bfa:	3f a1       	ldd	r19, Y+39	; 0x27
    2bfc:	48 a5       	ldd	r20, Y+40	; 0x28
    2bfe:	59 a5       	ldd	r21, Y+41	; 0x29
    2c00:	ca 01       	movw	r24, r20
    2c02:	b9 01       	movw	r22, r18
    2c04:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2c08:	9b 01       	movw	r18, r22
    2c0a:	ac 01       	movw	r20, r24
    2c0c:	c7 01       	movw	r24, r14
    2c0e:	b6 01       	movw	r22, r12
    2c10:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2c14:	6b 01       	movw	r12, r22
    2c16:	7c 01       	movw	r14, r24
    2c18:	2a a1       	ldd	r18, Y+34	; 0x22
    2c1a:	3b a1       	ldd	r19, Y+35	; 0x23
    2c1c:	4c a1       	ldd	r20, Y+36	; 0x24
    2c1e:	5d a1       	ldd	r21, Y+37	; 0x25
    2c20:	ca 01       	movw	r24, r20
    2c22:	b9 01       	movw	r22, r18
    2c24:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2c28:	9b 01       	movw	r18, r22
    2c2a:	ac 01       	movw	r20, r24
    2c2c:	c7 01       	movw	r24, r14
    2c2e:	b6 01       	movw	r22, r12
    2c30:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2c34:	6b 01       	movw	r12, r22
    2c36:	7c 01       	movw	r14, r24
    2c38:	2e a5       	ldd	r18, Y+46	; 0x2e
    2c3a:	3f a5       	ldd	r19, Y+47	; 0x2f
    2c3c:	48 a9       	ldd	r20, Y+48	; 0x30
    2c3e:	59 a9       	ldd	r21, Y+49	; 0x31
    2c40:	ca 01       	movw	r24, r20
    2c42:	b9 01       	movw	r22, r18
    2c44:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2c48:	9b 01       	movw	r18, r22
    2c4a:	ac 01       	movw	r20, r24
    2c4c:	c7 01       	movw	r24, r14
    2c4e:	b6 01       	movw	r22, r12
    2c50:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2c54:	6b 01       	movw	r12, r22
    2c56:	7c 01       	movw	r14, r24
    2c58:	c0 92 bf 39 	sts	0x39BF, r12	; 0x8039bf <gravity+0x8>
    2c5c:	d0 92 c0 39 	sts	0x39C0, r13	; 0x8039c0 <gravity+0x9>
    2c60:	e0 92 c1 39 	sts	0x39C1, r14	; 0x8039c1 <gravity+0xa>
    2c64:	f0 92 c2 39 	sts	0x39C2, r15	; 0x8039c2 <gravity+0xb>
dmpGetLinearAccel():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:497
}
// uint8_t MPU6050::dmpSetLinearAccelFilterCoefficient(float coef);
// uint8_t MPU6050::dmpGetLinearAccel(long *data, const uint8_t* packet);
uint8_t MPU6050::dmpGetLinearAccel(VectorInt16 *v, VectorInt16 *vRaw, VectorFloat *gravity) {
    // get rid of the gravity component (+1g = +8192 in standard DMP FIFO packet, sensitivity is 2g)
    v -> x = vRaw -> x - gravity -> x*8192;
    2c68:	b3 01       	movw	r22, r6
    2c6a:	77 0c       	add	r7, r7
    2c6c:	88 0b       	sbc	r24, r24
    2c6e:	99 0b       	sbc	r25, r25
    2c70:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2c74:	2b 01       	movw	r4, r22
    2c76:	3c 01       	movw	r6, r24
    2c78:	20 e0       	ldi	r18, 0x00	; 0
    2c7a:	30 e0       	ldi	r19, 0x00	; 0
    2c7c:	40 e0       	ldi	r20, 0x00	; 0
    2c7e:	56 e4       	ldi	r21, 0x46	; 70
    2c80:	c5 01       	movw	r24, r10
    2c82:	b4 01       	movw	r22, r8
    2c84:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2c88:	9b 01       	movw	r18, r22
    2c8a:	ac 01       	movw	r20, r24
    2c8c:	c3 01       	movw	r24, r6
    2c8e:	b2 01       	movw	r22, r4
    2c90:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2c94:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    2c98:	6e ab       	std	Y+54, r22	; 0x36
    2c9a:	7f ab       	std	Y+55, r23	; 0x37
    2c9c:	88 af       	std	Y+56, r24	; 0x38
    2c9e:	99 af       	std	Y+57, r25	; 0x39
    2ca0:	ee a9       	ldd	r30, Y+54	; 0x36
    2ca2:	ff a9       	ldd	r31, Y+55	; 0x37
    2ca4:	e0 93 c9 39 	sts	0x39C9, r30	; 0x8039c9 <aaReal>
    2ca8:	f0 93 ca 39 	sts	0x39CA, r31	; 0x8039ca <aaReal+0x1>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:498
    v -> y = vRaw -> y - gravity -> y*8192;
    2cac:	b8 01       	movw	r22, r16
    2cae:	11 0f       	add	r17, r17
    2cb0:	88 0b       	sbc	r24, r24
    2cb2:	99 0b       	sbc	r25, r25
    2cb4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2cb8:	4b 01       	movw	r8, r22
    2cba:	5c 01       	movw	r10, r24
    2cbc:	20 e0       	ldi	r18, 0x00	; 0
    2cbe:	30 e0       	ldi	r19, 0x00	; 0
    2cc0:	40 e0       	ldi	r20, 0x00	; 0
    2cc2:	56 e4       	ldi	r21, 0x46	; 70
    2cc4:	6a a9       	ldd	r22, Y+50	; 0x32
    2cc6:	7b a9       	ldd	r23, Y+51	; 0x33
    2cc8:	8c a9       	ldd	r24, Y+52	; 0x34
    2cca:	9d a9       	ldd	r25, Y+53	; 0x35
    2ccc:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2cd0:	9b 01       	movw	r18, r22
    2cd2:	ac 01       	movw	r20, r24
    2cd4:	c5 01       	movw	r24, r10
    2cd6:	b4 01       	movw	r22, r8
    2cd8:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2cdc:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    2ce0:	4b 01       	movw	r8, r22
    2ce2:	60 93 cb 39 	sts	0x39CB, r22	; 0x8039cb <aaReal+0x2>
    2ce6:	70 93 cc 39 	sts	0x39CC, r23	; 0x8039cc <aaReal+0x3>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050_6Axis_MotionApps20.h:499
    v -> z = vRaw -> z - gravity -> z*8192;
    2cea:	b1 01       	movw	r22, r2
    2cec:	33 0c       	add	r3, r3
    2cee:	88 0b       	sbc	r24, r24
    2cf0:	99 0b       	sbc	r25, r25
    2cf2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2cf6:	2b 01       	movw	r4, r22
    2cf8:	3c 01       	movw	r6, r24
    2cfa:	20 e0       	ldi	r18, 0x00	; 0
    2cfc:	30 e0       	ldi	r19, 0x00	; 0
    2cfe:	40 e0       	ldi	r20, 0x00	; 0
    2d00:	56 e4       	ldi	r21, 0x46	; 70
    2d02:	c7 01       	movw	r24, r14
    2d04:	b6 01       	movw	r22, r12
    2d06:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2d0a:	9b 01       	movw	r18, r22
    2d0c:	ac 01       	movw	r20, r24
    2d0e:	c3 01       	movw	r24, r6
    2d10:	b2 01       	movw	r22, r4
    2d12:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2d16:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    2d1a:	60 93 cd 39 	sts	0x39CD, r22	; 0x8039cd <aaReal+0x4>
    2d1e:	70 93 ce 39 	sts	0x39CE, r23	; 0x8039ce <aaReal+0x5>
rotate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:138
            // P_out = q * P_in * conj(q)
            // - P_out is the output vector
            // - q is the orientation quaternion
            // - P_in is the input vector (a*aReal)
            // - conj(q) is the conjugate of the orientation quaternion (q=[w,x,y,z], q*=[w,-x,-y,-z])
            Quaternion p(0, x, y, z);
    2d22:	07 2e       	mov	r0, r23
    2d24:	00 0c       	add	r0, r0
    2d26:	88 0b       	sbc	r24, r24
    2d28:	99 0b       	sbc	r25, r25
    2d2a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2d2e:	6a ab       	std	Y+50, r22	; 0x32
    2d30:	7b ab       	std	Y+51, r23	; 0x33
    2d32:	8c ab       	std	Y+52, r24	; 0x34
    2d34:	9d ab       	std	Y+53, r25	; 0x35
    2d36:	b4 01       	movw	r22, r8
    2d38:	99 0c       	add	r9, r9
    2d3a:	88 0b       	sbc	r24, r24
    2d3c:	99 0b       	sbc	r25, r25
    2d3e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2d42:	6b 01       	movw	r12, r22
    2d44:	7c 01       	movw	r14, r24
    2d46:	2e a9       	ldd	r18, Y+54	; 0x36
    2d48:	3f a9       	ldd	r19, Y+55	; 0x37
    2d4a:	b9 01       	movw	r22, r18
    2d4c:	33 0f       	add	r19, r19
    2d4e:	88 0b       	sbc	r24, r24
    2d50:	99 0b       	sbc	r25, r25
    2d52:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    2d56:	4b 01       	movw	r8, r22
    2d58:	5c 01       	movw	r10, r24
getProduct():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    2d5a:	2a a9       	ldd	r18, Y+50	; 0x32
    2d5c:	3b a9       	ldd	r19, Y+51	; 0x33
    2d5e:	4c a9       	ldd	r20, Y+52	; 0x34
    2d60:	5d a9       	ldd	r21, Y+53	; 0x35
    2d62:	6a a5       	ldd	r22, Y+42	; 0x2a
    2d64:	7b a5       	ldd	r23, Y+43	; 0x2b
    2d66:	8c a5       	ldd	r24, Y+44	; 0x2c
    2d68:	9d a5       	ldd	r25, Y+45	; 0x2d
    2d6a:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2d6e:	2b 01       	movw	r4, r22
    2d70:	3c 01       	movw	r6, r24
    2d72:	a7 01       	movw	r20, r14
    2d74:	96 01       	movw	r18, r12
    2d76:	6e a1       	ldd	r22, Y+38	; 0x26
    2d78:	7f a1       	ldd	r23, Y+39	; 0x27
    2d7a:	88 a5       	ldd	r24, Y+40	; 0x28
    2d7c:	99 a5       	ldd	r25, Y+41	; 0x29
    2d7e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2d82:	9b 01       	movw	r18, r22
    2d84:	ac 01       	movw	r20, r24
    2d86:	c3 01       	movw	r24, r6
    2d88:	b2 01       	movw	r22, r4
    2d8a:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2d8e:	2b 01       	movw	r4, r22
    2d90:	3c 01       	movw	r6, r24
    2d92:	a5 01       	movw	r20, r10
    2d94:	94 01       	movw	r18, r8
    2d96:	6a a1       	ldd	r22, Y+34	; 0x22
    2d98:	7b a1       	ldd	r23, Y+35	; 0x23
    2d9a:	8c a1       	ldd	r24, Y+36	; 0x24
    2d9c:	9d a1       	ldd	r25, Y+37	; 0x25
    2d9e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2da2:	9b 01       	movw	r18, r22
    2da4:	ac 01       	movw	r20, r24
    2da6:	c3 01       	movw	r24, r6
    2da8:	b2 01       	movw	r22, r4
    2daa:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2dae:	2b 01       	movw	r4, r22
    2db0:	3c 01       	movw	r6, r24
    2db2:	20 e0       	ldi	r18, 0x00	; 0
    2db4:	30 e0       	ldi	r19, 0x00	; 0
    2db6:	a9 01       	movw	r20, r18
    2db8:	6e a5       	ldd	r22, Y+46	; 0x2e
    2dba:	7f a5       	ldd	r23, Y+47	; 0x2f
    2dbc:	88 a9       	ldd	r24, Y+48	; 0x30
    2dbe:	99 a9       	ldd	r25, Y+49	; 0x31
    2dc0:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2dc4:	9b 01       	movw	r18, r22
    2dc6:	ac 01       	movw	r20, r24
    2dc8:	c3 01       	movw	r24, r6
    2dca:	b2 01       	movw	r22, r4
    2dcc:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2dd0:	6e ab       	std	Y+54, r22	; 0x36
    2dd2:	7f ab       	std	Y+55, r23	; 0x37
    2dd4:	88 af       	std	Y+56, r24	; 0x38
    2dd6:	99 af       	std	Y+57, r25	; 0x39
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:65
            //     (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
    2dd8:	a7 01       	movw	r20, r14
    2dda:	96 01       	movw	r18, r12
    2ddc:	6a a5       	ldd	r22, Y+42	; 0x2a
    2dde:	7b a5       	ldd	r23, Y+43	; 0x2b
    2de0:	8c a5       	ldd	r24, Y+44	; 0x2c
    2de2:	9d a5       	ldd	r25, Y+45	; 0x2d
    2de4:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2de8:	2b 01       	movw	r4, r22
    2dea:	3c 01       	movw	r6, r24
    2dec:	2a a9       	ldd	r18, Y+50	; 0x32
    2dee:	3b a9       	ldd	r19, Y+51	; 0x33
    2df0:	4c a9       	ldd	r20, Y+52	; 0x34
    2df2:	5d a9       	ldd	r21, Y+53	; 0x35
    2df4:	6e a1       	ldd	r22, Y+38	; 0x26
    2df6:	7f a1       	ldd	r23, Y+39	; 0x27
    2df8:	88 a5       	ldd	r24, Y+40	; 0x28
    2dfa:	99 a5       	ldd	r25, Y+41	; 0x29
    2dfc:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2e00:	9b 01       	movw	r18, r22
    2e02:	ac 01       	movw	r20, r24
    2e04:	c3 01       	movw	r24, r6
    2e06:	b2 01       	movw	r22, r4
    2e08:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2e0c:	2b 01       	movw	r4, r22
    2e0e:	3c 01       	movw	r6, r24
    2e10:	20 e0       	ldi	r18, 0x00	; 0
    2e12:	30 e0       	ldi	r19, 0x00	; 0
    2e14:	a9 01       	movw	r20, r18
    2e16:	6a a1       	ldd	r22, Y+34	; 0x22
    2e18:	7b a1       	ldd	r23, Y+35	; 0x23
    2e1a:	8c a1       	ldd	r24, Y+36	; 0x24
    2e1c:	9d a1       	ldd	r25, Y+37	; 0x25
    2e1e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2e22:	9b 01       	movw	r18, r22
    2e24:	ac 01       	movw	r20, r24
    2e26:	c3 01       	movw	r24, r6
    2e28:	b2 01       	movw	r22, r4
    2e2a:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2e2e:	2b 01       	movw	r4, r22
    2e30:	3c 01       	movw	r6, r24
    2e32:	a5 01       	movw	r20, r10
    2e34:	94 01       	movw	r18, r8
    2e36:	6e a5       	ldd	r22, Y+46	; 0x2e
    2e38:	7f a5       	ldd	r23, Y+47	; 0x2f
    2e3a:	88 a9       	ldd	r24, Y+48	; 0x30
    2e3c:	99 a9       	ldd	r25, Y+49	; 0x31
    2e3e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2e42:	9b 01       	movw	r18, r22
    2e44:	ac 01       	movw	r20, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    2e46:	c3 01       	movw	r24, r6
    2e48:	b2 01       	movw	r22, r4
    2e4a:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2e4e:	6a af       	std	Y+58, r22	; 0x3a
    2e50:	7b af       	std	Y+59, r23	; 0x3b
    2e52:	8c af       	std	Y+60, r24	; 0x3c
    2e54:	9d af       	std	Y+61, r25	; 0x3d
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:64
            //     (Q1 * Q2).x = (w1x2 + x1w2 + y1z2 - z1y2)
            //     (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
    2e56:	a5 01       	movw	r20, r10
    2e58:	94 01       	movw	r18, r8
    2e5a:	6a a5       	ldd	r22, Y+42	; 0x2a
    2e5c:	7b a5       	ldd	r23, Y+43	; 0x2b
    2e5e:	8c a5       	ldd	r24, Y+44	; 0x2c
    2e60:	9d a5       	ldd	r25, Y+45	; 0x2d
    2e62:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2e66:	2b 01       	movw	r4, r22
    2e68:	3c 01       	movw	r6, r24
    2e6a:	20 e0       	ldi	r18, 0x00	; 0
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	a9 01       	movw	r20, r18
    2e70:	6e a1       	ldd	r22, Y+38	; 0x26
    2e72:	7f a1       	ldd	r23, Y+39	; 0x27
    2e74:	88 a5       	ldd	r24, Y+40	; 0x28
    2e76:	99 a5       	ldd	r25, Y+41	; 0x29
    2e78:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2e7c:	9b 01       	movw	r18, r22
    2e7e:	ac 01       	movw	r20, r24
    2e80:	c3 01       	movw	r24, r6
    2e82:	b2 01       	movw	r22, r4
    2e84:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2e88:	2b 01       	movw	r4, r22
    2e8a:	3c 01       	movw	r6, r24
    2e8c:	2a a9       	ldd	r18, Y+50	; 0x32
    2e8e:	3b a9       	ldd	r19, Y+51	; 0x33
    2e90:	4c a9       	ldd	r20, Y+52	; 0x34
    2e92:	5d a9       	ldd	r21, Y+53	; 0x35
    2e94:	6a a1       	ldd	r22, Y+34	; 0x22
    2e96:	7b a1       	ldd	r23, Y+35	; 0x23
    2e98:	8c a1       	ldd	r24, Y+36	; 0x24
    2e9a:	9d a1       	ldd	r25, Y+37	; 0x25
    2e9c:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ea0:	9b 01       	movw	r18, r22
    2ea2:	ac 01       	movw	r20, r24
    2ea4:	c3 01       	movw	r24, r6
    2ea6:	b2 01       	movw	r22, r4
    2ea8:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2eac:	2b 01       	movw	r4, r22
    2eae:	3c 01       	movw	r6, r24
    2eb0:	a7 01       	movw	r20, r14
    2eb2:	96 01       	movw	r18, r12
    2eb4:	6e a5       	ldd	r22, Y+46	; 0x2e
    2eb6:	7f a5       	ldd	r23, Y+47	; 0x2f
    2eb8:	88 a9       	ldd	r24, Y+48	; 0x30
    2eba:	99 a9       	ldd	r25, Y+49	; 0x31
    2ebc:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ec0:	9b 01       	movw	r18, r22
    2ec2:	ac 01       	movw	r20, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    2ec4:	c3 01       	movw	r24, r6
    2ec6:	b2 01       	movw	r22, r4
    2ec8:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2ecc:	22 96       	adiw	r28, 0x02	; 2
    2ece:	6c af       	std	Y+60, r22	; 0x3c
    2ed0:	7d af       	std	Y+61, r23	; 0x3d
    2ed2:	8e af       	std	Y+62, r24	; 0x3e
    2ed4:	9f af       	std	Y+63, r25	; 0x3f
    2ed6:	22 97       	sbiw	r28, 0x02	; 2
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:63
            //     (Q1 * Q2).w = (w1w2 - x1x2 - y1y2 - z1z2)
            //     (Q1 * Q2).x = (w1x2 + x1w2 + y1z2 - z1y2)
            //     (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
    2ed8:	20 e0       	ldi	r18, 0x00	; 0
    2eda:	30 e0       	ldi	r19, 0x00	; 0
    2edc:	a9 01       	movw	r20, r18
    2ede:	6a a5       	ldd	r22, Y+42	; 0x2a
    2ee0:	7b a5       	ldd	r23, Y+43	; 0x2b
    2ee2:	8c a5       	ldd	r24, Y+44	; 0x2c
    2ee4:	9d a5       	ldd	r25, Y+45	; 0x2d
    2ee6:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2eea:	2b 01       	movw	r4, r22
    2eec:	3c 01       	movw	r6, r24
    2eee:	a5 01       	movw	r20, r10
    2ef0:	94 01       	movw	r18, r8
    2ef2:	6e a1       	ldd	r22, Y+38	; 0x26
    2ef4:	7f a1       	ldd	r23, Y+39	; 0x27
    2ef6:	88 a5       	ldd	r24, Y+40	; 0x28
    2ef8:	99 a5       	ldd	r25, Y+41	; 0x29
    2efa:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2efe:	9b 01       	movw	r18, r22
    2f00:	ac 01       	movw	r20, r24
    2f02:	c3 01       	movw	r24, r6
    2f04:	b2 01       	movw	r22, r4
    2f06:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2f0a:	4b 01       	movw	r8, r22
    2f0c:	5c 01       	movw	r10, r24
    2f0e:	a7 01       	movw	r20, r14
    2f10:	96 01       	movw	r18, r12
    2f12:	6a a1       	ldd	r22, Y+34	; 0x22
    2f14:	7b a1       	ldd	r23, Y+35	; 0x23
    2f16:	8c a1       	ldd	r24, Y+36	; 0x24
    2f18:	9d a1       	ldd	r25, Y+37	; 0x25
    2f1a:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2f1e:	9b 01       	movw	r18, r22
    2f20:	ac 01       	movw	r20, r24
    2f22:	c5 01       	movw	r24, r10
    2f24:	b4 01       	movw	r22, r8
    2f26:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2f2a:	6b 01       	movw	r12, r22
    2f2c:	7c 01       	movw	r14, r24
    2f2e:	2a a9       	ldd	r18, Y+50	; 0x32
    2f30:	3b a9       	ldd	r19, Y+51	; 0x33
    2f32:	4c a9       	ldd	r20, Y+52	; 0x34
    2f34:	5d a9       	ldd	r21, Y+53	; 0x35
    2f36:	6e a5       	ldd	r22, Y+46	; 0x2e
    2f38:	7f a5       	ldd	r23, Y+47	; 0x2f
    2f3a:	88 a9       	ldd	r24, Y+48	; 0x30
    2f3c:	99 a9       	ldd	r25, Y+49	; 0x31
    2f3e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2f42:	9b 01       	movw	r18, r22
    2f44:	ac 01       	movw	r20, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    2f46:	c7 01       	movw	r24, r14
    2f48:	b6 01       	movw	r22, r12
    2f4a:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    2f4e:	2b 01       	movw	r4, r22
    2f50:	3c 01       	movw	r6, r24
getConjugate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:70
        }

        Quaternion getConjugate() {
            return Quaternion(w, -x, -y, -z);
    2f52:	8e a4       	ldd	r8, Y+46	; 0x2e
    2f54:	9f a4       	ldd	r9, Y+47	; 0x2f
    2f56:	a8 a8       	ldd	r10, Y+48	; 0x30
    2f58:	b9 a8       	ldd	r11, Y+49	; 0x31
    2f5a:	b7 fa       	bst	r11, 7
    2f5c:	b0 94       	com	r11
    2f5e:	b7 f8       	bld	r11, 7
    2f60:	b0 94       	com	r11
    2f62:	8a a1       	ldd	r24, Y+34	; 0x22
    2f64:	9b a1       	ldd	r25, Y+35	; 0x23
    2f66:	ac a1       	ldd	r26, Y+36	; 0x24
    2f68:	bd a1       	ldd	r27, Y+37	; 0x25
    2f6a:	b0 58       	subi	r27, 0x80	; 128
    2f6c:	8a a3       	std	Y+34, r24	; 0x22
    2f6e:	9b a3       	std	Y+35, r25	; 0x23
    2f70:	ac a3       	std	Y+36, r26	; 0x24
    2f72:	bd a3       	std	Y+37, r27	; 0x25
    2f74:	8e a1       	ldd	r24, Y+38	; 0x26
    2f76:	9f a1       	ldd	r25, Y+39	; 0x27
    2f78:	a8 a5       	ldd	r26, Y+40	; 0x28
    2f7a:	b9 a5       	ldd	r27, Y+41	; 0x29
    2f7c:	b0 58       	subi	r27, 0x80	; 128
    2f7e:	8e a3       	std	Y+38, r24	; 0x26
    2f80:	9f a3       	std	Y+39, r25	; 0x27
    2f82:	a8 a7       	std	Y+40, r26	; 0x28
    2f84:	b9 a7       	std	Y+41, r27	; 0x29
getProduct():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:64
            //     (Q1 * Q2).x = (w1x2 + x1w2 + y1z2 - z1y2)
            //     (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
    2f86:	a3 01       	movw	r20, r6
    2f88:	92 01       	movw	r18, r4
    2f8a:	bc 01       	movw	r22, r24
    2f8c:	cd 01       	movw	r24, r26
    2f8e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2f92:	6b 01       	movw	r12, r22
    2f94:	7c 01       	movw	r14, r24
    2f96:	22 96       	adiw	r28, 0x02	; 2
    2f98:	2c ad       	ldd	r18, Y+60	; 0x3c
    2f9a:	3d ad       	ldd	r19, Y+61	; 0x3d
    2f9c:	4e ad       	ldd	r20, Y+62	; 0x3e
    2f9e:	5f ad       	ldd	r21, Y+63	; 0x3f
    2fa0:	22 97       	sbiw	r28, 0x02	; 2
    2fa2:	6a a5       	ldd	r22, Y+42	; 0x2a
    2fa4:	7b a5       	ldd	r23, Y+43	; 0x2b
    2fa6:	8c a5       	ldd	r24, Y+44	; 0x2c
    2fa8:	9d a5       	ldd	r25, Y+45	; 0x2d
    2faa:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2fae:	9b 01       	movw	r18, r22
    2fb0:	ac 01       	movw	r20, r24
    2fb2:	c7 01       	movw	r24, r14
    2fb4:	b6 01       	movw	r22, r12
    2fb6:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2fba:	6b 01       	movw	r12, r22
    2fbc:	7c 01       	movw	r14, r24
    2fbe:	2a ad       	ldd	r18, Y+58	; 0x3a
    2fc0:	3b ad       	ldd	r19, Y+59	; 0x3b
    2fc2:	4c ad       	ldd	r20, Y+60	; 0x3c
    2fc4:	5d ad       	ldd	r21, Y+61	; 0x3d
    2fc6:	c5 01       	movw	r24, r10
    2fc8:	b4 01       	movw	r22, r8
    2fca:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2fce:	9b 01       	movw	r18, r22
    2fd0:	ac 01       	movw	r20, r24
    2fd2:	c7 01       	movw	r24, r14
    2fd4:	b6 01       	movw	r22, r12
    2fd6:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    2fda:	6b 01       	movw	r12, r22
    2fdc:	7c 01       	movw	r14, r24
    2fde:	2e a9       	ldd	r18, Y+54	; 0x36
    2fe0:	3f a9       	ldd	r19, Y+55	; 0x37
    2fe2:	48 ad       	ldd	r20, Y+56	; 0x38
    2fe4:	59 ad       	ldd	r21, Y+57	; 0x39
    2fe6:	6a a1       	ldd	r22, Y+34	; 0x22
    2fe8:	7b a1       	ldd	r23, Y+35	; 0x23
    2fea:	8c a1       	ldd	r24, Y+36	; 0x24
    2fec:	9d a1       	ldd	r25, Y+37	; 0x25
    2fee:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    2ff2:	9b 01       	movw	r18, r22
    2ff4:	ac 01       	movw	r20, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    2ff6:	c7 01       	movw	r24, r14
    2ff8:	b6 01       	movw	r22, r12
    2ffa:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
rotate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:147

            // quaternion multiplication: p * conj(q), stored back in p
            p = p.getProduct(q -> getConjugate());

            // p quaternion is now [0, x', y', z']
            x = p.x;
    2ffe:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    3002:	60 93 c3 39 	sts	0x39C3, r22	; 0x8039c3 <aaWorld>
    3006:	70 93 c4 39 	sts	0x39C4, r23	; 0x8039c4 <aaWorld+0x1>
getProduct():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:65
            //     (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
    300a:	a3 01       	movw	r20, r6
    300c:	92 01       	movw	r18, r4
    300e:	6a a1       	ldd	r22, Y+34	; 0x22
    3010:	7b a1       	ldd	r23, Y+35	; 0x23
    3012:	8c a1       	ldd	r24, Y+36	; 0x24
    3014:	9d a1       	ldd	r25, Y+37	; 0x25
    3016:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    301a:	6b 01       	movw	r12, r22
    301c:	7c 01       	movw	r14, r24
    301e:	22 96       	adiw	r28, 0x02	; 2
    3020:	2c ad       	ldd	r18, Y+60	; 0x3c
    3022:	3d ad       	ldd	r19, Y+61	; 0x3d
    3024:	4e ad       	ldd	r20, Y+62	; 0x3e
    3026:	5f ad       	ldd	r21, Y+63	; 0x3f
    3028:	22 97       	sbiw	r28, 0x02	; 2
    302a:	c5 01       	movw	r24, r10
    302c:	b4 01       	movw	r22, r8
    302e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    3032:	9b 01       	movw	r18, r22
    3034:	ac 01       	movw	r20, r24
    3036:	c7 01       	movw	r24, r14
    3038:	b6 01       	movw	r22, r12
    303a:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    303e:	6b 01       	movw	r12, r22
    3040:	7c 01       	movw	r14, r24
    3042:	2a ad       	ldd	r18, Y+58	; 0x3a
    3044:	3b ad       	ldd	r19, Y+59	; 0x3b
    3046:	4c ad       	ldd	r20, Y+60	; 0x3c
    3048:	5d ad       	ldd	r21, Y+61	; 0x3d
    304a:	6a a5       	ldd	r22, Y+42	; 0x2a
    304c:	7b a5       	ldd	r23, Y+43	; 0x2b
    304e:	8c a5       	ldd	r24, Y+44	; 0x2c
    3050:	9d a5       	ldd	r25, Y+45	; 0x2d
    3052:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    3056:	9b 01       	movw	r18, r22
    3058:	ac 01       	movw	r20, r24
    305a:	c7 01       	movw	r24, r14
    305c:	b6 01       	movw	r22, r12
    305e:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    3062:	6b 01       	movw	r12, r22
    3064:	7c 01       	movw	r14, r24
    3066:	2e a9       	ldd	r18, Y+54	; 0x36
    3068:	3f a9       	ldd	r19, Y+55	; 0x37
    306a:	48 ad       	ldd	r20, Y+56	; 0x38
    306c:	59 ad       	ldd	r21, Y+57	; 0x39
    306e:	6e a1       	ldd	r22, Y+38	; 0x26
    3070:	7f a1       	ldd	r23, Y+39	; 0x27
    3072:	88 a5       	ldd	r24, Y+40	; 0x28
    3074:	99 a5       	ldd	r25, Y+41	; 0x29
    3076:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    307a:	9b 01       	movw	r18, r22
    307c:	ac 01       	movw	r20, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    307e:	c7 01       	movw	r24, r14
    3080:	b6 01       	movw	r22, r12
    3082:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
rotate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:148
            // quaternion multiplication: p * conj(q), stored back in p
            p = p.getProduct(q -> getConjugate());

            // p quaternion is now [0, x', y', z']
            x = p.x;
            y = p.y;
    3086:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    308a:	6b 01       	movw	r12, r22
    308c:	60 93 c5 39 	sts	0x39C5, r22	; 0x8039c5 <aaWorld+0x2>
    3090:	70 93 c6 39 	sts	0x39C6, r23	; 0x8039c6 <aaWorld+0x3>
getProduct():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:66
            //     (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2
            return Quaternion(
                w*q.w - x*q.x - y*q.y - z*q.z,  // new w
                w*q.x + x*q.w + y*q.z - z*q.y,  // new x
                w*q.y - x*q.z + y*q.w + z*q.x,  // new y
                w*q.z + x*q.y - y*q.x + z*q.w); // new z
    3094:	a3 01       	movw	r20, r6
    3096:	92 01       	movw	r18, r4
    3098:	c5 01       	movw	r24, r10
    309a:	b4 01       	movw	r22, r8
    309c:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    30a0:	4b 01       	movw	r8, r22
    30a2:	5c 01       	movw	r10, r24
    30a4:	22 96       	adiw	r28, 0x02	; 2
    30a6:	2c ad       	ldd	r18, Y+60	; 0x3c
    30a8:	3d ad       	ldd	r19, Y+61	; 0x3d
    30aa:	4e ad       	ldd	r20, Y+62	; 0x3e
    30ac:	5f ad       	ldd	r21, Y+63	; 0x3f
    30ae:	22 97       	sbiw	r28, 0x02	; 2
    30b0:	6a a1       	ldd	r22, Y+34	; 0x22
    30b2:	7b a1       	ldd	r23, Y+35	; 0x23
    30b4:	8c a1       	ldd	r24, Y+36	; 0x24
    30b6:	9d a1       	ldd	r25, Y+37	; 0x25
    30b8:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    30bc:	9b 01       	movw	r18, r22
    30be:	ac 01       	movw	r20, r24
    30c0:	c5 01       	movw	r24, r10
    30c2:	b4 01       	movw	r22, r8
    30c4:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
    30c8:	4b 01       	movw	r8, r22
    30ca:	5c 01       	movw	r10, r24
    30cc:	2a ad       	ldd	r18, Y+58	; 0x3a
    30ce:	3b ad       	ldd	r19, Y+59	; 0x3b
    30d0:	4c ad       	ldd	r20, Y+60	; 0x3c
    30d2:	5d ad       	ldd	r21, Y+61	; 0x3d
    30d4:	6e a1       	ldd	r22, Y+38	; 0x26
    30d6:	7f a1       	ldd	r23, Y+39	; 0x27
    30d8:	88 a5       	ldd	r24, Y+40	; 0x28
    30da:	99 a5       	ldd	r25, Y+41	; 0x29
    30dc:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    30e0:	9b 01       	movw	r18, r22
    30e2:	ac 01       	movw	r20, r24
    30e4:	c5 01       	movw	r24, r10
    30e6:	b4 01       	movw	r22, r8
    30e8:	0e 94 55 19 	call	0x32aa	; 0x32aa <__subsf3>
    30ec:	4b 01       	movw	r8, r22
    30ee:	5c 01       	movw	r10, r24
    30f0:	2e a9       	ldd	r18, Y+54	; 0x36
    30f2:	3f a9       	ldd	r19, Y+55	; 0x37
    30f4:	48 ad       	ldd	r20, Y+56	; 0x38
    30f6:	59 ad       	ldd	r21, Y+57	; 0x39
    30f8:	6a a5       	ldd	r22, Y+42	; 0x2a
    30fa:	7b a5       	ldd	r23, Y+43	; 0x2b
    30fc:	8c a5       	ldd	r24, Y+44	; 0x2c
    30fe:	9d a5       	ldd	r25, Y+45	; 0x2d
    3100:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    3104:	9b 01       	movw	r18, r22
    3106:	ac 01       	movw	r20, r24
    3108:	c5 01       	movw	r24, r10
    310a:	b4 01       	movw	r22, r8
    310c:	0e 94 56 19 	call	0x32ac	; 0x32ac <__addsf3>
rotate():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/helper_3dmath.h:149
            p = p.getProduct(q -> getConjugate());

            // p quaternion is now [0, x', y', z']
            x = p.x;
            y = p.y;
            z = p.z;
    3110:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    3114:	4b 01       	movw	r8, r22
    3116:	60 93 c7 39 	sts	0x39C7, r22	; 0x8039c7 <aaWorld+0x4>
    311a:	70 93 c8 39 	sts	0x39C8, r23	; 0x8039c8 <aaWorld+0x5>
loop():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:106
  mpu.dmpGetGravity(&gravity, &q);
  mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);
  mpu.dmpGetLinearAccelInWorld(&aaWorld, &aaReal, &q);

  //Normalizacja
  float normalAccX = (float)aaWorld.y * (9.80665f / 8192.0f); 
    311e:	b6 01       	movw	r22, r12
    3120:	dd 0c       	add	r13, r13
    3122:	88 0b       	sbc	r24, r24
    3124:	99 0b       	sbc	r25, r25
    3126:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    312a:	2a e0       	ldi	r18, 0x0A	; 10
    312c:	38 ee       	ldi	r19, 0xE8	; 232
    312e:	4c e9       	ldi	r20, 0x9C	; 156
    3130:	5a e3       	ldi	r21, 0x3A	; 58
    3132:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    3136:	6b 01       	movw	r12, r22
    3138:	7c 01       	movw	r14, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:107
  float normalAccY = (float)aaWorld.z * (9.80665f / 8192.0f); 
    313a:	b4 01       	movw	r22, r8
    313c:	99 0c       	add	r9, r9
    313e:	88 0b       	sbc	r24, r24
    3140:	99 0b       	sbc	r25, r25
    3142:	0e 94 ff 19 	call	0x33fe	; 0x33fe <__floatsisf>
    3146:	2a e0       	ldi	r18, 0x0A	; 10
    3148:	38 ee       	ldi	r19, 0xE8	; 232
    314a:	4c e9       	ldi	r20, 0x9C	; 156
    314c:	5a e3       	ldi	r21, 0x3A	; 58
    314e:	0e 94 b4 1a 	call	0x3568	; 0x3568 <__mulsf3>
    3152:	4b 01       	movw	r8, r22
    3154:	5c 01       	movw	r10, r24
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:111

  //Wypenij bufer do wysania do STM
  //Wy jeli przyspieszenie jest mniejsze ni 1 m/s^2
  if (normalAccX <= 1.0f && normalAccX >= -1.0f) response.accX = 0.0f;
    3156:	20 e0       	ldi	r18, 0x00	; 0
    3158:	30 e0       	ldi	r19, 0x00	; 0
    315a:	40 e8       	ldi	r20, 0x80	; 128
    315c:	5f e3       	ldi	r21, 0x3F	; 63
    315e:	c7 01       	movw	r24, r14
    3160:	b6 01       	movw	r22, r12
    3162:	0e 94 c2 19 	call	0x3384	; 0x3384 <__cmpsf2>
    3166:	18 16       	cp	r1, r24
    3168:	0c f4       	brge	.+2      	; 0x316c <main+0xe50>
    316a:	7a c0       	rjmp	.+244    	; 0x3260 <main+0xf44>
    316c:	20 e0       	ldi	r18, 0x00	; 0
    316e:	30 e0       	ldi	r19, 0x00	; 0
    3170:	40 e8       	ldi	r20, 0x80	; 128
    3172:	5f eb       	ldi	r21, 0xBF	; 191
    3174:	c7 01       	movw	r24, r14
    3176:	b6 01       	movw	r22, r12
    3178:	0e 94 af 1a 	call	0x355e	; 0x355e <__gesf2>
    317c:	87 fd       	sbrc	r24, 7
    317e:	70 c0       	rjmp	.+224    	; 0x3260 <main+0xf44>
    3180:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <response>
    3184:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <response+0x1>
    3188:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <response+0x2>
    318c:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <response+0x3>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:113
  else response.accX = normalAccX;
  if (normalAccY <= 1.0f && normalAccY >= -1.0f) response.accY = 0.0f;
    3190:	20 e0       	ldi	r18, 0x00	; 0
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	40 e8       	ldi	r20, 0x80	; 128
    3196:	5f e3       	ldi	r21, 0x3F	; 63
    3198:	c5 01       	movw	r24, r10
    319a:	b4 01       	movw	r22, r8
    319c:	0e 94 c2 19 	call	0x3384	; 0x3384 <__cmpsf2>
    31a0:	18 16       	cp	r1, r24
    31a2:	0c f4       	brge	.+2      	; 0x31a6 <main+0xe8a>
    31a4:	66 c0       	rjmp	.+204    	; 0x3272 <main+0xf56>
    31a6:	20 e0       	ldi	r18, 0x00	; 0
    31a8:	30 e0       	ldi	r19, 0x00	; 0
    31aa:	40 e8       	ldi	r20, 0x80	; 128
    31ac:	5f eb       	ldi	r21, 0xBF	; 191
    31ae:	c5 01       	movw	r24, r10
    31b0:	b4 01       	movw	r22, r8
    31b2:	0e 94 af 1a 	call	0x355e	; 0x355e <__gesf2>
    31b6:	87 fd       	sbrc	r24, 7
    31b8:	5c c0       	rjmp	.+184    	; 0x3272 <main+0xf56>
    31ba:	10 92 43 38 	sts	0x3843, r1	; 0x803843 <response+0x4>
    31be:	10 92 44 38 	sts	0x3844, r1	; 0x803844 <response+0x5>
    31c2:	10 92 45 38 	sts	0x3845, r1	; 0x803845 <response+0x6>
    31c6:	10 92 46 38 	sts	0x3846, r1	; 0x803846 <response+0x7>
digitalRead():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/wiring_digital.c:225

	/* Get port and check valid port */
	PORT_t *port = digitalPinToPortStruct(pin);

	/* Read pin value from PORTx.IN register */
	if(port->IN & bit_mask){
    31ca:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
    31ce:	87 ff       	sbrs	r24, 7
    31d0:	59 c0       	rjmp	.+178    	; 0x3284 <main+0xf68>
loop():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:117
  else response.accY = normalAccY;
  
  if (digitalRead(B1_PIN) == LOW) response.startContr = true; //Sprawd, czy naciskany jest przycisk
  else response.startContr = false;
    31d2:	10 92 47 38 	sts	0x3847, r1	; 0x803847 <response+0x8>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:118
  response.checksum = (int8_t)response.accX + (int8_t)response.accY + response.startContr;
    31d6:	60 91 3f 38 	lds	r22, 0x383F	; 0x80383f <response>
    31da:	70 91 40 38 	lds	r23, 0x3840	; 0x803840 <response+0x1>
    31de:	80 91 41 38 	lds	r24, 0x3841	; 0x803841 <response+0x2>
    31e2:	90 91 42 38 	lds	r25, 0x3842	; 0x803842 <response+0x3>
    31e6:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    31ea:	16 2f       	mov	r17, r22
    31ec:	60 91 43 38 	lds	r22, 0x3843	; 0x803843 <response+0x4>
    31f0:	70 91 44 38 	lds	r23, 0x3844	; 0x803844 <response+0x5>
    31f4:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <response+0x6>
    31f8:	90 91 46 38 	lds	r25, 0x3846	; 0x803846 <response+0x7>
    31fc:	0e 94 c7 19 	call	0x338e	; 0x338e <__fixsfsi>
    3200:	16 0f       	add	r17, r22
    3202:	60 91 47 38 	lds	r22, 0x3847	; 0x803847 <response+0x8>
    3206:	16 0f       	add	r17, r22
    3208:	10 93 48 38 	sts	0x3848, r17	; 0x803848 <response+0x9>
writeAckPayload():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1398
    }

    _SPI.transfern( (char *) spi_txbuff, size);
    endTransaction();
    #else
    beginTransaction();
    320c:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <RF24::beginTransaction() [clone .constprop.67]>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1399
    _SPI.transfer(W_ACK_PAYLOAD | (pipe & 0x07));
    3210:	89 ea       	ldi	r24, 0xA9	; 169
    3212:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    3216:	8f e3       	ldi	r24, 0x3F	; 63
    3218:	e8 2e       	mov	r14, r24
    321a:	88 e3       	ldi	r24, 0x38	; 56
    321c:	f8 2e       	mov	r15, r24
    321e:	11 e2       	ldi	r17, 0x21	; 33
    3220:	11 50       	subi	r17, 0x01	; 1
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1401

    while (data_len--) {
    3222:	a1 f1       	breq	.+104    	; 0x328c <main+0xf70>
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1402
        _SPI.transfer(*current++);
    3224:	d7 01       	movw	r26, r14
    3226:	8d 91       	ld	r24, X+
    3228:	7d 01       	movw	r14, r26
    322a:	0e 94 3e 04 	call	0x87c	; 0x87c <SPIClass::transfer(unsigned char) [clone .constprop.65]>
    322e:	f8 cf       	rjmp	.-16     	; 0x3220 <main+0xf04>
printNumber():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino\api/Print.cpp:245

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    3230:	09 5c       	subi	r16, 0xC9	; 201
    3232:	7a c9       	rjmp	.-3340   	; 0x2528 <main+0x20c>
closeReadingPipe():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1291

/****************************************************************************/

void RF24::closeReadingPipe(uint8_t pipe)
{
    write_register(EN_RXADDR, read_register(EN_RXADDR) & ~_BV(pgm_read_byte(&child_pipe_enable[pipe])));
    3234:	82 e0       	ldi	r24, 0x02	; 2
    3236:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <RF24::read_register(unsigned char) [clone .constprop.64]>
    323a:	e1 e1       	ldi	r30, 0x11	; 17
    323c:	f8 e0       	ldi	r31, 0x08	; 8
    323e:	e4 91       	lpm	r30, Z
    3240:	21 e0       	ldi	r18, 0x01	; 1
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	01 c0       	rjmp	.+2      	; 0x3248 <main+0xf2c>
    3246:	22 0f       	add	r18, r18
    3248:	ea 95       	dec	r30
    324a:	ea f7       	brpl	.-6      	; 0x3246 <main+0xf2a>
    324c:	20 95       	com	r18
    324e:	62 2f       	mov	r22, r18
    3250:	68 23       	and	r22, r24
    3252:	82 e0       	ldi	r24, 0x02	; 2
    3254:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <RF24::write_register(unsigned char, unsigned char) [clone .constprop.62]>
    3258:	95 cb       	rjmp	.-2262   	; 0x2984 <main+0x668>
getFIFOBytes():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/MPU6050.cpp:2740
    } else {
    	*data = 0;
    325a:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <fifoBuffer>
    325e:	d1 cb       	rjmp	.-2142   	; 0x2a02 <main+0x6e6>
loop():
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:112
  float normalAccY = (float)aaWorld.z * (9.80665f / 8192.0f); 

  //Wypenij bufer do wysania do STM
  //Wy jeli przyspieszenie jest mniejsze ni 1 m/s^2
  if (normalAccX <= 1.0f && normalAccX >= -1.0f) response.accX = 0.0f;
  else response.accX = normalAccX;
    3260:	c0 92 3f 38 	sts	0x383F, r12	; 0x80383f <response>
    3264:	d0 92 40 38 	sts	0x3840, r13	; 0x803840 <response+0x1>
    3268:	e0 92 41 38 	sts	0x3841, r14	; 0x803841 <response+0x2>
    326c:	f0 92 42 38 	sts	0x3842, r15	; 0x803842 <response+0x3>
    3270:	8f cf       	rjmp	.-226    	; 0x3190 <main+0xe74>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:114
  if (normalAccY <= 1.0f && normalAccY >= -1.0f) response.accY = 0.0f;
  else response.accY = normalAccY;
    3272:	80 92 43 38 	sts	0x3843, r8	; 0x803843 <response+0x4>
    3276:	90 92 44 38 	sts	0x3844, r9	; 0x803844 <response+0x5>
    327a:	a0 92 45 38 	sts	0x3845, r10	; 0x803845 <response+0x6>
    327e:	b0 92 46 38 	sts	0x3846, r11	; 0x803846 <response+0x7>
    3282:	a3 cf       	rjmp	.-186    	; 0x31ca <main+0xeae>
C:\Users\Marcin\AppData\Local\Temp\arduino_modified_sketch_365177/controller.ino:116
  
  if (digitalRead(B1_PIN) == LOW) response.startContr = true; //Sprawd, czy naciskany jest przycisk
    3284:	91 e0       	ldi	r25, 0x01	; 1
    3286:	90 93 47 38 	sts	0x3847, r25	; 0x803847 <response+0x8>
    328a:	a5 cf       	rjmp	.-182    	; 0x31d6 <main+0xeba>
writeAckPayload():
C:\Users\Marcin\AppData\Local\Temp\arduino_build_885311\sketch/RF24.cpp:1404
    _SPI.transfer(W_ACK_PAYLOAD | (pipe & 0x07));

    while (data_len--) {
        _SPI.transfer(*current++);
    }
    endTransaction();
    328c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <RF24::endTransaction() [clone .constprop.66]>
serialEventRun():
C:\Users\Marcin\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.0.2\cores\arduino/UART.cpp:66
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    3290:	e0 e0       	ldi	r30, 0x00	; 0
    3292:	f0 e0       	ldi	r31, 0x00	; 0
    3294:	ef 2b       	or	r30, r31
    3296:	09 f4       	brne	.+2      	; 0x329a <main+0xf7e>
    3298:	95 cb       	rjmp	.-2262   	; 0x29c4 <main+0x6a8>
    329a:	0e 94 56 05 	call	0xaac	; 0xaac <Serial0_available()>
    329e:	88 23       	and	r24, r24
    32a0:	09 f4       	brne	.+2      	; 0x32a4 <main+0xf88>
    32a2:	90 cb       	rjmp	.-2272   	; 0x29c4 <main+0x6a8>
    32a4:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    32a8:	8d cb       	rjmp	.-2278   	; 0x29c4 <main+0x6a8>

000032aa <__subsf3>:
__subsf3():
    32aa:	50 58       	subi	r21, 0x80	; 128

000032ac <__addsf3>:
    32ac:	bb 27       	eor	r27, r27
    32ae:	aa 27       	eor	r26, r26
    32b0:	0e 94 6d 19 	call	0x32da	; 0x32da <__addsf3x>
    32b4:	0c 94 75 1a 	jmp	0x34ea	; 0x34ea <__fp_round>
__addsf3():
    32b8:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__fp_pscA>
    32bc:	38 f0       	brcs	.+14     	; 0x32cc <__addsf3+0x20>
    32be:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <__fp_pscB>
    32c2:	20 f0       	brcs	.+8      	; 0x32cc <__addsf3+0x20>
    32c4:	39 f4       	brne	.+14     	; 0x32d4 <__addsf3+0x28>
    32c6:	9f 3f       	cpi	r25, 0xFF	; 255
    32c8:	19 f4       	brne	.+6      	; 0x32d0 <__addsf3+0x24>
    32ca:	26 f4       	brtc	.+8      	; 0x32d4 <__addsf3+0x28>
    32cc:	0c 94 64 1a 	jmp	0x34c8	; 0x34c8 <__fp_nan>
    32d0:	0e f4       	brtc	.+2      	; 0x32d4 <__addsf3+0x28>
    32d2:	e0 95       	com	r30
    32d4:	e7 fb       	bst	r30, 7
    32d6:	0c 94 5e 1a 	jmp	0x34bc	; 0x34bc <__fp_inf>

000032da <__addsf3x>:
__addsf3x():
    32da:	e9 2f       	mov	r30, r25
    32dc:	0e 94 86 1a 	call	0x350c	; 0x350c <__fp_split3>
    32e0:	58 f3       	brcs	.-42     	; 0x32b8 <__addsf3+0xc>
    32e2:	ba 17       	cp	r27, r26
    32e4:	62 07       	cpc	r22, r18
    32e6:	73 07       	cpc	r23, r19
    32e8:	84 07       	cpc	r24, r20
    32ea:	95 07       	cpc	r25, r21
    32ec:	20 f0       	brcs	.+8      	; 0x32f6 <__addsf3x+0x1c>
    32ee:	79 f4       	brne	.+30     	; 0x330e <__addsf3x+0x34>
    32f0:	a6 f5       	brtc	.+104    	; 0x335a <__addsf3x+0x80>
    32f2:	0c 94 a8 1a 	jmp	0x3550	; 0x3550 <__fp_zero>
    32f6:	0e f4       	brtc	.+2      	; 0x32fa <__addsf3x+0x20>
    32f8:	e0 95       	com	r30
    32fa:	0b 2e       	mov	r0, r27
    32fc:	ba 2f       	mov	r27, r26
    32fe:	a0 2d       	mov	r26, r0
    3300:	0b 01       	movw	r0, r22
    3302:	b9 01       	movw	r22, r18
    3304:	90 01       	movw	r18, r0
    3306:	0c 01       	movw	r0, r24
    3308:	ca 01       	movw	r24, r20
    330a:	a0 01       	movw	r20, r0
    330c:	11 24       	eor	r1, r1
    330e:	ff 27       	eor	r31, r31
    3310:	59 1b       	sub	r21, r25
    3312:	99 f0       	breq	.+38     	; 0x333a <__addsf3x+0x60>
    3314:	59 3f       	cpi	r21, 0xF9	; 249
    3316:	50 f4       	brcc	.+20     	; 0x332c <__addsf3x+0x52>
    3318:	50 3e       	cpi	r21, 0xE0	; 224
    331a:	68 f1       	brcs	.+90     	; 0x3376 <__addsf3x+0x9c>
    331c:	1a 16       	cp	r1, r26
    331e:	f0 40       	sbci	r31, 0x00	; 0
    3320:	a2 2f       	mov	r26, r18
    3322:	23 2f       	mov	r18, r19
    3324:	34 2f       	mov	r19, r20
    3326:	44 27       	eor	r20, r20
    3328:	58 5f       	subi	r21, 0xF8	; 248
    332a:	f3 cf       	rjmp	.-26     	; 0x3312 <__addsf3x+0x38>
    332c:	46 95       	lsr	r20
    332e:	37 95       	ror	r19
    3330:	27 95       	ror	r18
    3332:	a7 95       	ror	r26
    3334:	f0 40       	sbci	r31, 0x00	; 0
    3336:	53 95       	inc	r21
    3338:	c9 f7       	brne	.-14     	; 0x332c <__addsf3x+0x52>
    333a:	7e f4       	brtc	.+30     	; 0x335a <__addsf3x+0x80>
    333c:	1f 16       	cp	r1, r31
    333e:	ba 0b       	sbc	r27, r26
    3340:	62 0b       	sbc	r22, r18
    3342:	73 0b       	sbc	r23, r19
    3344:	84 0b       	sbc	r24, r20
    3346:	ba f0       	brmi	.+46     	; 0x3376 <__addsf3x+0x9c>
    3348:	91 50       	subi	r25, 0x01	; 1
    334a:	a1 f0       	breq	.+40     	; 0x3374 <__addsf3x+0x9a>
    334c:	ff 0f       	add	r31, r31
    334e:	bb 1f       	adc	r27, r27
    3350:	66 1f       	adc	r22, r22
    3352:	77 1f       	adc	r23, r23
    3354:	88 1f       	adc	r24, r24
    3356:	c2 f7       	brpl	.-16     	; 0x3348 <__addsf3x+0x6e>
    3358:	0e c0       	rjmp	.+28     	; 0x3376 <__addsf3x+0x9c>
    335a:	ba 0f       	add	r27, r26
    335c:	62 1f       	adc	r22, r18
    335e:	73 1f       	adc	r23, r19
    3360:	84 1f       	adc	r24, r20
    3362:	48 f4       	brcc	.+18     	; 0x3376 <__addsf3x+0x9c>
    3364:	87 95       	ror	r24
    3366:	77 95       	ror	r23
    3368:	67 95       	ror	r22
    336a:	b7 95       	ror	r27
    336c:	f7 95       	ror	r31
    336e:	9e 3f       	cpi	r25, 0xFE	; 254
    3370:	08 f0       	brcs	.+2      	; 0x3374 <__addsf3x+0x9a>
    3372:	b0 cf       	rjmp	.-160    	; 0x32d4 <__addsf3+0x28>
    3374:	93 95       	inc	r25
    3376:	88 0f       	add	r24, r24
    3378:	08 f0       	brcs	.+2      	; 0x337c <__addsf3x+0xa2>
    337a:	99 27       	eor	r25, r25
    337c:	ee 0f       	add	r30, r30
    337e:	97 95       	ror	r25
    3380:	87 95       	ror	r24
    3382:	08 95       	ret

00003384 <__cmpsf2>:
    3384:	0e 94 3a 1a 	call	0x3474	; 0x3474 <__fp_cmp>
    3388:	08 f4       	brcc	.+2      	; 0x338c <__cmpsf2+0x8>
    338a:	81 e0       	ldi	r24, 0x01	; 1
    338c:	08 95       	ret

0000338e <__fixsfsi>:
    338e:	0e 94 ce 19 	call	0x339c	; 0x339c <__fixunssfsi>
    3392:	68 94       	set
    3394:	b1 11       	cpse	r27, r1
    3396:	0c 94 a9 1a 	jmp	0x3552	; 0x3552 <__fp_szero>
    339a:	08 95       	ret

0000339c <__fixunssfsi>:
    339c:	0e 94 8e 1a 	call	0x351c	; 0x351c <__fp_splitA>
    33a0:	88 f0       	brcs	.+34     	; 0x33c4 <__fixunssfsi+0x28>
    33a2:	9f 57       	subi	r25, 0x7F	; 127
    33a4:	98 f0       	brcs	.+38     	; 0x33cc <__fixunssfsi+0x30>
__fixunssfsi():
    33a6:	b9 2f       	mov	r27, r25
    33a8:	99 27       	eor	r25, r25
    33aa:	b7 51       	subi	r27, 0x17	; 23
    33ac:	b0 f0       	brcs	.+44     	; 0x33da <__fixunssfsi+0x3e>
    33ae:	e1 f0       	breq	.+56     	; 0x33e8 <__fixunssfsi+0x4c>
    33b0:	66 0f       	add	r22, r22
    33b2:	77 1f       	adc	r23, r23
    33b4:	88 1f       	adc	r24, r24
    33b6:	99 1f       	adc	r25, r25
    33b8:	1a f0       	brmi	.+6      	; 0x33c0 <__fixunssfsi+0x24>
    33ba:	ba 95       	dec	r27
    33bc:	c9 f7       	brne	.-14     	; 0x33b0 <__fixunssfsi+0x14>
    33be:	14 c0       	rjmp	.+40     	; 0x33e8 <__fixunssfsi+0x4c>
    33c0:	b1 30       	cpi	r27, 0x01	; 1
    33c2:	91 f0       	breq	.+36     	; 0x33e8 <__fixunssfsi+0x4c>
    33c4:	0e 94 a8 1a 	call	0x3550	; 0x3550 <__fp_zero>
    33c8:	b1 e0       	ldi	r27, 0x01	; 1
    33ca:	08 95       	ret
    33cc:	0c 94 a8 1a 	jmp	0x3550	; 0x3550 <__fp_zero>
    33d0:	67 2f       	mov	r22, r23
    33d2:	78 2f       	mov	r23, r24
    33d4:	88 27       	eor	r24, r24
    33d6:	b8 5f       	subi	r27, 0xF8	; 248
    33d8:	39 f0       	breq	.+14     	; 0x33e8 <__fixunssfsi+0x4c>
    33da:	b9 3f       	cpi	r27, 0xF9	; 249
    33dc:	cc f3       	brlt	.-14     	; 0x33d0 <__fixunssfsi+0x34>
    33de:	86 95       	lsr	r24
    33e0:	77 95       	ror	r23
    33e2:	67 95       	ror	r22
    33e4:	b3 95       	inc	r27
    33e6:	d9 f7       	brne	.-10     	; 0x33de <__fixunssfsi+0x42>
    33e8:	3e f4       	brtc	.+14     	; 0x33f8 <__fixunssfsi+0x5c>
    33ea:	90 95       	com	r25
    33ec:	80 95       	com	r24
    33ee:	70 95       	com	r23
    33f0:	61 95       	neg	r22
    33f2:	7f 4f       	sbci	r23, 0xFF	; 255
    33f4:	8f 4f       	sbci	r24, 0xFF	; 255
    33f6:	9f 4f       	sbci	r25, 0xFF	; 255
    33f8:	08 95       	ret

000033fa <__floatunsisf>:
__floatunsisf():
    33fa:	e8 94       	clt
    33fc:	09 c0       	rjmp	.+18     	; 0x3410 <__floatsisf+0x12>

000033fe <__floatsisf>:
    33fe:	97 fb       	bst	r25, 7
    3400:	3e f4       	brtc	.+14     	; 0x3410 <__floatsisf+0x12>
    3402:	90 95       	com	r25
    3404:	80 95       	com	r24
    3406:	70 95       	com	r23
    3408:	61 95       	neg	r22
    340a:	7f 4f       	sbci	r23, 0xFF	; 255
    340c:	8f 4f       	sbci	r24, 0xFF	; 255
    340e:	9f 4f       	sbci	r25, 0xFF	; 255
    3410:	99 23       	and	r25, r25
    3412:	a9 f0       	breq	.+42     	; 0x343e <__floatsisf+0x40>
    3414:	f9 2f       	mov	r31, r25
    3416:	96 e9       	ldi	r25, 0x96	; 150
    3418:	bb 27       	eor	r27, r27
    341a:	93 95       	inc	r25
    341c:	f6 95       	lsr	r31
    341e:	87 95       	ror	r24
    3420:	77 95       	ror	r23
    3422:	67 95       	ror	r22
    3424:	b7 95       	ror	r27
    3426:	f1 11       	cpse	r31, r1
    3428:	f8 cf       	rjmp	.-16     	; 0x341a <__floatsisf+0x1c>
    342a:	fa f4       	brpl	.+62     	; 0x346a <__floatsisf+0x6c>
    342c:	bb 0f       	add	r27, r27
    342e:	11 f4       	brne	.+4      	; 0x3434 <__floatsisf+0x36>
    3430:	60 ff       	sbrs	r22, 0
    3432:	1b c0       	rjmp	.+54     	; 0x346a <__floatsisf+0x6c>
    3434:	6f 5f       	subi	r22, 0xFF	; 255
    3436:	7f 4f       	sbci	r23, 0xFF	; 255
    3438:	8f 4f       	sbci	r24, 0xFF	; 255
    343a:	9f 4f       	sbci	r25, 0xFF	; 255
    343c:	16 c0       	rjmp	.+44     	; 0x346a <__floatsisf+0x6c>
    343e:	88 23       	and	r24, r24
    3440:	11 f0       	breq	.+4      	; 0x3446 <__floatsisf+0x48>
    3442:	96 e9       	ldi	r25, 0x96	; 150
    3444:	11 c0       	rjmp	.+34     	; 0x3468 <__floatsisf+0x6a>
    3446:	77 23       	and	r23, r23
    3448:	21 f0       	breq	.+8      	; 0x3452 <__floatsisf+0x54>
    344a:	9e e8       	ldi	r25, 0x8E	; 142
    344c:	87 2f       	mov	r24, r23
    344e:	76 2f       	mov	r23, r22
    3450:	05 c0       	rjmp	.+10     	; 0x345c <__floatsisf+0x5e>
    3452:	66 23       	and	r22, r22
    3454:	71 f0       	breq	.+28     	; 0x3472 <__floatsisf+0x74>
    3456:	96 e8       	ldi	r25, 0x86	; 134
    3458:	86 2f       	mov	r24, r22
    345a:	70 e0       	ldi	r23, 0x00	; 0
    345c:	60 e0       	ldi	r22, 0x00	; 0
    345e:	2a f0       	brmi	.+10     	; 0x346a <__floatsisf+0x6c>
    3460:	9a 95       	dec	r25
    3462:	66 0f       	add	r22, r22
    3464:	77 1f       	adc	r23, r23
    3466:	88 1f       	adc	r24, r24
    3468:	da f7       	brpl	.-10     	; 0x3460 <__floatsisf+0x62>
    346a:	88 0f       	add	r24, r24
    346c:	96 95       	lsr	r25
    346e:	87 95       	ror	r24
    3470:	97 f9       	bld	r25, 7
    3472:	08 95       	ret

00003474 <__fp_cmp>:
__fp_cmp():
    3474:	99 0f       	add	r25, r25
    3476:	00 08       	sbc	r0, r0
    3478:	55 0f       	add	r21, r21
    347a:	aa 0b       	sbc	r26, r26
    347c:	e0 e8       	ldi	r30, 0x80	; 128
    347e:	fe ef       	ldi	r31, 0xFE	; 254
    3480:	16 16       	cp	r1, r22
    3482:	17 06       	cpc	r1, r23
    3484:	e8 07       	cpc	r30, r24
    3486:	f9 07       	cpc	r31, r25
    3488:	c0 f0       	brcs	.+48     	; 0x34ba <__fp_cmp+0x46>
    348a:	12 16       	cp	r1, r18
    348c:	13 06       	cpc	r1, r19
    348e:	e4 07       	cpc	r30, r20
    3490:	f5 07       	cpc	r31, r21
    3492:	98 f0       	brcs	.+38     	; 0x34ba <__fp_cmp+0x46>
    3494:	62 1b       	sub	r22, r18
    3496:	73 0b       	sbc	r23, r19
    3498:	84 0b       	sbc	r24, r20
    349a:	95 0b       	sbc	r25, r21
    349c:	39 f4       	brne	.+14     	; 0x34ac <__fp_cmp+0x38>
    349e:	0a 26       	eor	r0, r26
    34a0:	61 f0       	breq	.+24     	; 0x34ba <__fp_cmp+0x46>
    34a2:	23 2b       	or	r18, r19
    34a4:	24 2b       	or	r18, r20
    34a6:	25 2b       	or	r18, r21
    34a8:	21 f4       	brne	.+8      	; 0x34b2 <__fp_cmp+0x3e>
    34aa:	08 95       	ret
    34ac:	0a 26       	eor	r0, r26
    34ae:	09 f4       	brne	.+2      	; 0x34b2 <__fp_cmp+0x3e>
    34b0:	a1 40       	sbci	r26, 0x01	; 1
    34b2:	a6 95       	lsr	r26
    34b4:	8f ef       	ldi	r24, 0xFF	; 255
    34b6:	81 1d       	adc	r24, r1
    34b8:	81 1d       	adc	r24, r1
    34ba:	08 95       	ret

000034bc <__fp_inf>:
__fp_inf():
    34bc:	97 f9       	bld	r25, 7
    34be:	9f 67       	ori	r25, 0x7F	; 127
    34c0:	80 e8       	ldi	r24, 0x80	; 128
    34c2:	70 e0       	ldi	r23, 0x00	; 0
    34c4:	60 e0       	ldi	r22, 0x00	; 0
    34c6:	08 95       	ret

000034c8 <__fp_nan>:
__fp_nan():
    34c8:	9f ef       	ldi	r25, 0xFF	; 255
    34ca:	80 ec       	ldi	r24, 0xC0	; 192
    34cc:	08 95       	ret

000034ce <__fp_pscA>:
__fp_pscA():
    34ce:	00 24       	eor	r0, r0
    34d0:	0a 94       	dec	r0
    34d2:	16 16       	cp	r1, r22
    34d4:	17 06       	cpc	r1, r23
    34d6:	18 06       	cpc	r1, r24
    34d8:	09 06       	cpc	r0, r25
    34da:	08 95       	ret

000034dc <__fp_pscB>:
__fp_pscB():
    34dc:	00 24       	eor	r0, r0
    34de:	0a 94       	dec	r0
    34e0:	12 16       	cp	r1, r18
    34e2:	13 06       	cpc	r1, r19
    34e4:	14 06       	cpc	r1, r20
    34e6:	05 06       	cpc	r0, r21
    34e8:	08 95       	ret

000034ea <__fp_round>:
__fp_round():
    34ea:	09 2e       	mov	r0, r25
    34ec:	03 94       	inc	r0
    34ee:	00 0c       	add	r0, r0
    34f0:	11 f4       	brne	.+4      	; 0x34f6 <__fp_round+0xc>
    34f2:	88 23       	and	r24, r24
    34f4:	52 f0       	brmi	.+20     	; 0x350a <__fp_round+0x20>
    34f6:	bb 0f       	add	r27, r27
    34f8:	40 f4       	brcc	.+16     	; 0x350a <__fp_round+0x20>
    34fa:	bf 2b       	or	r27, r31
    34fc:	11 f4       	brne	.+4      	; 0x3502 <__fp_round+0x18>
    34fe:	60 ff       	sbrs	r22, 0
    3500:	04 c0       	rjmp	.+8      	; 0x350a <__fp_round+0x20>
    3502:	6f 5f       	subi	r22, 0xFF	; 255
    3504:	7f 4f       	sbci	r23, 0xFF	; 255
    3506:	8f 4f       	sbci	r24, 0xFF	; 255
    3508:	9f 4f       	sbci	r25, 0xFF	; 255
    350a:	08 95       	ret

0000350c <__fp_split3>:
__fp_split3():
    350c:	57 fd       	sbrc	r21, 7
    350e:	90 58       	subi	r25, 0x80	; 128
    3510:	44 0f       	add	r20, r20
    3512:	55 1f       	adc	r21, r21
    3514:	59 f0       	breq	.+22     	; 0x352c <__fp_splitA+0x10>
    3516:	5f 3f       	cpi	r21, 0xFF	; 255
    3518:	71 f0       	breq	.+28     	; 0x3536 <__fp_splitA+0x1a>
    351a:	47 95       	ror	r20

0000351c <__fp_splitA>:
    351c:	88 0f       	add	r24, r24
    351e:	97 fb       	bst	r25, 7
    3520:	99 1f       	adc	r25, r25
    3522:	61 f0       	breq	.+24     	; 0x353c <__fp_splitA+0x20>
    3524:	9f 3f       	cpi	r25, 0xFF	; 255
    3526:	79 f0       	breq	.+30     	; 0x3546 <__fp_splitA+0x2a>
    3528:	87 95       	ror	r24
    352a:	08 95       	ret
    352c:	12 16       	cp	r1, r18
    352e:	13 06       	cpc	r1, r19
    3530:	14 06       	cpc	r1, r20
    3532:	55 1f       	adc	r21, r21
    3534:	f2 cf       	rjmp	.-28     	; 0x351a <__fp_split3+0xe>
    3536:	46 95       	lsr	r20
    3538:	f1 df       	rcall	.-30     	; 0x351c <__fp_splitA>
    353a:	08 c0       	rjmp	.+16     	; 0x354c <__fp_splitA+0x30>
    353c:	16 16       	cp	r1, r22
    353e:	17 06       	cpc	r1, r23
    3540:	18 06       	cpc	r1, r24
    3542:	99 1f       	adc	r25, r25
    3544:	f1 cf       	rjmp	.-30     	; 0x3528 <__fp_splitA+0xc>
    3546:	86 95       	lsr	r24
    3548:	71 05       	cpc	r23, r1
    354a:	61 05       	cpc	r22, r1
    354c:	08 94       	sec
    354e:	08 95       	ret

00003550 <__fp_zero>:
__fp_zero():
    3550:	e8 94       	clt

00003552 <__fp_szero>:
    3552:	bb 27       	eor	r27, r27
    3554:	66 27       	eor	r22, r22
    3556:	77 27       	eor	r23, r23
    3558:	cb 01       	movw	r24, r22
    355a:	97 f9       	bld	r25, 7
    355c:	08 95       	ret

0000355e <__gesf2>:
__gesf2():
    355e:	0e 94 3a 1a 	call	0x3474	; 0x3474 <__fp_cmp>
    3562:	08 f4       	brcc	.+2      	; 0x3566 <__gesf2+0x8>
    3564:	8f ef       	ldi	r24, 0xFF	; 255
    3566:	08 95       	ret

00003568 <__mulsf3>:
__mulsf3():
    3568:	0e 94 c7 1a 	call	0x358e	; 0x358e <__mulsf3x>
    356c:	0c 94 75 1a 	jmp	0x34ea	; 0x34ea <__fp_round>
    3570:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__fp_pscA>
    3574:	38 f0       	brcs	.+14     	; 0x3584 <__mulsf3+0x1c>
    3576:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <__fp_pscB>
    357a:	20 f0       	brcs	.+8      	; 0x3584 <__mulsf3+0x1c>
    357c:	95 23       	and	r25, r21
    357e:	11 f0       	breq	.+4      	; 0x3584 <__mulsf3+0x1c>
    3580:	0c 94 5e 1a 	jmp	0x34bc	; 0x34bc <__fp_inf>
    3584:	0c 94 64 1a 	jmp	0x34c8	; 0x34c8 <__fp_nan>
    3588:	11 24       	eor	r1, r1
    358a:	0c 94 a9 1a 	jmp	0x3552	; 0x3552 <__fp_szero>

0000358e <__mulsf3x>:
__mulsf3x():
    358e:	0e 94 86 1a 	call	0x350c	; 0x350c <__fp_split3>
    3592:	70 f3       	brcs	.-36     	; 0x3570 <__mulsf3+0x8>

00003594 <__mulsf3_pse>:
    3594:	95 9f       	mul	r25, r21
    3596:	c1 f3       	breq	.-16     	; 0x3588 <__mulsf3+0x20>
    3598:	95 0f       	add	r25, r21
    359a:	50 e0       	ldi	r21, 0x00	; 0
    359c:	55 1f       	adc	r21, r21
    359e:	62 9f       	mul	r22, r18
    35a0:	f0 01       	movw	r30, r0
    35a2:	72 9f       	mul	r23, r18
    35a4:	bb 27       	eor	r27, r27
    35a6:	f0 0d       	add	r31, r0
    35a8:	b1 1d       	adc	r27, r1
    35aa:	63 9f       	mul	r22, r19
    35ac:	aa 27       	eor	r26, r26
    35ae:	f0 0d       	add	r31, r0
    35b0:	b1 1d       	adc	r27, r1
    35b2:	aa 1f       	adc	r26, r26
    35b4:	64 9f       	mul	r22, r20
    35b6:	66 27       	eor	r22, r22
    35b8:	b0 0d       	add	r27, r0
    35ba:	a1 1d       	adc	r26, r1
    35bc:	66 1f       	adc	r22, r22
    35be:	82 9f       	mul	r24, r18
    35c0:	22 27       	eor	r18, r18
    35c2:	b0 0d       	add	r27, r0
    35c4:	a1 1d       	adc	r26, r1
    35c6:	62 1f       	adc	r22, r18
    35c8:	73 9f       	mul	r23, r19
    35ca:	b0 0d       	add	r27, r0
    35cc:	a1 1d       	adc	r26, r1
    35ce:	62 1f       	adc	r22, r18
    35d0:	83 9f       	mul	r24, r19
    35d2:	a0 0d       	add	r26, r0
    35d4:	61 1d       	adc	r22, r1
    35d6:	22 1f       	adc	r18, r18
    35d8:	74 9f       	mul	r23, r20
    35da:	33 27       	eor	r19, r19
    35dc:	a0 0d       	add	r26, r0
    35de:	61 1d       	adc	r22, r1
    35e0:	23 1f       	adc	r18, r19
    35e2:	84 9f       	mul	r24, r20
    35e4:	60 0d       	add	r22, r0
    35e6:	21 1d       	adc	r18, r1
    35e8:	82 2f       	mov	r24, r18
    35ea:	76 2f       	mov	r23, r22
    35ec:	6a 2f       	mov	r22, r26
    35ee:	11 24       	eor	r1, r1
    35f0:	9f 57       	subi	r25, 0x7F	; 127
    35f2:	50 40       	sbci	r21, 0x00	; 0
    35f4:	9a f0       	brmi	.+38     	; 0x361c <__mulsf3_pse+0x88>
    35f6:	f1 f0       	breq	.+60     	; 0x3634 <__mulsf3_pse+0xa0>
    35f8:	88 23       	and	r24, r24
    35fa:	4a f0       	brmi	.+18     	; 0x360e <__mulsf3_pse+0x7a>
    35fc:	ee 0f       	add	r30, r30
    35fe:	ff 1f       	adc	r31, r31
    3600:	bb 1f       	adc	r27, r27
    3602:	66 1f       	adc	r22, r22
    3604:	77 1f       	adc	r23, r23
    3606:	88 1f       	adc	r24, r24
    3608:	91 50       	subi	r25, 0x01	; 1
    360a:	50 40       	sbci	r21, 0x00	; 0
    360c:	a9 f7       	brne	.-22     	; 0x35f8 <__mulsf3_pse+0x64>
    360e:	9e 3f       	cpi	r25, 0xFE	; 254
    3610:	51 05       	cpc	r21, r1
    3612:	80 f0       	brcs	.+32     	; 0x3634 <__mulsf3_pse+0xa0>
    3614:	0c 94 5e 1a 	jmp	0x34bc	; 0x34bc <__fp_inf>
    3618:	0c 94 a9 1a 	jmp	0x3552	; 0x3552 <__fp_szero>
    361c:	5f 3f       	cpi	r21, 0xFF	; 255
    361e:	e4 f3       	brlt	.-8      	; 0x3618 <__mulsf3_pse+0x84>
    3620:	98 3e       	cpi	r25, 0xE8	; 232
    3622:	d4 f3       	brlt	.-12     	; 0x3618 <__mulsf3_pse+0x84>
    3624:	86 95       	lsr	r24
    3626:	77 95       	ror	r23
    3628:	67 95       	ror	r22
    362a:	b7 95       	ror	r27
    362c:	f7 95       	ror	r31
    362e:	e7 95       	ror	r30
    3630:	9f 5f       	subi	r25, 0xFF	; 255
    3632:	c1 f7       	brne	.-16     	; 0x3624 <__mulsf3_pse+0x90>
    3634:	fe 2b       	or	r31, r30
    3636:	88 0f       	add	r24, r24
    3638:	91 1d       	adc	r25, r1
    363a:	96 95       	lsr	r25
    363c:	87 95       	ror	r24
    363e:	97 f9       	bld	r25, 7
    3640:	08 95       	ret

00003642 <round>:
    3642:	0e 94 8e 1a 	call	0x351c	; 0x351c <__fp_splitA>
    3646:	e8 f0       	brcs	.+58     	; 0x3682 <round+0x40>
    3648:	9e 37       	cpi	r25, 0x7E	; 126
    364a:	e8 f0       	brcs	.+58     	; 0x3686 <round+0x44>
    364c:	96 39       	cpi	r25, 0x96	; 150
    364e:	b8 f4       	brcc	.+46     	; 0x367e <round+0x3c>
    3650:	9e 38       	cpi	r25, 0x8E	; 142
    3652:	48 f4       	brcc	.+18     	; 0x3666 <round+0x24>
    3654:	67 2f       	mov	r22, r23
    3656:	78 2f       	mov	r23, r24
    3658:	88 27       	eor	r24, r24
    365a:	98 5f       	subi	r25, 0xF8	; 248
    365c:	f9 cf       	rjmp	.-14     	; 0x3650 <round+0xe>
    365e:	86 95       	lsr	r24
round():
    3660:	77 95       	ror	r23
    3662:	67 95       	ror	r22
    3664:	93 95       	inc	r25
    3666:	95 39       	cpi	r25, 0x95	; 149
    3668:	d0 f3       	brcs	.-12     	; 0x365e <round+0x1c>
    366a:	b6 2f       	mov	r27, r22
    366c:	b1 70       	andi	r27, 0x01	; 1
    366e:	6b 0f       	add	r22, r27
    3670:	71 1d       	adc	r23, r1
    3672:	81 1d       	adc	r24, r1
    3674:	20 f4       	brcc	.+8      	; 0x367e <round+0x3c>
    3676:	87 95       	ror	r24
    3678:	77 95       	ror	r23
    367a:	67 95       	ror	r22
    367c:	93 95       	inc	r25
    367e:	0c 94 45 1b 	jmp	0x368a	; 0x368a <__fp_mintl>
    3682:	0c 94 60 1b 	jmp	0x36c0	; 0x36c0 <__fp_mpack>
    3686:	0c 94 a9 1a 	jmp	0x3552	; 0x3552 <__fp_szero>

0000368a <__fp_mintl>:
__fp_mintl():
    368a:	88 23       	and	r24, r24
    368c:	71 f4       	brne	.+28     	; 0x36aa <__fp_mintl+0x20>
    368e:	77 23       	and	r23, r23
    3690:	21 f0       	breq	.+8      	; 0x369a <__fp_mintl+0x10>
    3692:	98 50       	subi	r25, 0x08	; 8
    3694:	87 2b       	or	r24, r23
    3696:	76 2f       	mov	r23, r22
    3698:	07 c0       	rjmp	.+14     	; 0x36a8 <__fp_mintl+0x1e>
    369a:	66 23       	and	r22, r22
    369c:	11 f4       	brne	.+4      	; 0x36a2 <__fp_mintl+0x18>
    369e:	99 27       	eor	r25, r25
    36a0:	0d c0       	rjmp	.+26     	; 0x36bc <__fp_mintl+0x32>
    36a2:	90 51       	subi	r25, 0x10	; 16
    36a4:	86 2b       	or	r24, r22
    36a6:	70 e0       	ldi	r23, 0x00	; 0
    36a8:	60 e0       	ldi	r22, 0x00	; 0
    36aa:	2a f0       	brmi	.+10     	; 0x36b6 <__fp_mintl+0x2c>
    36ac:	9a 95       	dec	r25
    36ae:	66 0f       	add	r22, r22
    36b0:	77 1f       	adc	r23, r23
    36b2:	88 1f       	adc	r24, r24
    36b4:	da f7       	brpl	.-10     	; 0x36ac <__fp_mintl+0x22>
    36b6:	88 0f       	add	r24, r24
    36b8:	96 95       	lsr	r25
    36ba:	87 95       	ror	r24
    36bc:	97 f9       	bld	r25, 7
    36be:	08 95       	ret

000036c0 <__fp_mpack>:
__fp_mpack():
    36c0:	9f 3f       	cpi	r25, 0xFF	; 255
    36c2:	31 f0       	breq	.+12     	; 0x36d0 <__fp_mpack_finite+0xc>

000036c4 <__fp_mpack_finite>:
    36c4:	91 50       	subi	r25, 0x01	; 1
    36c6:	20 f4       	brcc	.+8      	; 0x36d0 <__fp_mpack_finite+0xc>
    36c8:	87 95       	ror	r24
    36ca:	77 95       	ror	r23
    36cc:	67 95       	ror	r22
    36ce:	b7 95       	ror	r27
    36d0:	88 0f       	add	r24, r24
    36d2:	91 1d       	adc	r25, r1
    36d4:	96 95       	lsr	r25
    36d6:	87 95       	ror	r24
    36d8:	97 f9       	bld	r25, 7
    36da:	08 95       	ret

000036dc <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    36dc:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    36de:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    36e0:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    36e2:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    36e4:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    36e6:	0d c0       	rjmp	.+26     	; 0x3702 <__udivmodsi4_ep>

000036e8 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    36e8:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    36ea:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    36ec:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    36ee:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    36f0:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    36f2:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    36f4:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    36f6:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    36f8:	20 f0       	brcs	.+8      	; 0x3702 <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    36fa:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    36fc:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    36fe:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    3700:	f5 0b       	sbc	r31, r21

00003702 <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    3702:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    3704:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    3706:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    3708:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    370a:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    370c:	69 f7       	brne	.-38     	; 0x36e8 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    370e:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    3710:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    3712:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    3714:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    3716:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    3718:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    371a:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    371c:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    371e:	08 95       	ret

00003720 <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    3720:	0e 94 a9 1b 	call	0x3752	; 0x3752 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    3724:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    3726:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    3728:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    372a:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    372c:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    372e:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    3730:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    3732:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    3734:	08 95       	ret

00003736 <__mulshisi3>:
__mulshisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    3736:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    3738:	0c 94 90 1b 	jmp	0x3720	; 0x3720 <__muluhisi3>

0000373c <__mulohisi3>:
__mulohisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    373c:	0e 94 90 1b 	call	0x3720	; 0x3720 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    3740:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    3742:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    3744:	08 95       	ret

00003746 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    3746:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    3748:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    374a:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    374c:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    374e:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    3750:	09 94       	ijmp

00003752 <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    3752:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    3754:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    3756:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    3758:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    375a:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    375c:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    375e:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    3760:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    3762:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    3764:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    3766:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    3768:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    376a:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    376c:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    376e:	08 95       	ret

00003770 <malloc>:
malloc():
    3770:	0f 93       	push	r16
    3772:	1f 93       	push	r17
    3774:	cf 93       	push	r28
    3776:	df 93       	push	r29
    3778:	82 30       	cpi	r24, 0x02	; 2
    377a:	91 05       	cpc	r25, r1
    377c:	10 f4       	brcc	.+4      	; 0x3782 <malloc+0x12>
    377e:	82 e0       	ldi	r24, 0x02	; 2
    3780:	90 e0       	ldi	r25, 0x00	; 0
    3782:	e0 91 12 3a 	lds	r30, 0x3A12	; 0x803a12 <__flp>
    3786:	f0 91 13 3a 	lds	r31, 0x3A13	; 0x803a13 <__flp+0x1>
    378a:	30 e0       	ldi	r19, 0x00	; 0
    378c:	20 e0       	ldi	r18, 0x00	; 0
    378e:	b0 e0       	ldi	r27, 0x00	; 0
    3790:	a0 e0       	ldi	r26, 0x00	; 0
    3792:	30 97       	sbiw	r30, 0x00	; 0
    3794:	99 f4       	brne	.+38     	; 0x37bc <malloc+0x4c>
    3796:	21 15       	cp	r18, r1
    3798:	31 05       	cpc	r19, r1
    379a:	09 f4       	brne	.+2      	; 0x379e <malloc+0x2e>
    379c:	4a c0       	rjmp	.+148    	; 0x3832 <malloc+0xc2>
    379e:	28 1b       	sub	r18, r24
    37a0:	39 0b       	sbc	r19, r25
    37a2:	24 30       	cpi	r18, 0x04	; 4
    37a4:	31 05       	cpc	r19, r1
    37a6:	d8 f5       	brcc	.+118    	; 0x381e <malloc+0xae>
    37a8:	8a 81       	ldd	r24, Y+2	; 0x02
    37aa:	9b 81       	ldd	r25, Y+3	; 0x03
    37ac:	61 15       	cp	r22, r1
    37ae:	71 05       	cpc	r23, r1
    37b0:	89 f1       	breq	.+98     	; 0x3814 <malloc+0xa4>
    37b2:	fb 01       	movw	r30, r22
    37b4:	82 83       	std	Z+2, r24	; 0x02
    37b6:	93 83       	std	Z+3, r25	; 0x03
    37b8:	fe 01       	movw	r30, r28
    37ba:	11 c0       	rjmp	.+34     	; 0x37de <malloc+0x6e>
    37bc:	40 81       	ld	r20, Z
    37be:	51 81       	ldd	r21, Z+1	; 0x01
    37c0:	02 81       	ldd	r16, Z+2	; 0x02
    37c2:	13 81       	ldd	r17, Z+3	; 0x03
    37c4:	48 17       	cp	r20, r24
    37c6:	59 07       	cpc	r21, r25
    37c8:	e0 f0       	brcs	.+56     	; 0x3802 <malloc+0x92>
    37ca:	48 17       	cp	r20, r24
    37cc:	59 07       	cpc	r21, r25
    37ce:	99 f4       	brne	.+38     	; 0x37f6 <malloc+0x86>
    37d0:	10 97       	sbiw	r26, 0x00	; 0
    37d2:	61 f0       	breq	.+24     	; 0x37ec <malloc+0x7c>
    37d4:	12 96       	adiw	r26, 0x02	; 2
    37d6:	0c 93       	st	X, r16
    37d8:	12 97       	sbiw	r26, 0x02	; 2
    37da:	13 96       	adiw	r26, 0x03	; 3
    37dc:	1c 93       	st	X, r17
    37de:	32 96       	adiw	r30, 0x02	; 2
    37e0:	cf 01       	movw	r24, r30
    37e2:	df 91       	pop	r29
    37e4:	cf 91       	pop	r28
    37e6:	1f 91       	pop	r17
    37e8:	0f 91       	pop	r16
    37ea:	08 95       	ret
    37ec:	00 93 12 3a 	sts	0x3A12, r16	; 0x803a12 <__flp>
    37f0:	10 93 13 3a 	sts	0x3A13, r17	; 0x803a13 <__flp+0x1>
    37f4:	f4 cf       	rjmp	.-24     	; 0x37de <malloc+0x6e>
    37f6:	21 15       	cp	r18, r1
    37f8:	31 05       	cpc	r19, r1
    37fa:	51 f0       	breq	.+20     	; 0x3810 <malloc+0xa0>
    37fc:	42 17       	cp	r20, r18
    37fe:	53 07       	cpc	r21, r19
    3800:	38 f0       	brcs	.+14     	; 0x3810 <malloc+0xa0>
    3802:	a9 01       	movw	r20, r18
    3804:	db 01       	movw	r26, r22
    3806:	9a 01       	movw	r18, r20
    3808:	bd 01       	movw	r22, r26
    380a:	df 01       	movw	r26, r30
    380c:	f8 01       	movw	r30, r16
    380e:	c1 cf       	rjmp	.-126    	; 0x3792 <malloc+0x22>
    3810:	ef 01       	movw	r28, r30
    3812:	f9 cf       	rjmp	.-14     	; 0x3806 <malloc+0x96>
    3814:	80 93 12 3a 	sts	0x3A12, r24	; 0x803a12 <__flp>
    3818:	90 93 13 3a 	sts	0x3A13, r25	; 0x803a13 <__flp+0x1>
    381c:	cd cf       	rjmp	.-102    	; 0x37b8 <malloc+0x48>
    381e:	fe 01       	movw	r30, r28
    3820:	e2 0f       	add	r30, r18
    3822:	f3 1f       	adc	r31, r19
    3824:	81 93       	st	Z+, r24
    3826:	91 93       	st	Z+, r25
    3828:	22 50       	subi	r18, 0x02	; 2
    382a:	31 09       	sbc	r19, r1
    382c:	28 83       	st	Y, r18
    382e:	39 83       	std	Y+1, r19	; 0x01
    3830:	d7 cf       	rjmp	.-82     	; 0x37e0 <malloc+0x70>
    3832:	20 91 10 3a 	lds	r18, 0x3A10	; 0x803a10 <__brkval>
    3836:	30 91 11 3a 	lds	r19, 0x3A11	; 0x803a11 <__brkval+0x1>
    383a:	23 2b       	or	r18, r19
    383c:	41 f4       	brne	.+16     	; 0x384e <malloc+0xde>
    383e:	20 91 02 38 	lds	r18, 0x3802	; 0x803802 <__malloc_heap_start>
    3842:	30 91 03 38 	lds	r19, 0x3803	; 0x803803 <__malloc_heap_start+0x1>
    3846:	20 93 10 3a 	sts	0x3A10, r18	; 0x803a10 <__brkval>
    384a:	30 93 11 3a 	sts	0x3A11, r19	; 0x803a11 <__brkval+0x1>
    384e:	20 91 00 38 	lds	r18, 0x3800	; 0x803800 <__data_start>
    3852:	30 91 01 38 	lds	r19, 0x3801	; 0x803801 <__data_start+0x1>
    3856:	21 15       	cp	r18, r1
    3858:	31 05       	cpc	r19, r1
    385a:	41 f4       	brne	.+16     	; 0x386c <malloc+0xfc>
    385c:	2d b7       	in	r18, 0x3d	; 61
    385e:	3e b7       	in	r19, 0x3e	; 62
    3860:	40 91 04 38 	lds	r20, 0x3804	; 0x803804 <__malloc_margin>
    3864:	50 91 05 38 	lds	r21, 0x3805	; 0x803805 <__malloc_margin+0x1>
    3868:	24 1b       	sub	r18, r20
    386a:	35 0b       	sbc	r19, r21
    386c:	e0 91 10 3a 	lds	r30, 0x3A10	; 0x803a10 <__brkval>
    3870:	f0 91 11 3a 	lds	r31, 0x3A11	; 0x803a11 <__brkval+0x1>
    3874:	e2 17       	cp	r30, r18
    3876:	f3 07       	cpc	r31, r19
    3878:	a0 f4       	brcc	.+40     	; 0x38a2 <malloc+0x132>
    387a:	2e 1b       	sub	r18, r30
    387c:	3f 0b       	sbc	r19, r31
    387e:	28 17       	cp	r18, r24
    3880:	39 07       	cpc	r19, r25
    3882:	78 f0       	brcs	.+30     	; 0x38a2 <malloc+0x132>
    3884:	ac 01       	movw	r20, r24
    3886:	4e 5f       	subi	r20, 0xFE	; 254
    3888:	5f 4f       	sbci	r21, 0xFF	; 255
    388a:	24 17       	cp	r18, r20
    388c:	35 07       	cpc	r19, r21
    388e:	48 f0       	brcs	.+18     	; 0x38a2 <malloc+0x132>
    3890:	4e 0f       	add	r20, r30
    3892:	5f 1f       	adc	r21, r31
    3894:	40 93 10 3a 	sts	0x3A10, r20	; 0x803a10 <__brkval>
    3898:	50 93 11 3a 	sts	0x3A11, r21	; 0x803a11 <__brkval+0x1>
    389c:	81 93       	st	Z+, r24
    389e:	91 93       	st	Z+, r25
    38a0:	9f cf       	rjmp	.-194    	; 0x37e0 <malloc+0x70>
    38a2:	f0 e0       	ldi	r31, 0x00	; 0
    38a4:	e0 e0       	ldi	r30, 0x00	; 0
    38a6:	9c cf       	rjmp	.-200    	; 0x37e0 <malloc+0x70>

000038a8 <free>:
free():
    38a8:	cf 93       	push	r28
    38aa:	df 93       	push	r29
    38ac:	00 97       	sbiw	r24, 0x00	; 0
    38ae:	e9 f0       	breq	.+58     	; 0x38ea <free+0x42>
    38b0:	fc 01       	movw	r30, r24
    38b2:	32 97       	sbiw	r30, 0x02	; 2
    38b4:	12 82       	std	Z+2, r1	; 0x02
    38b6:	13 82       	std	Z+3, r1	; 0x03
    38b8:	a0 91 12 3a 	lds	r26, 0x3A12	; 0x803a12 <__flp>
    38bc:	b0 91 13 3a 	lds	r27, 0x3A13	; 0x803a13 <__flp+0x1>
    38c0:	ed 01       	movw	r28, r26
    38c2:	30 e0       	ldi	r19, 0x00	; 0
    38c4:	20 e0       	ldi	r18, 0x00	; 0
    38c6:	10 97       	sbiw	r26, 0x00	; 0
    38c8:	a1 f4       	brne	.+40     	; 0x38f2 <free+0x4a>
    38ca:	20 81       	ld	r18, Z
    38cc:	31 81       	ldd	r19, Z+1	; 0x01
    38ce:	82 0f       	add	r24, r18
    38d0:	93 1f       	adc	r25, r19
    38d2:	20 91 10 3a 	lds	r18, 0x3A10	; 0x803a10 <__brkval>
    38d6:	30 91 11 3a 	lds	r19, 0x3A11	; 0x803a11 <__brkval+0x1>
    38da:	28 17       	cp	r18, r24
    38dc:	39 07       	cpc	r19, r25
    38de:	09 f0       	breq	.+2      	; 0x38e2 <free+0x3a>
    38e0:	61 c0       	rjmp	.+194    	; 0x39a4 <free+0xfc>
    38e2:	e0 93 10 3a 	sts	0x3A10, r30	; 0x803a10 <__brkval>
    38e6:	f0 93 11 3a 	sts	0x3A11, r31	; 0x803a11 <__brkval+0x1>
    38ea:	df 91       	pop	r29
    38ec:	cf 91       	pop	r28
    38ee:	08 95       	ret
    38f0:	ea 01       	movw	r28, r20
    38f2:	ce 17       	cp	r28, r30
    38f4:	df 07       	cpc	r29, r31
    38f6:	e8 f5       	brcc	.+122    	; 0x3972 <free+0xca>
    38f8:	4a 81       	ldd	r20, Y+2	; 0x02
    38fa:	5b 81       	ldd	r21, Y+3	; 0x03
    38fc:	9e 01       	movw	r18, r28
    38fe:	41 15       	cp	r20, r1
    3900:	51 05       	cpc	r21, r1
    3902:	b1 f7       	brne	.-20     	; 0x38f0 <free+0x48>
    3904:	e9 01       	movw	r28, r18
    3906:	ea 83       	std	Y+2, r30	; 0x02
    3908:	fb 83       	std	Y+3, r31	; 0x03
    390a:	49 91       	ld	r20, Y+
    390c:	59 91       	ld	r21, Y+
    390e:	c4 0f       	add	r28, r20
    3910:	d5 1f       	adc	r29, r21
    3912:	ec 17       	cp	r30, r28
    3914:	fd 07       	cpc	r31, r29
    3916:	61 f4       	brne	.+24     	; 0x3930 <free+0x88>
    3918:	80 81       	ld	r24, Z
    391a:	91 81       	ldd	r25, Z+1	; 0x01
    391c:	02 96       	adiw	r24, 0x02	; 2
    391e:	84 0f       	add	r24, r20
    3920:	95 1f       	adc	r25, r21
    3922:	e9 01       	movw	r28, r18
    3924:	88 83       	st	Y, r24
    3926:	99 83       	std	Y+1, r25	; 0x01
    3928:	82 81       	ldd	r24, Z+2	; 0x02
    392a:	93 81       	ldd	r25, Z+3	; 0x03
    392c:	8a 83       	std	Y+2, r24	; 0x02
    392e:	9b 83       	std	Y+3, r25	; 0x03
    3930:	f0 e0       	ldi	r31, 0x00	; 0
    3932:	e0 e0       	ldi	r30, 0x00	; 0
    3934:	12 96       	adiw	r26, 0x02	; 2
    3936:	8d 91       	ld	r24, X+
    3938:	9c 91       	ld	r25, X
    393a:	13 97       	sbiw	r26, 0x03	; 3
    393c:	00 97       	sbiw	r24, 0x00	; 0
    393e:	b9 f5       	brne	.+110    	; 0x39ae <free+0x106>
    3940:	2d 91       	ld	r18, X+
    3942:	3c 91       	ld	r19, X
    3944:	11 97       	sbiw	r26, 0x01	; 1
    3946:	cd 01       	movw	r24, r26
    3948:	02 96       	adiw	r24, 0x02	; 2
    394a:	82 0f       	add	r24, r18
    394c:	93 1f       	adc	r25, r19
    394e:	20 91 10 3a 	lds	r18, 0x3A10	; 0x803a10 <__brkval>
    3952:	30 91 11 3a 	lds	r19, 0x3A11	; 0x803a11 <__brkval+0x1>
    3956:	28 17       	cp	r18, r24
    3958:	39 07       	cpc	r19, r25
    395a:	39 f6       	brne	.-114    	; 0x38ea <free+0x42>
    395c:	30 97       	sbiw	r30, 0x00	; 0
    395e:	51 f5       	brne	.+84     	; 0x39b4 <free+0x10c>
    3960:	10 92 12 3a 	sts	0x3A12, r1	; 0x803a12 <__flp>
    3964:	10 92 13 3a 	sts	0x3A13, r1	; 0x803a13 <__flp+0x1>
    3968:	a0 93 10 3a 	sts	0x3A10, r26	; 0x803a10 <__brkval>
    396c:	b0 93 11 3a 	sts	0x3A11, r27	; 0x803a11 <__brkval+0x1>
    3970:	bc cf       	rjmp	.-136    	; 0x38ea <free+0x42>
    3972:	c2 83       	std	Z+2, r28	; 0x02
    3974:	d3 83       	std	Z+3, r29	; 0x03
    3976:	40 81       	ld	r20, Z
    3978:	51 81       	ldd	r21, Z+1	; 0x01
    397a:	84 0f       	add	r24, r20
    397c:	95 1f       	adc	r25, r21
    397e:	c8 17       	cp	r28, r24
    3980:	d9 07       	cpc	r29, r25
    3982:	61 f4       	brne	.+24     	; 0x399c <free+0xf4>
    3984:	4e 5f       	subi	r20, 0xFE	; 254
    3986:	5f 4f       	sbci	r21, 0xFF	; 255
    3988:	88 81       	ld	r24, Y
    398a:	99 81       	ldd	r25, Y+1	; 0x01
    398c:	48 0f       	add	r20, r24
    398e:	59 1f       	adc	r21, r25
    3990:	40 83       	st	Z, r20
    3992:	51 83       	std	Z+1, r21	; 0x01
    3994:	8a 81       	ldd	r24, Y+2	; 0x02
    3996:	9b 81       	ldd	r25, Y+3	; 0x03
    3998:	82 83       	std	Z+2, r24	; 0x02
    399a:	93 83       	std	Z+3, r25	; 0x03
    399c:	21 15       	cp	r18, r1
    399e:	31 05       	cpc	r19, r1
    39a0:	09 f0       	breq	.+2      	; 0x39a4 <free+0xfc>
    39a2:	b0 cf       	rjmp	.-160    	; 0x3904 <free+0x5c>
    39a4:	e0 93 12 3a 	sts	0x3A12, r30	; 0x803a12 <__flp>
    39a8:	f0 93 13 3a 	sts	0x3A13, r31	; 0x803a13 <__flp+0x1>
    39ac:	9e cf       	rjmp	.-196    	; 0x38ea <free+0x42>
    39ae:	fd 01       	movw	r30, r26
    39b0:	dc 01       	movw	r26, r24
    39b2:	c0 cf       	rjmp	.-128    	; 0x3934 <free+0x8c>
    39b4:	12 82       	std	Z+2, r1	; 0x02
    39b6:	13 82       	std	Z+3, r1	; 0x03
    39b8:	d7 cf       	rjmp	.-82     	; 0x3968 <free+0xc0>

000039ba <memcmp>:
memcmp():
    39ba:	fb 01       	movw	r30, r22
    39bc:	dc 01       	movw	r26, r24
    39be:	04 c0       	rjmp	.+8      	; 0x39c8 <memcmp+0xe>
    39c0:	8d 91       	ld	r24, X+
    39c2:	01 90       	ld	r0, Z+
    39c4:	80 19       	sub	r24, r0
    39c6:	21 f4       	brne	.+8      	; 0x39d0 <memcmp+0x16>
    39c8:	41 50       	subi	r20, 0x01	; 1
    39ca:	50 40       	sbci	r21, 0x00	; 0
    39cc:	c8 f7       	brcc	.-14     	; 0x39c0 <memcmp+0x6>
    39ce:	88 1b       	sub	r24, r24
    39d0:	99 0b       	sbc	r25, r25
    39d2:	08 95       	ret

000039d4 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    39d4:	f8 94       	cli

000039d6 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    39d6:	ff cf       	rjmp	.-2      	; 0x39d6 <__stop_program>
